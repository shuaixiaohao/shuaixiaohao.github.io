{"meta":{"title":"帅小昊-博客","subtitle":"心有多大，舞台就有多大","description":null,"author":"冯  昊","url":"https://shuaixiaohao.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-05-16T14:42:02.636Z","updated":"2018-06-23T12:25:29.591Z","comments":true,"path":"about/index.html","permalink":"https://shuaixiaohao.github.io/about/index.html","excerpt":"","text":"GitHub ID: shuaixiaohao 新浪微博： 馮昊-FengHao Email : 1073510119@qq.com University: Hebei University of Engineering 大家好，我叫冯昊，是一名python开发工程师 哈哈哈 哈哈 哈"},{"title":"分类","date":"2019-05-16T14:42:02.770Z","updated":"2018-06-29T15:58:03.598Z","comments":true,"path":"categories/index.html","permalink":"https://shuaixiaohao.github.io/categories/index.html","excerpt":"","text":""},{"title":"photos","date":"2018-07-02T14:13:23.000Z","updated":"2018-07-02T14:13:23.767Z","comments":true,"path":"photos/index.html","permalink":"https://shuaixiaohao.github.io/photos/index.html","excerpt":"","text":""},{"title":"sponsor","date":"2018-05-26T04:51:14.000Z","updated":"2018-06-23T05:46:09.957Z","comments":true,"path":"sponsor/index.html","permalink":"https://shuaixiaohao.github.io/sponsor/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-05-16T14:42:02.787Z","updated":"2018-06-29T15:58:35.049Z","comments":true,"path":"tags/index.html","permalink":"https://shuaixiaohao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"kNN","slug":"KNN","date":"2019-05-23T14:29:31.000Z","updated":"2019-05-23T14:40:11.091Z","comments":true,"path":"2019/05/23/KNN/","link":"","permalink":"https://shuaixiaohao.github.io/2019/05/23/KNN/","excerpt":"kNN – k近邻算法K Nearest Neighbor，也称为k近邻算法 ，可以这样理解它： 先读出一堆分好类的数据点，每一个数据点在坐标轴上都有一个位置，标记他们的分类 归一化数据 计算我们要预测的数据 X 到每个数据点的距离，并且排序 选取与X点最近的K个点，确定哪个分类的出现次数最多，那么我们就预测这个数据 X 属于这个出现次数最多的分类","text":"kNN – k近邻算法K Nearest Neighbor，也称为k近邻算法 ，可以这样理解它： 先读出一堆分好类的数据点，每一个数据点在坐标轴上都有一个位置，标记他们的分类 归一化数据 计算我们要预测的数据 X 到每个数据点的距离，并且排序 选取与X点最近的K个点，确定哪个分类的出现次数最多，那么我们就预测这个数据 X 属于这个出现次数最多的分类 简单地说，k近邻算法采用测量不同特征值之间的距离方法进行分类。 ​ 优点：精度高、对异常值不敏感、无数据输入假定。 ​ 缺点：计算复杂度高、空间复杂度高。 ​ 适用数据范围：数值型和标称型。 类别分析例： 导入包 12345678import numpy as npimport pandas as pdfrom pandas import Series,DataFrameimport matplotlib.pyplot as plt%matplotlib inline# KNeighborsClassifier分类模型，可以处理分类问题from sklearn.neighbors import KNeighborsClassifier 123# 获取数据samples = pd.read_excel(&apos;films.xlsx&apos;)samples 123456789101112131415161718192021222324252627282930313233# 获取特征集合和标签集合train = samples[['动作镜头','谈情镜头']]target = samples['类别']# 构建算法模型对象# n_neighbors一般为奇数knn = KNeighborsClassifier(n_neighbors=5)# 训练算法模型knn.fit(train,target)KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski', metric_params=None, n_jobs=1, n_neighbors=5, p=2, weights='uniform')# 预测数据X_test = np.array([[3,18],[23,5]])y_ = knn.predict(X_test)# 绘制样本空间def transform_target(x): if x == '动作': return 1 else: return 0 number_target = target.map(transform_target)plt.scatter(train.values[:,0],train.values[:,1],c=number_target)plt.scatter(X_test[:,0],X_test[:,1])plt.xlabel('action')plt.ylabel('love')&gt;&gt;&gt; 12345# k值的取值范围 不大于样本集数量的平方根knn1 = KNeighborsClassifier(n_neighbors=3)knn1.fit(train,target)X_test = np.array([[3,18],[23,5],[90,1]])knn1.predict(X_test) KNN处理回归例： 12345678import numpy as npimport pandas as pdfrom pandas import Series,DataFrameimport matplotlib.pyplot as plt%matplotlib inline# 回归模型from sklearn.neighbors import KNeighborsRegressor 1234# 生成一组符合正弦分布的数据样本点，x就是样本，y样本标签x = np.linspace(0,2*np.pi,40)y = np.sin(x)plt.scatter(x,y) 12# 创建噪音数据，模拟真实环境noise = np.random.random(size=20)*0.6-0.3 123# 把噪音数据添加到样本标签中，查看包含噪声的数据分布情况y[::2] += noiseplt.scatter(x,y) 123456789101112131415161718192021# 分别训练三种不同k值的knn回归器，预测结果，查看预测情况knn1 = KNeighborsRegressor(n_neighbors=5)knn1.fit(x.reshape(-1,1),y)knn2 = KNeighborsRegressor(n_neighbors=1)knn2.fit(x.reshape(-1,1),y)knn3 = KNeighborsRegressor(n_neighbors=15)knn3.fit(x.reshape(-1,1),y)X_test = np.linspace(x.min(),x.max(),100).reshape(-1,1)y1_ = knn1.predict(X_test)y2_ = knn2.predict(X_test)y3_ = knn3.predict(X_test)# 红色线属于过拟合 产生原因：对样本数据学习太完美，受到一些个体特影响# 蓝色线属于欠拟合 产生原因：对数据样本学习不够详细，没有学习到普遍特征# 黄色线属于最佳拟合，plt.plot(X_test,y1_,label='preidct k=5',color='orange')plt.plot(X_test,y2_,label='preidct k=1',color='red')plt.plot(X_test,y3_,label='preidct k=15',color='cyan')plt.scatter(x,y,label='true_data',color='blue')plt.legend()","categories":[{"name":"算法","slug":"算法","permalink":"https://shuaixiaohao.github.io/categories/算法/"}],"tags":[{"name":"KNN","slug":"KNN","permalink":"https://shuaixiaohao.github.io/tags/KNN/"}]},{"title":"数据分析","slug":"数据分析","date":"2018-01-21T14:29:31.000Z","updated":"2019-02-01T11:50:59.381Z","comments":true,"path":"2018/01/21/数据分析/","link":"","permalink":"https://shuaixiaohao.github.io/2018/01/21/数据分析/","excerpt":"数据分析三剑客 numpy、 pandas、 matplotlib NumPyNumPy 是什么？​ NumPy是Python中用于科学计算的基础包。它是一个Python库，提供多维数组对象，各种派生的对象（如掩码数组和矩阵），以及数组快速操作的各种各样的例程，包括数学、逻辑、图形操作，排序、选择、I/O、离散傅里叶变换、基本线性代数、基本统计操作，随机模拟以及其他。","text":"数据分析三剑客 numpy、 pandas、 matplotlib NumPyNumPy 是什么？​ NumPy是Python中用于科学计算的基础包。它是一个Python库，提供多维数组对象，各种派生的对象（如掩码数组和矩阵），以及数组快速操作的各种各样的例程，包括数学、逻辑、图形操作，排序、选择、I/O、离散傅里叶变换、基本线性代数、基本统计操作，随机模拟以及其他。 ​ NumPy包的核心是ndarray对象。它封装了均匀数据类型的n维数组，带有一些在编译过的代码中执行的操作。NumPy数组和Python标准列表有一些重要的差异： NumPy数组在创建时有固定的大小，不像Python列表（可动态增长）。改变一个ndarray的大小将创建一个新数组，并删除原有数组。 NumPy数组中的元素都必须是相同的数据类型，从而具有相同的内存大小。但有个例外：（Python，包括NumPy）对象数组的元素大小是不同的。 NumPy数组使大量数据上的高级数学运算和其他类型的操作变得容易。通常情况下，这样的操作可能比使用Python的内置列表效率更高，执行的代码更少。 越来越多的基于Python的科学和数学包使用NumPy数组；虽然它们通常支持Python列表作为输入，但他们会在处理之前将这些输入转换为NumPy数组，并总是输出NumPy数组。换句话说，为了高效使用许多（也许甚至是大多数）当今基于Python的科学/数学软件，只要知道如何使用Python的内置列表类型是不够的————你还需要知道如何使用NumPy数组。 Ndarray 对象NumPy 中定义的最重要的对象是称为 ndarray 的 N 维数组类型。 它描述相同类型的元素集合。 可以使用基于零的索引访问集合中的项目。 ndarray中的每个元素在内存中使用相同大小的块。 ndarray中的每个元素是数据类型对象的对象(称为 dtype)。 创建ndarray导入numpy库 1import numpy as np 使用np.array()创建多维数组 参数为列表： np.array([1,2,3]) 注意： numpy默认ndarray的所有元素的类型是相同的 如果传进来的列表中包含不同的类型，则统一为同一类型，优先级：str&gt;float&gt;int 12np.array([1,2,\"3\"])&gt;&gt;&gt;array(['1', '2', '3'], dtype='&lt;U11') 使用np的常用函数(routines)创建 包含以下常见创建方法： ​ 1、np.ones(shape, dtype=None, order=’C’) 功能：按照指定形状创建多维数组，并用1填充 参数： shape 用于指定创建的多维数组的形状 可以传入2 或者 (2,3) dtype 数据的类型 np.int8 np.float64 返回值：返沪创建好的多维数组数组 ​ 2、np.zeros(shape, dtype=float, order=’C’) 功能类似np.zeros只不过不是用1填充 而是用0填充 ​ 3、np.full(shape, fill_value, dtype=None, order=’C’) shape指定形状 一般可以是 2 或者 (2,3) 之类的 fill_value指定填充的值 123np.full(shape=(2,3),fill_value=5)&gt;&gt;&gt;array([[5, 5, 5], [5, 5, 5]]) ​ 4、np.eye(N, M=None, k=0, dtype=floa 功能：创建一个方阵（行和列的数量相等） N 指定矩阵中有多少行和列 对角线为1其他的位置为0（单位矩阵） ​ 5、 np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) 功能：把start到stop的这个范围的数，等分成num份儿，填入数组 ​ 6、np.logspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) 功能：把start到stop的这个范围的数，等分成num份儿，获得的值作为10的指数，求出来的值，填入数组 ​ 7、 np.arange([start, ]stop, [step, ]dtype=None) 从start，到end，每隔step去一个值，放入一个数组 ​ 8、np.random.randint(low, high=None, size=None, dtype=’l’) 从low到high的范围随机取整数，填充多维数组 size用于指定数组的形状 如 2 (2,3) ​ 9、np.random.randn(d0, d1, …, dn) 传入几个参数，就创建几维数组 产生以0为中心 方差为1 的 标准正太分布 的随机数 填充数组 如 np.random.randn(2,3,3) 产生一个三维数组 数组中有两个数组 两个数组中分别有三个数组 三个数组中每个都有三个元素 ​ 10、np.random.normal(loc=0.0, scale=1.0, size=None) np.random.randn是标准正态分布（以0为中心，方差是1） normal可以指定中心和方差 loc 正态分别的中心 scale 正态分布的变化范围 size 数组的形状 如 2 (2,3) ​ 11、np.random.random(size=None) size指定三维数组的形状 如 2 (2,3) 函数随机生成0到1的随机数（左闭右开）填充数组 ndarray的属性4个必记参数： ndim：维度 shape：形状（各维度的长度） size：总长度 dtype：元素类型 MatplotlibMatplotlib 是 Python 的绘图库。 它可与 NumPy 一起使用，提供了一种有效的 MatLab 开源替代方案。 它也可以和图形工具包一起使用，如 PyQt 和 wxPython。 1.引入matplotlib.pyplot 1import matplotlib.pyplot as plt 2.读取图片 pyplot.imread(要读取的文件路的径字) 1jin = plt.imread(&quot;./jin.png&quot;) 3.查看引入的图片的属性（其实图片就是一个三维数组） 123456jin # 其实图片就是一个三维数组 jin.ndim # ndarray的ndim属性可以查看当前多维数组的维度jin.shape #一个多维数组 里面有273个数组 这273个数组里面分别有411个数组 411个数组中有三个元素 这个三个元素分别对应 r g b 的值jin.size #多维数组的总长度jin.dtype #里面元素的数据类型jin.shape 4.根据传入的数据去绘制图片 pyplot.imshow(传入多维数组数据) ndarray的基本操作索引ndarray对象的内容可以通过索引或切片来访问和修改，就像 Python 的内置容器对象一样。 如前所述，ndarray对象中的元素遵循基于零的索引。 有三种可用的索引方法类型： 字段访问，基本切片和高级索引。 基本切片是 Python 中基本切片概念到 n 维的扩展。 通过将start，stop和step参数提供给内置的slice函数来构造一个 Python slice对象。 此slice对象被传递给数组来提取数组的一部分。 基本索引：一维与列表完全一致 多维时同理 切片 一维与列表切片完全一致 多维时同理 12345678910nd = np.random.randint(0,10,size=(5,4))&gt;&gt;&gt;nd[1:3]nd[1:3,0:2] # 从外往里 层层切片# start:end# start:end:stepnd[0:4:2,0:4:2]nd[::2,::2]nd[::-1] # 把最外围的顺序颠倒nd[:,::-1] #把往里一维的内部元素的顺序颠倒 变形使用reshape函数，注意参数是一个tuple！ 连结 np.concatenate() 连结需要注意的点： 连结的参数是列表：一定要加小括号 维度必须相同 形状相符 连结的方向默认是shape这个tuple的第一个值所代表的维度方向 可通过axis参数改变连结的方向 切分与级联类似，三个函数完成切分工作： np.split 参数 1.要切分的数组 ；2.要分成几份； 3切分时候的轴（axis默认是0） np.vsplit vertical ，对垂直方向的元素进行切割（切割的时候是水平去切的） np.hsplit horizon ，对水平方向上的元素进行切割（切的时候垂直切） 副本所有赋值运算不会为ndarray的任何元素创建副本。对赋值后的对象的操作也对原来的对象生效。 可使用copy()函数创建副本 1ndarr2 = ndarr.copy() #多维数组调用自身的copy()方法 就会返回一个一模一样 但是完全独立的数组 ndarray的聚合操作求和np.sum最大最小值：np.max/ np.min其他聚合操作123456789101112131415Function Name NaN-safe Version Descriptionnp.sum np.nansum Compute sum of elementsnp.prod np.nanprod Compute product of elementsnp.mean np.nanmean Compute mean of elementsnp.std np.nanstd Compute standard deviationnp.var np.nanvar Compute variancenp.min np.nanmin Find minimum valuenp.max np.nanmax Find maximum valuenp.argmin np.nanargmin Find index of minimum valuenp.argmax np.nanargmax Find index of maximum valuenp.median np.nanmedian Compute median of elementsnp.percentile np.nanpercentile Compute rank-based statistics of elementsnp.any N/A Evaluate whether any elements are truenp.all N/A Evaluate whether all elements are truenp.power 幂运算 操作文件使用pandas打开文件president_heights.csv 获取文件中的数据 123import pandas as pd# csv comma seperated value 逗号 分隔 的 值data = pd.read_csv(\"./president_heights.csv\") ndarray的矩阵操作基本矩阵操作1) 算术运算符： 加减乘除 123456789101112ndarr = np.random.randint(0,10,size=(4,5))ndarr&gt;&gt;&gt;array([[4, 3, 5, 5, 2], [3, 0, 5, 1, 3], [4, 0, 1, 5, 1], [2, 0, 9, 1, 3]])# 矩阵和数值的运算ndarr + 1 # 矩阵和数值做加法 给矩阵中所有的值都加上这个数 广播机制ndarr - 1 # 矩阵中每一个值都减这个数值ndarr * 2 # 每个值都乘以这个数值ndarr / 2 # 每个值都除以这个数值 2) 矩阵积numpy.dot() 此函数返回两个数组的点积。 对于二维向量，其等效于矩阵乘法。 对于一维数组，它是向量的内积。 对于 N 维数组，它是a的最后一个轴上的和与b的倒数第二个轴的乘积。 12345import numpy as np a = np.array([[1,2],[3,4]]) b = np.array([[11,12],[13,14]]) np.dot(a,b) 输出如下： 12[[37 40] [85 92]] #[[1*11+2*13, 1*12+2*14],[3*11+4*13, 3*12+4*14]] 广播机制广播是指 NumPy 在算术运算期间处理不同形状的数组的能力。 对数组的算术运算通常在相应的元素上进行。 如果两个阵列具有完全相同的形状，则这些操作被无缝执行。 如果两个数组的维数不相同，则元素到元素的操作是不可能的。 然而，在 NumPy 中仍然可以对形状不相似的数组进行操作，因为它拥有广播功能。 较小的数组会广播到较大数组的大小，以便使它们的形状可兼容。 如果满足以下规则，可以进行广播： ndim较小的数组会在前面追加一个长度为 1 的维度。 输出数组的每个维度的大小是输入数组该维度大小的最大值。 如果输入在每个维度中的大小与输出大小匹配，或其值正好为 1，则在计算中可它。 如果输入的某个维度大小为 1，则该维度中的第一个数据元素将用于该维度的所有计算。 如果上述规则产生有效结果，并且满足以下条件之一，那么数组被称为可广播的。 数组拥有相同形状。 数组拥有相同的维数，每个维度拥有相同长度，或者长度为 1。 数组拥有极少的维度，可以在其前面追加长度为 1 的维度，使上述条件成立。 【重要】ndarray广播机制规则 缺失元素用已有值填充 1234567891011121314a = np.arange(3).reshape((3, 1))&gt;&gt;&gt;array([[0], [1], [2]])b = np.arange(3)&gt;&gt;&gt;array([0, 1, 2])a + b&gt;&gt;&gt;array([[0, 1, 2], [1, 2, 3], [2, 3, 4]]) ndarray的排序快速排序numpy.sort()与ndarray.sort()都可以，但有区别： numpy.sort()不改变输入 ndarray.sort()本地处理，不占用空间，但改变输入 部分排序np.partition(a,k) 有的时候我们不是对全部数据感兴趣，我们可能只对最小或最大的一部分感兴趣。 当k为正时，我们想要得到最小的k个数 当k为负时，我们想要得到最大的k个数 12345678ndarr3 = np.random.randint(0,100,size=15)&gt;&gt;&gt; array([89, 2, 20, 55, 76, 96, 92, 22, 23, 92, 13, 65, 15, 10, 52])numpy.partition(ndarr3,3)&gt;&gt;&gt; array([ 2, 10, 13, 15, 20, 22, 23, 52, 92, 92, 96, 65, 76, 55, 89]) # 前面三个最小排序numpy.partition(ndarr3,-5)&gt;&gt;&gt; array([ 2, 22, 20, 10, 15, 13, 23, 52, 55, 65, 76, 89, 92, 96, 92]) # 后面五个最大排序 字符串函数以下函数用于对dtype为numpy.string_或numpy.unicode_的数组执行向量化字符串操作。 它们基于 Python 内置库中的标准字符串函数。 序号 函数及描述 1. add() 返回两个str或Unicode数组的逐个字符串连接 2. multiply() 返回按元素多重连接后的字符串 3. center() 返回给定字符串的副本，其中元素位于特定字符串的中央 4. capitalize() 返回给定字符串的副本，其中只有第一个字符串大写 5. title() 返回字符串或 Unicode 的按元素标题转换版本 6. lower() 返回一个数组，其元素转换为小写 7. upper() 返回一个数组，其元素转换为大写 8. split() 返回字符串中的单词列表，并使用分隔符来分割 9. splitlines() 返回元素中的行列表，以换行符分割 10. strip() 返回数组副本，其中元素移除了开头或者结尾处的特定字符 11. join() 返回一个字符串，它是序列中字符串的连接 12. replace() 返回字符串的副本，其中所有子字符串的出现位置都被新字符串取代 13. decode() 按元素调用str.decode 14. encode() 按元素调用str.encode 这些函数在字符数组类(numpy.char)中定义。 较旧的 Numarray 包包含chararray类。 numpy.char类中的上述函数在执行向量化字符串操作时非常有用。 numpy.char.add()函数执行按元素的字符串连接。 12345678910import numpy as np print &apos;连接两个字符串：&apos; print np.char.add([&apos;hello&apos;],[&apos; xyz&apos;]) print &apos;\\n&apos;print &apos;连接示例：&apos; print np.char.add([&apos;hello&apos;, &apos;hi&apos;],[&apos; abc&apos;, &apos; xyz&apos;])Python 输出如下： 12345连接两个字符串：[&apos;hello xyz&apos;]连接示例：[&apos;hello abc&apos; &apos;hi xyz&apos;] numpy.char.multiply()这个函数执行多重连接。 12345import numpy as np print np.char.multiply(&apos;Hello &apos;,3)Python 输出如下： 1234Hello Hello HelloPython numpy.char.center()此函数返回所需宽度的数组，以便输入字符串位于中心，并使用fillchar在左侧和右侧进行填充。 123456import numpy as np # np.char.center(arr, width,fillchar) print np.char.center(&apos;hello&apos;, 20,fillchar = &apos;*&apos;)Python 输出如下： 1234*******hello********Python numpy.char.capitalize()函数返回字符串的副本，其中第一个字母大写 12345import numpy as np print np.char.capitalize(&apos;hello world&apos;)Python 输出如下： 1Hello world numpy.char.title()返回输入字符串的按元素标题转换版本，其中每个单词的首字母都大写。 12345import numpy as np print np.char.title(&apos;hello how are you?&apos;)Python 输出如下： 1Hello How Are You? numpy.char.lower()函数返回一个数组，其元素转换为小写。它对每个元素调用str.lower。 123456import numpy as np print np.char.lower([&apos;HELLO&apos;,&apos;WORLD&apos;]) print np.char.lower(&apos;HELLO&apos;)Python 输出如下： 12345[&apos;hello&apos; &apos;world&apos;]helloPython numpy.char.upper()函数返回一个数组，其元素转换为大写。它对每个元素调用str.upper。 123456import numpy as np print np.char.upper(&apos;hello&apos;) print np.char.upper([&apos;hello&apos;,&apos;world&apos;])Python 输出如下： 12345HELLO[&apos;HELLO&apos; &apos;WORLD&apos;]Python numpy.char.split()此函数返回输入字符串中的单词列表。 默认情况下，空格用作分隔符。 否则，指定的分隔符字符用于分割字符串。 123456import numpy as np print np.char.split (&apos;hello how are you?&apos;) print np.char.split (&apos;YiibaiPoint,Hyderabad,Telangana&apos;, sep = &apos;,&apos;)Python 输出如下： 12345[&apos;hello&apos;, &apos;how&apos;, &apos;are&apos;, &apos;you?&apos;][&apos;YiibaiPoint&apos;, &apos;Hyderabad&apos;, &apos;Telangana&apos;]Python numpy.char.splitlines()函数返回数组中元素的单词列表，以换行符分割。 123456import numpy as np print np.char.splitlines(&apos;hello\\nhow are you?&apos;) print np.char.splitlines(&apos;hello\\rhow are you?&apos;)Python 输出如下： 12345[&apos;hello&apos;, &apos;how are you?&apos;][&apos;hello&apos;, &apos;how are you?&apos;]Python &#39;\\n&#39;，&#39;\\r&#39;，&#39;\\r\\n&#39;都会用作换行符。 numpy.char.strip()函数返回数组的副本，其中元素移除了开头或结尾处的特定字符。 123456import numpy as np print np.char.strip(&apos;ashok arora&apos;,&apos;a&apos;) print np.char.strip([&apos;arora&apos;,&apos;admin&apos;,&apos;java&apos;],&apos;a&apos;)Python 输出如下： 12shok aror[&apos;ror&apos; &apos;dmin&apos; &apos;jav&apos;] numpy.char.join()这个函数返回一个字符串，其中单个字符由特定的分隔符连接。 123456import numpy as np print np.char.join(&apos;:&apos;,&apos;dmy&apos;) print np.char.join([&apos;:&apos;,&apos;-&apos;],[&apos;dmy&apos;,&apos;ymd&apos;])Python 输出如下： 12345d:m:y[&apos;d:m:y&apos; &apos;y-m-d&apos;]Python numpy.char.replace()这个函数返回字符串副本，其中所有字符序列的出现位置都被另一个给定的字符序列取代。 12345import numpy as np print np.char.replace (&apos;He is a good boy&apos;, &apos;is&apos;, &apos;was&apos;)Python 输出如下： 1He was a good boy numpy.char.decode()这个函数在给定的字符串中使用特定编码调用str.decode()。 12345678import numpy as np a = np.char.encode(&apos;hello&apos;, &apos;cp500&apos;) print a print np.char.decode(a,&apos;cp500&apos;)Python 输出如下： 12\\x88\\x85\\x93\\x93\\x96hello numpy.char.encode()此函数对数组中的每个元素调用str.encode函数。 默认编码是utf_8，可以使用标准 Python 库中的编解码器。 123456import numpy as np a = np.char.encode(&apos;hello&apos;, &apos;cp500&apos;) print aPython 输出如下： 1\\x88\\x85\\x93\\x93\\x96 Pandas​ 官方文档 数据分析三剑客 numpy pandas matplotlib Pandas介绍Pandas是一个开放源码的Python库，它使用强大的数据结构提供高性能的数据操作和分析工具。它的名字：Pandas是从Panel Data - 多维数据的计量经济学(an Econometrics from Multidimensional data)。 2008年，为满足需要高性能，灵活的数据分析工具，开发商Wes McKinney开始开发Pandas。 在Pandas之前，Python主要用于数据迁移和准备。它对数据分析的贡献更小。 Pandas解决了这个问题。 使用Pandas可以完成数据处理和分析的五个典型步骤，而不管数据的来源 - 加载，准备，操作，模型和分析。 Python Pandas用于广泛的领域，包括金融，经济，统计，分析等学术和商业领域。 Pandas的主要特点 快速高效的DataFrame对象，具有默认和自定义的索引。 将数据从不同文件格式加载到内存中的数据对象的工具。 丢失数据的数据对齐和综合处理。 重组和摆动日期集。 基于标签的切片，索引和大数据集的子集。 可以删除或插入来自数据结构的列。 按数据分组进行聚合和转换。 高性能合并和数据加入。 时间序列功能。 数据结构Pandas处理以下三个数据结构 - 系列(Series) 数据帧(DataFrame) 面板(Panel) 这些数据结构构建在Numpy数组之上，这意味着它们很快。 维数和描述 考虑这些数据结构的最好方法是，较高维数据结构是其较低维数据结构的容器。 例如，DataFrame是Series的容器，Panel是DataFrame的容器。 数据结构 维数 描述 系列 1 1D标记均匀数组，大小不变。 数据帧 2 一般2D标记，大小可变的表结构与潜在的异质类型的列。 面板 3 一般3D标记，大小可变数组。 构建和处理两个或更多个维数组是一项繁琐的任务，用户在编写函数时要考虑数据集的方向。 但是使用Pandas数据结构，减少了用户的思考。 例如，使用表格数据(DataFrame)，在语义上更有用于考虑索引(行)和列，而不是轴0和轴1。 可变性 所有Pandas数据结构是值可变的(可以更改)，除了系列都是大小可变的。系列是大小不变的。 注 - DataFrame被广泛使用，是最重要的数据结构之一。面板使用少得多。 系列（Series）系列是具有均匀数据的一维数组结构。例如，以下系列是整数：10,23,56，...的集合。 关键点 均匀数据 尺寸大小不变 数据的值可变 数据帧（DataFrame）数据帧(DataFrame)是一个具有异构数据的二维数组。 关键点 异构数据 大小可变 数据可变 面板（Panel）面板是具有异构数据的三维数据结构。在图形表示中很难表示面板。但是一个面板可以说明为DataFrame的容器。 关键点 异构数据 大小可变 数据可变 Series（系列）Series是一种类似于一维数组的对象，由下面两个部分组成： index：相关的数据索引标签 values：一组数据（ndarray类型） 1. Series的创建两种创建方式： (1) 由列表或numpy数组创建 12默认索引为0到N-1的整数型索引Series([1,2,3],index=(\"a\",\"b\",\"c\")) # 通过index可以指定索引 注意：索引的个数和值的个数要对应 (2) 由字典创建 12345Series(&#123;\"A\":10,\"B\":20,\"C\":30&#125;)&gt;&gt;&gt; A 10 B 20 C 30 dtype: int64 2. Series的索引和切片可以使用中括号取单个索引（此时返回的是元素类型），或者中括号里一个列表取多个索引（此时返回的仍然是一个Series类型）。分为显示索引和隐式索引： (1) 显式索引： 12- 使用index中的元素作为索引值- 使用.loc[]（推荐） 注意，此时是闭区间 (2) 隐式索引： 12- 使用整数作为索引值- 使用.iloc[]（推荐） 注意，此时是半开区间 根据索引对Series进行切片 12345678s1&gt;&gt;&gt; 语文 150 数学 150 英语 150 理综 300 dtype: int64s1.loc[&apos;语文&apos;:&apos;英语&apos;]s1.iloc[0:4] 3. Series的常用属性和方法 可以把Series看成一个定长的有序字典 可以通过shape，size，index,values等得到series的属性 head(),tail()快速查看Series对象的样式 例：s.head(2)看头两个 s.tail(1)看后一个 当索引没有对应的值时，可能出现缺失数据显示NaN（not a number）的情况 使用pd.isnull()，pd.notnull()，或自带isnull(),notnull()函数检测缺失数据 Series对象本身及其实例都有一个name属性 12345Series([1,2,3],index=(\"a\",\"b\",\"c\"),name=\"张三\")&gt;&gt;&gt; a 1 b 2 c 3 Name: 张三, dtype: int64 4. Series的运算(1) 适用于numpy的数组运算也适用于Series (2) Series之间的运算 在运算中自动对齐不同索引的数据 如果索引不对应，则补NaN 注意：要想保留所有的index，则需要使用.add()函数 123456789101112131415161718192021222324s1&gt;&gt;&gt; 语文 150 数学 150 dtype: int64 s3&gt;&gt;&gt; a 1 b 2 Name: 张三, dtype: int64 s1 + s3 # 两个Series进行加和时，如果索引不对应，返回值 nan&gt;&gt;&gt; a NaN b NaN 语文 NaN 数学 NaN dtype: float64# 索引不对应 就出NaN 如果不喜欢这样可以调用 series自身的add（）方法s1.add(s3)&gt;&gt;&gt; a 1.0 b 2.0 语文 150.0 数学 150.0 dtype: float64 DataFrame（数据帧）DataFrame是一个【表格型】的数据结构，可以看做是【由Series组成的字典】（共用同一个索引）。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到多维。DataFrame既有行索引，也有列索引。 行索引：index 列索引：columns 值：values（numpy的二维数组） pandas中的DataFrame可以使用以下构造函数创建 - 1pandas.DataFrame( data, index, columns, dtype, copy) 构造函数的参数如下 - 编号 参数 描述 1 data 数据采取各种形式，如:ndarray，series，map，lists，dict，constant和另一个DataFrame。 2 index 对于行标签，要用于结果帧的索引是可选缺省值np.arrange(n)，如果没有传递索引值。 3 columns 对于列标签，可选的默认语法是 - np.arange(n)。 这只有在没有索引传递的情况下才是这样。 4 dtype 每列的数据类型。 5 copy 如果默认值为False，则此命令(或任何它)用于复制数据。 1. DataFrame的创建最常用的方法是传递一个字典来创建。DataFrame以字典的键作为每一【列】的名称，以字典的值（一个数组）作为每一列。 此外，DataFrame会自动加上每一行的索引（和Series一样）。 同Series一样，若传入的列与字典的键不匹配，则相应的值为NaN。 123456789101112import numpy as npfrom pandas import DataFramedata = np.random.randint(0,150,size=(4,4))index = ['张三','李四','王五','小六']df = DataFrame(data, index=index,columns=['Math','Chinese','English','Python'])&gt;&gt;&gt; Math Chinese English Python 张三 41 47 19 114 李四 16 43 77 115 王五 116 148 92 74 小六 93 72 26 59 2. DataFrame的索引(1) 对 列 进行索引 ​ – 通过类似字典的方式 ​ – 通过属性的方式 可以将DataFrame的列获取为一个Series。返回的Series拥有原DataFrame相同的索引，且name属性也已经设置好了，就是相应的列名。 每一行是一个样本 每一列是描述这个样本的维度 (2) 对 行 进行索引 ​ – 使用.loc[]加index来进行行索引 ​ – 使用.iloc[]加整数来进行行索引 同样返回一个Series，index为原来的columns。 总结： ​ columns 才能以索引的形式去找 df [“列名”] 、df.列名 ​ index 不能用索引的方式去找 只能用 loc[] 和 iloc[] 去定位内容 (3) 对元素进行索引 ​ – 使用列索引 ​ – 使用行索引( iloc[3,1]相当于两个参数; iloc[[3,3]] 里面的[3,3]看做一个参数) ​ – 使用values属性（二维numpy数组） 【注意】 直接用中括号 [ ] 时： 索引表示的是列索引 切片表示的是行切片 3. DataFrame的运算（1） DataFrame和数值的运算 12DataFrame + 1 # 所有内容都加一# 还有列与行 （2） DataFrame与DataFrame之间的运算 同Series一样： 在运算中自动对齐不同索引的数据 如果索引不对应，则补NaN 下面是Python 操作符与pandas操作函数的对应表： Python Operator Pandas Method(s) + add() - sub(), subtract() * mul(), multiply() / truediv(), div(), divide() // floordiv() % mod() ** pow() （3） DataFrame和Series之间的运算 【重要】 使用Python操作符：以行为单位操作（参数必须是行），对所有行都有效。（类似于numpy中二维数组与一维数组的运算，但可能出现NaN） 使用pandas操作函数： ​ – axis=0：以列为单位操作（参数必须是列），对所有列都有效。 -- axis=1：以行为单位操作（参数必须是行），对所有行都有效。 空数据处理检查缺失值​ isnull()和notnull()函数 ,它们也是Series和DataFrame对象的方法 配合any使用，可以查看每一 行 / 列 是否存在空值 可以控制axis来改变查看方向 12345df1 = DataFrame(data=np.random.randint(0,20,size=(5,5)),columns=list(\"abcde\"))# 如果想看每一行的 中 有没有空值 可以改变axisdf1.isnull().any()df1.isnull().any(axis=0) # axis 默认是 0 是竖直方向df1.isnull().any(axis=1) # 通过这种方式 可以找到有空值的样本 过滤丢失数据​ dropna(): 过滤丢失数据 1dropna(axis, how) # axis 删除有NaN的行还是列，how 要有NaN就删 还是全都是NaN才删 123456df1.dropna() # 如果有空值 就把整行都干掉df1.dropna(axis=0) # 默认是对行进行处理df1.dropna(axis=1) # 对有空值的列进行处理df1.dropna(how=\"any\") # 只要有空值 就干掉df1.dropna(how=\"all\") # 这一行所有的值都是空值 才干掉 填充缺少数据​ fillna()函数可以用非空数据“填充”NaN值 ​ – value ：指定填充的值 – method ：指定找前面还是找后面 – axis ：指定是横着找还是竖着找 – limit：限定往前/后找几个 注意：value参数是不能跟method参数共用的 123456789101112df1.fillna(value=0) # 遇到空值 可以设置成我们制定的值df1.fillna(value=10) # 可以指定value值# pad / ffill 从前面找值来填充# backfill/ bfill 从后面找值来填充df1.fillna(method=&quot;ffill&quot;)df1.fillna(method=&quot;bfill&quot;)df1.fillna(method=&quot;ffill&quot;,axis=0) # axis 默认是0 竖直找df1.fillna(method=&quot;ffill&quot;,axis=1) # axis 1 水平找df1.fillna(method=&quot;ffill&quot;,limit=2) # 限制往前找几个 多层索引多层行索引创建MultiIndex（分层索引）对象 该MultiIndex对象是标准Index对象的分层模拟 ，通常将轴标签存储在pandas对象中 数组列表（使用 MultiIndex.from_arrays） 12345index = pd.MultiIndex.from_arrays([[\"期中\",\"期中\",\"期中\",\"期末\",\"期末\",\"期末\"],[\"语文\",\"英语\",\"数学\",\"语文\",\"英语\",\"数学\"]])columns = [\"张三\",\"李四\",\"王五\",\"赵柳\"]data = np.random.randint(0,150,size=(6,4))DataFrame(data,index,columns) 元组数组（使用MultiIndex.from_tuples） 12345index = pd.MultiIndex.from_tuples([(\"期中\",\"语文\"),(\"期中\",\"数学\"),(\"期中\",\"英语\"),(\"期末\",\"语文\"),(\"期末\",\"数学\"),(\"期末\",\"英语\")])columns = [\"张三\",\"李四\",\"王五\",\"赵柳\"]data = np.random.randint(0,150,size=(6,4))DataFrame(data,index,columns) 交叉迭代集（使用 MultiIndex.from_product），最简单，推荐使用 12345index = pd.MultiIndex.from_product([[\"期中\",\"期末\"],[\"语文\",\"数学\",\"英语\"]])columns = [\"张三\",\"李四\",\"王五\",\"赵柳\"]data = np.random.randint(0,150,size=(6,4))DataFrame(data,index,columns) 多层列索引除了行索引index，列索引columns也能用同样的方法创建多层索引 123456789data = np.random.randint(0,150,size=(2,4))index= pd.MultiIndex.from_product([[&quot;期中&quot;,&quot;期末&quot;],[&quot;语文&quot;,&quot;英语&quot;]]) # 多层索引columns = [&quot;张三&quot;,&quot;李四&quot;] #单层索引df1 = DataFrame(data=data,index=columns,columns=index)&gt;&gt;&gt; 期中 期末 语文 英语 语文 英语张三 50 12 89 99李四 119 9 133 102 索引与切片操作Series的操作 【重要】对于Series来说，直接中括号 [ ] 与使用 .loc() 完全一样，推荐使用 .loc 中括号索引和切片。 DataFrame的操作 (1) 可以直接使用列名称来进行列索引 1df1[&quot;期中&quot;][&quot;语文&quot;] (2) 使用行索引需要用 loc() 等函数 12df1.loc[&quot;张三&quot;]df1.iloc[0] 形状变换stack() ​ columns -&gt; index 列标题变行标题（数据也会跟着标题走） ​ level 的值默认为-1（最内层）；取值从外往里 从0递增 1df.stack(level=0) # level 索引的级别 默认是-1 -1就是最里面的 level的值 从外到内 0 1 2 3 unstack() ​ index -&gt; columns 行标题变列标题（数据也会跟着标题走） 聚合操作 功能 描述 count() Number of non-null observations sum() 对 values 求和 mean() values 的平均值 min() 求 values 最小值 max() 求 values 最大值 123# 如果想对 行进行聚合操作 可以调整 axisdf.sum(axis=0) # axis 默认值是0 是对列做加和df.sum(axis=1) 合并、连接pandas的拼接分为两种： 级联：pandas.concat， pandas.append (没有重复数据) 合并：pandas.merge， pandas.join (有重复数据) pandas.concat()级联简单级联 pandas使用pandas.concat函数，与numpy.concatenate函数类似 123pd.concat(objs, axis=0, join='outer', join_axes=None, ignore_index=False, keys=None, levels=None, names=None, verify_integrity=False, copy=True) 参数： objs 传入列表或者元素 里面是要拼接的DataFrame axis 拼接的时候是沿着什么方向 默认值是0 纵向 如果是1就是横向 join 指定了拼接的方式 默认是outer – outer 外联 所有的列都会拼进来 – inner 内联 只有那些两个DataFrame都有的列才会拼进来 join_axes 直接指定那些列要放进来 ignore_index=False 忽略原有索引创建新的索引 （如果索引有重复可以通过忽略原索引来重置） keys 可以把不同的DataFrame分成多组 也可以用来解决index重复的问题 1234567891011121314151617181920212223242526272829df3 = pd.concat((df1,df2)) #默认 axis是0 是纵向拼接&gt;&gt;&gt; 0 1 20 7 4 21 2 7 92 7 6 60 69 93 711 87 25 382 42 15 35# 可以通过 重置索引的方式 去重新让索引不重复# ignore_index=False 忽略原索引 建立新索引 默认是Falsedf3 = pd.concat((df1,df2),ignore_index=True)&gt;&gt;&gt; 0 1 20 7 4 21 2 7 92 7 6 63 69 93 714 87 25 385 42 15 35# axis=1 水平方向拼接df3 = pd.concat((df1,df2),ignore_index=True,axis=1)&gt;&gt;&gt; 0 1 2 3 4 50 7 4 2 69 93 711 2 7 9 87 25 382 7 6 6 42 15 35 不匹配级联 不匹配指的是级联的维度的索引不一致。例如纵向级联时列索引不一致，横向级联时行索引不一致 有3种连接方式： 外连接：补NaN（默认模式） join=’outer’ 内连接：只连接匹配的项 join=’inner’ 连接指定轴 join_axes pandas.append()函数添加由于在后面级联的使用非常普遍，因此有一个函数pandas.append()专门用于在后面添加 1df6.append(df7) # 只能是把行 纵向地 从后 往前 拼接 pandas.merge()合并merge与concat的区别在于，merge需要依据某一共同的行或列来进行合并 使用pd.merge()合并时，会自动根据两者相同column名称的那一列，作为key来进行合并。 注意每一列元素的顺序不要求一致 12pd.merge(left, right, how='inner', on=None, left_on=None, right_on=None,left_index=False, right_index=False, sort=True) 在这里，有以下几个参数可以使用 - left - 一个DataFrame对象。 right - 另一个DataFrame对象。 on - 列(名称)连接，必须在左和右DataFrame对象中存在(找到)。 left_on - 左侧DataFrame中的列用作键，可以是列名或长度等于DataFrame长度的数组。 right_on - 来自右的DataFrame的列作为键，可以是列名或长度等于DataFrame长度的数组。 left_index - 如果为True，则使用左侧DataFrame中的索引(行标签)作为其连接键。 在具有MultiIndex(分层)的DataFrame的情况下，级别的数量必须与来自右DataFrame的连接键的数量相匹配。 right_index - 与右DataFrame的left_index具有相同的用法。 how - 它是left, right, outer以及inner之中的一个，默认为内inner。 – inner 是取交集 两个都有的项目才出现 – outer 是取并集 任何一个表格里出现的项目都会出现 – left 左边的表格有多少项目 这里就有多少项目 – right 右边的表格有多少项目 这里就有多少项目 sort - 按照字典顺序通过连接键对结果DataFrame进行排序。默认为True，设置为False时，在很多情况下大大提高性能。 key的规范化 ​ – 使用on=显式指定哪一列为key,当有多个key相同时使用 ​ – 使用left_on和right_on指定左右两边的列作为key，当左右两边的key都不想等时使用 内合并与外合并 ​ – 内合并：只保留两者都有的key（默认模式） ​ – 外合并 how=’outer’：补NaN ​ – 左合并、右合并：how=’left’，how=’right’， 列冲突的解决 ​ – 当列冲突时，即有多个列名称相同时，需要使用on=来指定哪一个列作为key，配合suffixes指定冲突列名 ​ – 可以使用suffixes=自己指定后缀 IOPandas I/O API是一套像pd.read_csv()一样返回Pandas对象的顶级读取器函数。 读取文本文件(或平面文件)的两个主要功能是read_csv()和read_table()。它们都使用相同的解析代码来智能地将表格数据转换为DataFrame对象 12pandas.read_csv(filepath_or_buffer, sep=&apos;,&apos;, delimiter=None, header=&apos;infer&apos;,names=None, index_col=None, usecols=None) read.csv read.csv从csv文件中读取数据并创建一个DataFrame对象。 123456import pandas as pddf=pd.read_csv(&quot;temp.csv&quot;)print (df)Python 执行上面示例代码，得到以下结果 - 12345678 S.No Name Age City Salary0 1 Tom 28 Toronto 200001 2 Lee 32 HongKong 30002 3 Steven 43 Bay Area 83003 4 Ram 38 Hyderabad 3900Shell 自定义索引 可以指定csv文件中的一列来使用index_col定制索引。 1234567import pandas as pddf=pd.read_csv(&quot;temp.csv&quot;,index_col=[&apos;S.No&apos;])print (df)Python 执行上面示例代码，得到以下结果 - 123456789 Name Age City SalaryS.No 1 Tom 28 Toronto 200002 Lee 32 HongKong 30003 Steven 43 Bay Area 83004 Ram 38 Hyderabad 3900Shell 转换器dtype的列可以作为字典传递。 1234567import pandas as pdimport numpy as npdf = pd.read_csv(&quot;temp.csv&quot;, dtype=&#123;&apos;Salary&apos;: np.float64&#125;)print (df.dtypes)Python 执行上面示例代码，得到以下结果 - 123456789S.No int64Name objectAge int64City objectSalary float64dtype: objectShell 默认情况下，Salary列的dtype是int，但结果显示为float，因为我们明确地转换了类型。 因此，数据看起来像浮点数 - 12345 S.No Name Age City Salary0 1 Tom 28 Toronto 20000.01 2 Lee 32 HongKong 3000.02 3 Steven 43 Bay Area 8300.03 4 Ram 38 Hyderabad 3900.0 header_names使用names参数指定标题的名称。 12345678import pandas as pdimport numpy as npdf=pd.read_csv(&quot;temp.csv&quot;, names=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;,&apos;d&apos;,&apos;e&apos;])print (df)Python 执行上面示例代码，得到以下结果 - 123456789 a b c d e0 S.No Name Age City Salary1 1 Tom 28 Toronto 200002 2 Lee 32 HongKong 30003 3 Steven 43 Bay Area 83004 4 Ram 38 Hyderabad 3900Shell 观察可以看到，标题名称附加了自定义名称，但文件中的标题还没有被消除。 现在，使用header参数来删除它。 如果标题不是第一行，则将行号传递给标题。这将跳过前面的行。 12345678import pandas as pdimport numpy as npdf=pd.read_csv(&quot;temp.csv&quot;,names=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;],header=0)print (df)Python 执行上面示例代码，得到以下结果 - 12345 a b c d e0 1 Tom 28 Toronto 200001 2 Lee 32 HongKong 30002 3 Steven 43 Bay Area 83003 4 Ram 38 Hyderabad 3900 skiprows skiprows跳过指定的行数。参考以下示例代码 - 12345678import pandas as pdimport numpy as npdf=pd.read_csv(&quot;temp.csv&quot;, skiprows=2)print (df)Python 执行上面示例代码，得到以下结果 - 123 2 Lee 32 HongKong 30000 3 Steven 43 Bay Area 83001 4 Ram 38 Hyderabad 3900 去重使用duplicated()函数检测重复的行，返回元素为布尔类型的Series对象，每个元素对应一行，如果该行不是第一次出现，则元素为True（是重复的） 使用drop_duplicates()函数删除重复的行 使用duplicate()函数查看重复的行 12345678910111213141516171819202122232425262728293031323334 python c++ javaA 100 100 100B 90 90 88C 100 100 100D 90 90 87E 100 100 100df.duplicated(keep=\"first\") # 告诉我们 当前行是否重复, default 'first'# 参数默认是 keep=\"first\" 保留开始的 意思是如果发现很多重复的元素 第一个不算重复的 后面的才是# 某一行重复 就返回TrueA FalseB FalseC TrueD FalseE Truedtype: booldf.duplicated(keep=\"last\") # keep last 如果遇到重复的元素 最后一个不算重复的 前面的才算重复# 这一行重复了 就是TrueA TrueB FalseC TrueD FalseE Falsedtype: bool df.duplicated(keep=False) # 只要有和别人完全一样的 不管在开头还是结尾 都算重复# 这一行如果是重复的就返回 TrueA TrueB FalseC TrueD FalseE Truedtype: bool 替换映射映射的含义：创建一个映射关系列表，把values元素和一个特定的标签或者字符串绑定 包含三种操作： replace()函数：替换元素 最重要：map()函数：新建一列 rename()函数：替换索引 replace()函数：替换元素使用replace()函数，对values进行替换操作 Series替换操作 单值替换 普通替换 字典替换(推荐） 多值替换 列表替换 字典替换（推荐） 1234567891011# 单值替换 普通替换s1.replace(to_replace=\"peppa\",value=\"佩琪\")# 单值替换 字典替换（ ）s1.replace(&#123;\"chengdu\":\"成都\"&#125;)# 多值替换 列表替换 s1.replace([要替换的值1,要替换的值2,.....],[替换成什么1,替换成什么2,....])s1.replace([100,np.nan],[\"满分\",\"空值\"])# 多值替换 字典替换（ &#123; 要替换的值:替换成什么,要替换的值:替换成什么 &#125; ）s1.replace(&#123;100:\"满分\",\"peppa\":\"佩琪\"&#125;) Series参数说明： method：对指定的值使用相邻的值填充 limit：设定填充次数 1234# 如果指定value不好 还可以找值来填充s2.replace(to_replace=100,method=\"bfill\") # 从后面找值来替换当前值s2.replace(to_replace=100,method=\"ffill\") # 从前面找s2.replace(to_replace=100,method=\"ffill\",limit=1) # limit 指定是最多往前或者往后 找几个 如果找不到就不填充了 # limit 默认是None不限制 DataFrame替换操作 单值替换 普通替换 按列指定单值替换{列标签：目标值} 多值替换 列表替换 单字典替换（推荐） 12345678910111213# 普通的单值替换df.replace(to_replace='Beijing',value='北京')# 按列指定单值换目标值 (&#123;列索引,待替换值&#125;,目标值)df.replace(&#123;4:'Beijing'&#125;,'首都')# 多值替换 列表进替换# replace([要替换的1，要替换的2...],[替换成1，替换成2])df.replace([66,'甲','shanghai'],[100,'first','上海'])# replace(&#123;要替换的1：替换成的值1，要替换的2：替换成的值2，...&#125;) 可以将没有的值也放在这里 不会报错 将来可以整个项目使用一个过滤器df.replace(&#123;66:100,'乙':'second','Beijing':'BEIJING','没有的值':'也可以放'&#125;)# 我们可以在 字典里面写很多值 字典中的值即使找不到也不会报错 注意：DataFrame中，无法使用method和limit参数 map()函数：新建一列 map(字典) 字典的键要足以匹配所有的数据，否则出现NaN map()可以映射新一列数据 map()中可以使用lambd表达式 map()中可以使用方法，可以是自定义的方法 注意 map()中不能使用sum之类的函数，for循环 1234567 姓名 语文 数学 python php0 小明 90 98 90 981 小红 44 89 44 892 小芳 98 90 90 983 小李 89 44 44 894 李元芳 78 98 98 875 狄仁杰 66 44 44 89 123456789101112# 映射字典map_dic = &#123;&apos;小明&apos;:&apos;北京&apos;,&apos;小红&apos;:&apos;上海&apos;,&apos;小芳&apos;:&apos;北京&apos;, &apos;小李&apos;:&apos;广州&apos;,&apos;李元芳&apos;:&apos;成都&apos;,&apos;狄仁杰&apos;:&apos;成都&apos;&#125;score[&quot;姓名&quot;]&gt;&gt;&gt;0 小明1 小红2 小芳3 小李4 李元芳5 狄仁杰Name: 姓名, dtype: object 1234567891011# map函数不是DataFrame的方法，而是Sereis对象的方法# 可以传入映射字典score[&quot;姓名&quot;].map(map_dic)&gt;&gt;&gt;0 北京1 上海2 北京3 广州4 成都5 成都Name: 姓名, dtype: object 12345678910score[&quot;所在城市&quot;] = score[&quot;姓名&quot;].map(map_dic) # 可以传入字典score&gt;&gt;&gt; 姓名 语文 数学 python php 所在城市0 小明 90 98 90 98 北京1 小红 44 89 44 89 上海2 小芳 98 90 90 98 北京3 小李 89 44 44 89 广州4 李元芳 78 98 98 87 成都5 狄仁杰 66 44 44 89 成都 1234567891011# 还可以传入 拉姆达表达式 如 lambda x:x+10score[&quot;python&quot;]= score[&quot;python&quot;].map(lambda x:x+10)&gt;&gt;&gt;姓名 语文 数学 python php 所在城市0 小明 90 98 100 18 北京1 小红 44 89 54 9 上海2 小芳 98 90 100 18 北京3 小李 89 44 54 9 广州4 李元芳 78 98 108 7 成都5 狄仁杰 66 44 54 9 成都 rename()函数：替换索引对DataFrame的索引名进行更改 , 仍然是新建一个字典 使用rename()函数替换行索引 index 替换行索引 columns 替换列索引 level 指定多维索引的维度 12345score.rename(map_dic) # 默认是替换 行的名称score.rename(columns=map_dic) # 指定columns可以对列名称进行替换score.rename(columns=map_dic,level=0) # 通过level参数 可以指定具体对哪一层级进行替换 score.rename(columns=map_dic,level=1) # 0 是最外层 异常检测和过滤使用 df.describe() 函数查看每一列的描述性统计量 12345678910111213data = np.random.randn(1000,5)df = DataFrame(data)df.describe() &gt;&gt;&gt; 0 1 2 3 4count 1000.000000 1000.000000 1000.000000 1000.000000 1000.000000mean 0.019615 0.008978 0.002853 0.014141 -0.008822std 0.988672 1.013836 1.010433 1.020105 1.023155min -2.842544 -3.892657 -2.630116 -3.175475 -3.86024225% -0.679723 -0.656524 -0.695306 -0.675029 -0.66500650% 0.025267 -0.005455 -0.053128 -0.030491 -0.01647775% 0.718051 0.732615 0.701169 0.702746 0.660637max 2.832537 3.205288 3.456829 3.537849 3.125329 使用std()函数可以求得DataFrame对象每一列的标准差 根据每一列或行的标准差，对DataFrame元素进行过滤。 借助any()或all()函数, 测试是否有True，有一个或以上返回True，反之返回False 对每一列应用筛选条件,去除标准差太大的数据 1234567# 寻找异常数据 太大的 或者 太小的df.mean() # 各个列的平均值 是一个Seriesdf - df.mean() # DataFrame - Series DataFrame中的每一行都和Series做减法 对应的列相减df - df.mean() &gt; 3*df.std()(df - df.mean() &gt; 3*df.std()).any()(df - df.mean() &gt; 3*df.std()).any(axis=1)df[(df - df.mean() &gt; 3*df.std()).any(axis=1)] #找到异常的行 删除特定索引df.drop(labels,inplace = True) 排序Pandas有两种排序方式，它们分别是 - 按标签 按实际值 按标签排序 使用sort_index()方法，通过传递axis参数和排序顺序，可以对DataFrame进行排序。 默认情况下，按照升序对行标签进行排序。 按列排列 通过传递axis参数值为0或1，可以对列标签进行排序。 默认情况下，axis = 0，逐行排列。来看看下面的例子来理解这个概念。 按值排序 像索引排序一样，sort_values()是按值排序的方法。它接受一个by参数，它将使用要与其排序值的DataFrame的列名称。 排序算法 sort_values()提供了从mergeesort，heapsort和quicksort中选择算法的一个配置。Mergesort是唯一稳定的算法。 使用.take()函数排序 12- take()函数接受一个索引列表，用数字表示- eg:df.take([1,3,4,2,5]) 可以借助np.random.permutation()函数随机排序使用.take()函数排序 12- take()函数接受一个索引列表，用数字表示- eg:df.take([1,3,4,2,5]) 可以借助np.random.permutation()函数随机排序 123456789101112131415161718192021222324252627data = np.random.randint(0,100,size=(5,5))index = list('ABCDE')columns = list('甲乙丙丁戊')df = DataFrame(data=data,index=index,columns=columns)&gt;&gt;&gt; 甲 乙 丙 丁 戊A 27 11 28 69 12B 46 15 31 19 28C 22 76 3 17 98D 28 91 73 72 65E 18 46 22 40 64df.take([3,3,3,3]) # 按照索引去取行 顺序随意 还可以重复 还可以不完全 甲 乙 丙 丁 戊D 28 91 73 72 65D 28 91 73 72 65D 28 91 73 72 65D 28 91 73 72 65df.take(np.random.permutation(5)) # 随机排序 （行不会少 也不会重复 只是顺序随机变换） 甲 乙 丙 丁 戊D 28 91 73 72 65B 46 15 31 19 28A 27 11 28 69 12E 18 46 22 40 64C 22 76 3 17 98 随机抽样 当DataFrame规模足够大时，直接使用np.random.randint()函数，就配合take()函数实现随机抽样 123456789np.random.randint(0,5,size=2)&gt;&gt;&gt;array([2, 1])df.take(np.random.randint(0,5,size=2)) # 随机抽样&gt;&gt;&gt; 甲 乙 丙 丁 戊D 28 91 73 72 65C 22 76 3 17 98 分类数据分类处理： 分组：先把数据分为几组 用函数处理：为不同组的数据应用不同的函数以转换数据 合并：把不同组得到的结果合并起来 数据分类处理的核心： ​ – groupby()函数 ​ – groups属性查看分组情况 12345678910111213df = DataFrame(&#123;&apos;item&apos;:[&apos;苹果&apos;,&apos;香蕉&apos;,&apos;橘子&apos;,&apos;香蕉&apos;,&apos;橘子&apos;,&apos;苹果&apos;,&apos;苹果&apos;], &apos;price&apos;:[4,3,3,2.5,4,2,2.8], &apos;color&apos;:[&apos;red&apos;,&apos;yellow&apos;,&apos;yellow&apos;,&apos;green&apos;,&apos;green&apos;,&apos;green&apos;,&apos;yello&apos;], &apos;weight&apos;:[12,20,50,30,20,44,37]&#125;)&gt;&gt;&gt; item price color weight0 苹果 4.0 red 121 香蕉 3.0 yellow 202 橘子 3.0 yellow 503 香蕉 2.5 green 304 橘子 4.0 green 205 苹果 2.0 green 446 苹果 2.8 yello 37 根据item分组,通过groups属性查看结果 12345df.groupby(&quot;item&quot;).groups&gt;&gt;&gt;&#123;&apos;橘子&apos;: Int64Index([2, 4], dtype=&apos;int64&apos;), &apos;苹果&apos;: Int64Index([0, 5, 6], dtype=&apos;int64&apos;), &apos;香蕉&apos;: Int64Index([1, 3], dtype=&apos;int64&apos;)&#125; 获取weight的总和 1234567df.groupby(&quot;item&quot;)[&quot;weight&quot;].sum() #各类水果的总重量&gt;&gt;&gt;item橘子 70苹果 93香蕉 50Name: weight, dtype: int64 Matplotlibmatplotlib在Python中应用最多的2D图像的绘图工具包，使用matplotlib能够非常简单的可视化数据。在matplotlib中使用最多的模块就是pyplot。pyplot非常接近Matlab的绘图实现，而且大多数的命令及其类似Matlab.当然，与Matlab类似，需要很多的数学运算，因此numpy这个组件同样是必不可少的。所以很多人说python+matplotlib+numpy就是MATLAB。 一、Matplotlib基础知识Matplotlib中的基本图表包括的元素 x轴和y轴–axis ， 水平和垂直的轴线 轴标签–axisLabel ， 水平和垂直的轴标签 x轴和y轴刻度–tick ， 刻度标示坐标轴的分隔，包括最小刻度和最大刻度 x轴和y轴刻度标签–tick label ， 表示特定坐标轴的值 绘图区域（坐标系）–axes ， 实际绘图的区域 画布–figure ， 呈现所有的坐标系 只含单一曲线的图1、可以使用多个plot函数（推荐），在一个图中绘制多个曲线 2、也可以在一个plot函数中传入多对X,Y值，在一个图中绘制多个曲线 设置子画布axes = plt.subplot() 网格线绘制正弦余弦 使用plt.grid方法可以开启网格线，使用plt面向对象的方法，创建多个子图显示不同网格线 lw代表linewidth，线的粗细 alpha表示线的明暗程度 color代表颜色 axis显示轴向 坐标轴界限plt.axis([xmin,xmax,ymin,ymax]) plt.axis(‘xxx’) ‘tight’、’off’、’equal’…… 设置坐标轴类型关闭坐标轴 xlim方法和ylim方法 除了plt.axis方法，还可以通过xlim，ylim方法设置坐标轴范围 坐标轴标签xlabel方法和ylabel方法plt.ylabel(‘y = x^2 + 5’,rotation = 60)旋转 color 标签颜色 fontsize 字体大小 rotation 旋转角度 标题plt.title()方法 loc {left,center,right} color 标签颜色 fontsize 字体大小 rotation 旋转角度 图例legend方法 两种传参方法： 分别在plot函数中增加label参数,再调用legend()方法显示 直接在legend方法中传入字符串列表 loc参数 loc参数用于设置图例标签的位置，一般在legend函数内 matplotlib已经预定义好几种数字表示的位置 字符串 数值 字符串 数值 best 0 center left 6 upper right 1 center right 7 upper left 2 lower center 8 lower left 3 upper center 9 lower right 4 center 10 right 5 loc参数可以是2元素的元组，表示图例左下角的坐标 [0,0] 左下 [0,1] 左上 [1,0] 右下 [1,1] 右上 图例也可以超过图的界限loc = (-0.1,0.9) ncol参数ncol控制图例中有几列,在legend中设置ncol,需要设置loc linestyle、color、marker修改线条样式 linestyle(ls) 设置线的风格 linewidth(lw) 设置线宽 alpha 透明度 color 颜色 marker 点形 markersize 点大小 markeredagecolor 点的边界颜色 markeredagewidth 点的边界宽度 markerfacecolor 点的主体颜色 保存图片使用figure对象的savefig的函数 filename含有文件路径的字符串或Python的文件型对象。图像格式由文件扩展名推断得出，例如，.pdf推断出PDF，.png推断出PNG （“png”、“pdf”、“svg”、“ps”、“eps”……） dpi图像分辨率（每英寸点数），默认为100 facecolor图像的背景色，默认为“w”（白色） 二、设置plot的风格和样式plot语句中支持除X,Y以外的参数，以字符串形式存在，来控制颜色、线型、点型等要素，语法形式为：plt.plot(X, Y, ‘format’, …) 点和线的样式颜色 参数color或c 颜色值的方式 别名 color=’r’ 合法的HTML颜色名 color = ‘red’ 颜色 别名 HTML颜色名 颜色 别名 HTML颜色名 蓝色 b blue 绿色 g green 红色 r red 黄色 y yellow 青色 c cyan 黑色 k black 洋红色 m magenta 白色 w white HTML十六进制字符串 color = ‘#eeefff’ 归一化到[0, 1]的RGB元组 color = (0.3, 0.3, 0.4) jpg png 区别 透明度 alpha参数 背景色 设置背景色，通过plt.subplot()方法传入facecolor参数，来设置坐标系的背景色 线型 参数linestyle或ls 线条风格 描述 线条风格 描述 ‘-‘ 实线 ‘:’ 虚线 ‘–’ 破折线 ‘steps’ 阶梯线 ‘-.’ 点划线 ‘None’ / ‘，’ 什么都不画 不同宽度的破折线 dashes参数 eg.dashes = [20,50,5,2,10,5] 设置破折号序列各段的宽度 点型 marker 设置点形 markersize 设置点形大小 标记 描述 标记 描述 ‘1’ 一角朝下的三脚架 ‘3’ 一角朝左的三脚架 ‘2’ 一角朝上的三脚架 ‘4’ 一角朝右的三脚架 标记 描述 标记 描述 ‘s’ 正方形 ‘p’ 五边形 ‘h’ 六边形1 ‘H’ 六边形2 ‘8’ 八边形 标记 描述 标记 描述 ‘.’ 点 ‘x’ X ‘*’ 星号 ‘+’ 加号 ‘,’ 像素 标记 描述 标记 描述 ‘o’ 圆圈 ‘D’ 菱形 ‘d’ 小菱形 ‘’,’None’,’ ‘,None 无 标记 描述 标记 描述 ‘_’ 水平线 ‘\\ ‘ 竖线 标记 描述 标记 描述 ‘v’ 一角朝下的三角形 ‘&lt;’ 一角朝左的三角形 ‘^’ 一角朝上的三角形 ‘&gt;’ 一角朝右的三角形 多参数连用 颜色、点型、线型，可以把几种参数写在一个字符串内进行设置 ‘r-.o’ 更多点和线的设置 参数 描述 参数 描述 color或c 线的颜色 linestyle或ls 线型 linewidth或lw 线宽 marker 点型 markeredgecolor 点边缘的颜色 markeredgewidth 点边缘的宽度 markerfacecolor 点内部的颜色 markersize 点的大小 多个曲线同一设置 属性名声明，不可以多参数连用 plt.plot(x1, y1, x2, y2, fmt, …) 多个曲线不同设置 多个都进行设置时，多参数连用 plt.plot(x1, y1, fmt1, x2, y2, fmt2, …) 三种设置方式 向方法传入关键字参数 import matplotlib as mpl 对实例使用一系列的setter方法 plt.plot()方法返回一个包含所有线的列表，设置每一个线需要获取该线对象 eg: lines = plt.plot(); line = lines[0] line.set_linewith() line.set_linestyle() line.set_color() 对坐标系使用一系列的setter方法 axes = plt.subplot()获取坐标系 set_title() set_facecolor() set_xticks、set_yticks 设置刻度值 set_xticklabels、set_yticklabels 设置刻度名称 X、Y轴坐标刻度plt.xticks()和plt.yticks()方法 需指定刻度值和刻度名称 plt.xticks([刻度列表],[名称列表]) 支持fontsize、rotation、color等参数设置 三、2D图形直方图【直方图的参数只有一个x！！！不像条形图需要传入x,y】 hist() 的参数 bins可以是一个bin数量的整数值，也可以是表示bin的一个序列。默认值为10 normed如果值为True，直方图的值将进行归一化处理，形成概率密度，默认值为False color指定直方图的颜色。可以是单一颜色值或颜色的序列。如果指定了多个数据集合，颜色序列将会设置为相同的顺序。如果未指定，将会使用一个默认的线条颜色 orientation通过设置orientation为horizontal创建水平直方图。默认值为vertical 1234data = np.random.randint(0,10,size=100)display(data)# horizontal verticalvalue = plt.hist(data,bins=10,rwidth=0.9,color=&apos;orange&apos;,orientation=&apos;vertical&apos;) 条形图【条形图有两个参数x,y】 width 纵向设置条形宽度 height 横向设置条形高度 bar()横向条形图 、 barh()纵向条形图 1234567891011# 横向条形图# x index# height values# width 条形宽度# plt.bar(data1.index,data1.values,width=0.9)# 纵向条形图# y index# width values# height 条形宽度plt.barh(data1.index,data1.values,height=0.9) 饼图【饼图也只有一个参数x！】 pie()饼图适合展示各部分占总体的比例，条形图适合比较各部分的大小 普通各部分占满饼图 123456import numpy as npimport pandas as pdfrom pandas import Series,DataFrameimport matplotlib.pyplot as plt%matplotlib inline 1plt.pie([0.3,0.2,0.5]) 普通未占满饼图 1plt.pie([0.3,0.1,0.5]) 饼图阴影、分裂等属性设置 labels参数设置每一块的标签； labeldistance参数设置标签距离圆心的距离（比例值,只能设置一个浮点小数） autopct参数设置比例值的显示格式(%1.1f%%)； pctdistance参数设置比例值文字距离圆心的距离 explode参数设置每一块顶点距圆形的长度（比例值,列表）； colors参数设置每一块的颜色（列表）； shadow参数为布尔值，设置是否绘制阴影 startangle参数设置饼图起始角度 12345678plt.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;] # 步骤一（替换sans-serif字体）plt.rcParams[&apos;axes.unicode_minus&apos;] = False # 步骤二（解决坐标轴负数的负号显示问题）data = [4,2,3,1,1]values = plt.pie(data,labels=[&apos;小学&apos;,&apos;初中&apos;,&apos;高中&apos;,&apos;大学&apos;,&apos;现在&apos;],labeldistance=0.7, autopct=&apos;%.2f%%&apos;,pctdistance=0.5,explode=[0,0,0,0,0.2], colors=[&apos;yellow&apos;,&apos;cyan&apos;,&apos;purple&apos;,&apos;orange&apos;,&apos;blue&apos;],shadow=True, startangle=90) 散点图【散点图需要两个参数x,y，但此时x不是表示x轴的刻度，而是每个点的横坐标！】 scatter() 123x = np.linspace(0,2*np.pi,20)y = np.sin(x)plt.scatter(x,y) 四、图形内的文字、注释、箭头控制文字属性的方法: pyplot函数 API方法 描述 text() mpl.axes.Axes.text() 在Axes对象的任意位置添加文字 xlabel() mpl.axes.Axes.set_xlabel() 为X轴添加标签 ylabel() mpl.axes.Axes.set_ylabel() 为Y轴添加标签 title() mpl.axes.Axes.set_title() 为Axes对象添加标题 legend() mpl.axes.Axes.legend() 为Axes对象添加图例 figtext() mpl.figure.Figure.text() 在Figure对象的任意位置添加文字 suptitle() mpl.figure.Figure.suptitle() 为Figure对象添加中心化的标题 annnotate() mpl.axes.Axes.annotate() 为Axes对象添加注释（箭头可选） 所有的方法会返回一个matplotlib.text.Text对象 图形内的文字text() 注释annotate() xy参数设置箭头指示的位置 xytext参数设置注释文字的位置 arrowprops参数以字典的形式设置箭头的样式 width参数设置箭头长方形部分的宽度 headlength参数设置箭头尖端的长度， headwidth参数设置箭头尖端底部的宽度 shrink参数设置箭头顶点、尾部与指示点、注释文字的距离（比例值），可以理解为控制箭头的长度 五、3D图曲面图导包 from mpl_toolkits.mplot3d.axes3d import Axes3D 使用mershgrid函数切割x,y轴 X,Y = np.meshgrid(x, y) 创建3d坐标系 axes = plt.subplot(projection=’3d’) 绘制3d图形 p = axes.plot_surface(X,Y,Z,color=’red’,cmap=’summer’,rstride=5,cstride=5) 添加colorbar plt.colorbar(p,shrink=0.5) 玫瑰图/极坐标条形图创建极坐标，设置polar属性 plt.axes(polar = True) 绘制极坐标条形图 index = np.arange(-np.pi,np.pi,2*np.pi/6) plt.bar(x=index ,height = [1,2,3,4,5,6] ,width = 2*np.pi/6) 123456789101112# 先设置子画布为极坐标画布plt.axes(polar=True)# 极坐标的索引需要使用弧度表示# 由于在圆中，起始点和终点是一个点，所以在切分索引时，不要保留最后一个点index = np.linspace(0,2*np.pi,8,endpoint=False)values = np.array([10,5,9,2,8,5,6,7])# 生成8个不同的颜色 [r,g,b]colors = np.random.random(size=(8,3))# 扇形区域的半径，表示数值的大小，宽度使用width设置，默认值0.8plt.bar(x=index,height=values,width=0.8,color=colors,align='edge')","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://shuaixiaohao.github.io/categories/数据分析/"}],"tags":[{"name":"numpy,pandas,Matplotlib","slug":"numpy-pandas-Matplotlib","permalink":"https://shuaixiaohao.github.io/tags/numpy-pandas-Matplotlib/"}]},{"title":"Django","slug":"Django","date":"2017-12-15T13:24:12.000Z","updated":"2019-02-01T11:53:48.354Z","comments":true,"path":"2017/12/15/Django/","link":"","permalink":"https://shuaixiaohao.github.io/2017/12/15/Django/","excerpt":"一、Django简介：Django官网地址 Django发布于2005年7月，是当前Python世界里最有名且成熟的网络框架。 最初是被开发用于管理劳伦斯出版集团旗下的以新闻内容为主的网站的，即CMS(内容管理系统)软件。 Django是一个用Python编写的开放源代码的Web应用框架，代码是开源的。此系统采用了MVC的框架模式, 也可以称为MTV模式","text":"一、Django简介：Django官网地址 Django发布于2005年7月，是当前Python世界里最有名且成熟的网络框架。 最初是被开发用于管理劳伦斯出版集团旗下的以新闻内容为主的网站的，即CMS(内容管理系统)软件。 Django是一个用Python编写的开放源代码的Web应用框架，代码是开源的。此系统采用了MVC的框架模式, 也可以称为MTV模式 什么是MVC模式 MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 通俗的来讲就是，强制性的使应用程序的输入，处理和输出分开。 核心思想：解耦 优点：减低各个模块之间的耦合性，方便变更，更容易重构代码，最大程度的实现了代码的重用 MVC(Model, View, Controller) Model: 即数据存取层。用于封装于应用程序的业务逻辑相关的数据，以及对数据的处理。说白了就是模型对象负责在数据库中存取数据 View: 即表现层。负责数据的显示和呈现。渲染的html页面给用户，或者返回数据给用户。 Controller: 即业务逻辑层。负责从用户端收集用户的输入，进行业务逻辑处理，包括向模型中发送数据，进行CRUD操作。 图解： 浏览器中MVC的表现形式图解: Django的模式简介 MVT模式 严格来说，Django的模式应该是MVT模式，本质上和MVC没什么区别，也是各组件之间为了保持松耦合关系，只是定义上有些许不同。 Model： 负责业务与数据库(ORM)的对象 View： 负责业务逻辑并适当调用Model和Template Template: 负责把页面渲染展示给用户 注意： Django中还有一个url分发器，也叫作路由。主要用于将url请求发送给不同的View处理，View在进行相关的业务逻辑处理。 二、创建Django项目window下安装Django​ 用django-admin创建项目的时候，在macOS上可以不指定路径就在项目目录下就可以了，但是Windows和Linux在命令后面加一个点，指定当前路径 django-admin startproject hello_django . 注意最后面有一个点，这样就不会创建多级路径了 123456789101112131415161718192021222324251.查看python版本 python --version2.建虚拟环境,目录名hello_django_venv python -m venv hello_django_venv3.激活虚拟环境 cd hello_django_venv cd Scripts activate #激活虚拟环境 pip install django[==版本号] 5.查看Django版本(可跳过此步骤) django-admin --version6.建项目（在用户目录下） django-admin startproject hello_djang .---------------------------------------------------------7.进入项目目录下 cd hello_django8.启服务器 python manage.py runserver9.改页面语言 找到项目目录，打开settings.py， 找到LANGUAGE_CODE，更改为LANGUAGE_CODE = 'zh-hans'10.建应用hrs python manage.py startapp hrs11.打开settings.py，将创建的应用添加到 INSTALLED_APPS 列表中12.在建的应用文件下(hrs)打开views.py，开始创作 Linux /Mac 下安装Django123456789101112131415161.创建项目目录 mkdir hello_django2.切换到项目目录 cd hello_django/3.使用venv模块创建虚拟环境，目录名hd_venv python3 -m venv hd_venv4.激活虚拟环境 source hd_venv/bin/activate5.更新pip到最新版本 python -m pip install --upgrade pip6.使用pip安装django pip install django7.通过安装django时安装的脚本工具django-admin检查django版本 django-admin --version8. 开启一个项目 django-admin startproject hello_django . 利用virtualenv 创建纯净虚拟环境1pip install virtualenv pip freeze 查看已装过哪些包 pip install -r xxx.text 安装指定文件中的包 使用pycharm创建Django项目1.点击Create New Project 创建一个新项目 2.点击 Django → 选择项目存储路径如果想在创建项目是新建一个应用, 点击More Setting, 输入应用的名称点击 右下角Greate, 创建项目 ubuntu中安装使用 安装virtualenv 1apt-get install python-virtualenv 创建包含python3版本的虚拟环境 1virtualenv -p /usr/bin/python3 env env代表创建的虚拟环境的名称 进入/退出env 123进入 source env/bin/activate退出 deactivate pip使用 查看虚拟环境下安装的所有的包 1pip list 查看虚拟环境重通过pip安装的包 1pip freeze 创建一个Django项目1. 创建项目 1django-admin startproject halloWorld 该命令是创建一个名为halloWorld的工程 项目目录介绍 下面展示创建以后的文件，具体有哪些文件： manage.py： 是Django用于管理本项目的管理集工具，之后站点运行，数据库自动生成，数据表的修改等都是通过该文件完成。 init.py： 指明该目录结构是一个python包，暂无内容，在后期会初始化一些工具会使用到。 seetings.py： Django项目的配置文件，其中定义了本项目的引用组件，项目名，数据库，静态资源，调试模式，域名限制等 urls.py：项目的URL路由映射，实现客户端请求url由哪个模块进行响应。 wsgi.py：定义WSGI接口信息，通常本文件生成后无需改动 运行Django项目 1python manage.py runserver 端口 该命令是运行项目，端口可以不用写，启动的时候会默认随机创建一个可以使用的端口 2. 创建app 1python manage.py startapp hallo_app 该命令是在blog工程下创建一个名为hallo_app的app 3. settings.py配置文件详细解读 a) 设置语言： LANGUAGE_CODE = ‘zh-hans’ 表示中文 LANGUAGE_CODE = ‘en-us’ 表示英文 设置时区： TIME_ZONE = ‘Asia/Shanghai’ b) 时区解释： (需要详细回顾思考时区问题) UTC：世界标准时间，也就是平常说的零时区。 北京时间表示东八区时间，即UTC+8 三、配置Django项目1.创建的应用python manager.py startapp cars 执行上面的命令会在当前路径下创建hrs目录，其目录结构如下所示： __init__.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。 admin.py：可以用来注册模型，让Django自动创建管理界面。 apps.py：当前应用的配置。 migrations：存放与模型有关的数据库迁移信息。 models.py：存放应用的数据模型，即实体类及其之间的关系（MVC/MVT中的M）。 tests.py：包含测试应用各项功能的测试类和测试函数。 views.py：处理请求并返回响应的函数（MVC中的C，MVT中的V）。 setting.py 12345# 添加应用配置# 每新建一个应用就要添加一个INSTALLED_APPS = [ &apos;cars.apps.CarsConfig&apos;,] 2.创建数据库创建名为cars的数据库, 并指定utf8字符集 3.配置数据库项目文件下settings.py里 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'cars', # 与数据库名称对应 'HOST': 'localhost', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', &#125;&#125; 在项目文件夹下 __init__.py 123import pymysql#把pymysql方式当成是mysqldb一样使用pymysql.install_as_MySQLdb() 4.创建模型models.py 123456789101112131415from django.db import modelsclass Record(models.Model): no = models.AutoField(primary_key=True,verbose_name='编号') car_no = models.CharField(max_length=7, verbose_name='车牌号') cause = models.CharField(max_length=100, verbose_name='违章原因') date = models.DateTimeField(auto_now_add=True, verbose_name='违章日期',db_column='happen_date') way = models.CharField(max_length=100, verbose_name='处罚方式') dispose = models.BooleanField(default=False, verbose_name='是否受理') class Meta: db_table = 'tb_car_record' verbose_name_plural = '违章记录' ordering = ('no', ) 5.迁移数据库 python manage.py makemigrations 应用名记录我们对models.py的所有改动，并且将这个改动迁移到migrations这个文件下生成一个文件 python manage.py migrate把改动作用到数据库 清空数据库python manage.py flush [此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表] 6.创建管理员python manage.py createsuperuser配置 Username / Email address / Password 7. 配置管理员界面admin.py 1234567891011from django.contrib import adminfrom cars.models import Recordclass RecordAdmin(admin.ModelAdmin): # 添加管理员页面需要显示的列 list_display = ('no', 'car_no', 'cause', 'date', 'way', 'dispose') # 指定搜索列 search_fields = ('car_no',) # 指定排序方式 ordering = ('no',)admin.site.register(Record, RecordAdmin) 8.创建视图文件夹 templates / 静态文件夹 static (与应用/项目目录同级)|— cars |— static (存放静态文件 css / js / jQuery) |— templates (存放html页面, 使用pycharm创建项目会自动添加) setting.py 12# 添加static文件夹路径,os.path.join路径拼接STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')] 如果使用命令行创建Django项目 还需要在setting.py中添加如下配置: ‘DIRS’: [os.path.join(BASE_DIR, ‘templates’)] 1234567891011121314151617TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', # 添加templates文件夹路径 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 9.修改视图文件views.py1234from django.http import HttpResponsedef index(request): return HttpResponse('&lt;h1&gt;Hello, Django!&lt;/h1&gt;') 10.映射URL应用目录创建一个urls.py文件并映射URL切换到项目目录，修改该目录下的urls.py文件，对应用中设定的URL进行合并 123456from django.urls import pathfrom hrs import viewsurlpatterns = [ path('', views.index, name='index'),] 123456from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('admin/', admin.site.urls), path('hrs/', include('hrs.urls')), python manage.py shell 增删改查操作 1234567891011121314151617181920212223242526272829python manage.py shellfrom hrs.models import Dept, Emp#添加数据&gt;&gt;&gt; dept = Dept(dno='16',name='研发部',location='小溪坝')&gt;&gt;&gt; dept.save()#删数据&gt;&gt;&gt; Dept.objects.filter(dno='16').delete()#更改数据&gt;&gt;&gt; Dept.objects.filter(dno='16').update(name='销售部')#查询数据&gt;&gt;&gt; Dept.objects.all() #查所有&gt;&gt;&gt; Dept.objects.all().values('location') #查询指定列&gt;&gt;&gt; Dept.objects.get(dno=16) #过滤数据&gt;&gt;&gt; &gt;&gt;&gt; Dept.objects.filter(name='研发3部') # 查询部门名称为“研发3部”的部门&lt;QuerySet [&lt;Dept: 研发3部&gt;]&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dept.objects.filter(name__contains='研发') # 查询部门名称包含“研发”的部门(模糊查询)&lt;QuerySet [&lt;Dept: 研发1部&gt;, &lt;Dept: 研发3部&gt;]&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dept.objects.filter(no__gt=10).filter(no__lt=40) # 查询部门编号大于10小于40的部门&lt;QuerySet [&lt;Dept: 销售1部&gt;, &lt;Dept: 运维1部&gt;]&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dept.objects.filter(no__range=(10, 30)) # 查询部门编号在10到30之间的部门&lt;QuerySet [&lt;Dept: 研发1部&gt;, &lt;Dept: 销售1部&gt;, &lt;Dept: 运维1部&gt;]&gt;all() / filter() --&gt; QuerySetQuerySet使用了惰性查询 - 如果不是非得取到数据那么不会发出SQL语句这样就是为了节省服务器内存的开销 - 延迟加载 - 节省空间势必浪费时间","categories":[{"name":"Web框架","slug":"Web框架","permalink":"https://shuaixiaohao.github.io/categories/Web框架/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://shuaixiaohao.github.io/tags/Django/"}]},{"title":"Flask","slug":"Flask学习","date":"2017-12-15T10:29:31.000Z","updated":"2019-02-01T11:56:14.981Z","comments":true,"path":"2017/12/15/Flask学习/","link":"","permalink":"https://shuaixiaohao.github.io/2017/12/15/Flask学习/","excerpt":"1、flask介绍Flask是一个基于Python实现的web开发的’微’框架 中文文档地址 flask流行的主要原因： 123a）有非常齐全的官方文档，上手非常方便b) 有非常好的拓展机制和第三方的拓展环境，工作中常见的软件都有对应的拓展，自己动手实现拓展也很容易c) 微型框架的形式给了开发者更大的选择空间","text":"1、flask介绍Flask是一个基于Python实现的web开发的’微’框架 中文文档地址 flask流行的主要原因： 123a）有非常齐全的官方文档，上手非常方便b) 有非常好的拓展机制和第三方的拓展环境，工作中常见的软件都有对应的拓展，自己动手实现拓展也很容易c) 微型框架的形式给了开发者更大的选择空间 安装flask虚拟环境搭建123456pip instatll virtualenvvirtualenv --no-site-packages falskenv激活windows下虚拟环境cd Scriptsactivate 安装1pip install flask 基于flask的最小的应用创建hello.py文件 1234567891011from flask import Flaskapp = Flask(__name__)@app.route('/')def gello_world(): return 'Hello World'if __name__ == '__main__': app.run() 运行：python hello.py 初始化123from flask import Flaskapp = Flask(__name__) Flask类构造函数唯一需要的参数就是应用程序的主模块或包。对于大多数应用程序，Python的name变量就是那个正确的、你需要传递的值。Flask使用这个参数来确定应用程序的根目录，这样以后可以相对这个路径来找到资源文件。 路由1@app.route('/') 客户端例如web浏览器发送 请求 给web服务，进而将它们发送给Flask应用程序实例。应用程序实例需要知道对于各个URL请求需要运行哪些代码，所以它给Python函数建立了一个URLs映射。这些在URL和函数之间建立联系的操作被称之为 路由 。 在Flask应程序中定义路由的最便捷的方式是通过显示定义在应用程序实例之上的app.route装饰器，注册被装饰的函数来作为一个 路由。 视图函数在上一个示例给应用程序的根URL注册gello_world()函数作为事件的处理程序。如果这个应用程序被部署在服务器上并绑定了 www.example.com 域名，然后在你的浏览器地址栏中输入 http://www.example.com 将触发gello_world()来运行服务。客户端接收到的这个函数的返回值被称为 响应 。如果客户端是web浏览器，响应则是显示给用户的文档。 类似于gello_world()的函数被称作 视图函数 。 动态名称组件路由你的Facebook个人信息页的URL是 http://www.facebook.com/ ，所以你的用户名是它的一部分。Flask在路由装饰器中使用特殊的语法支持这些类型的URLs。下面的示例定义了一个拥有动态名称组件的路由： 12345@app.route('/hello/&lt;name&gt;')def gello_world(name): return 'Hello World %s' % name 用尖括号括起来的部分是动态的部分，所以任何URLs匹配到静态部分都将映射到这个路由。当视图函数被调用，Flask发送动态组件作为一个参数。在前面的示例的视图函数中，这个参数是用于生成一个个性的问候作为响应。 在路由中动态组件默认为字符串，但是可以定义为其他类型。例如，路由/user/int:id只匹配有一个整数在id动态段的URLs。Flask路由支持int、float 如下： 12345@app.route('/hello/&lt;int:id&gt;')def gello_stu_id(id): return 'Hello World id: %s' % id 服务启动123if __name__ == '__main__': app.run() 注意： name == ‘main‘在此处使用是用于确保web服务已经启动当脚本被立即执行。当脚本被另一个脚本导入，它被看做父脚本将启动不同的服务，所以app.run()调用会被跳过。 一旦服务启动，它将进入循环等待请求并为之服务。这个循环持续到应用程序停止，例如通过按下Ctrl-C。 有几个选项参数可以给app.run()配置web服务的操作模式。在开发期间，可以很方便的开启debug模式，将激活 debugger 和 reloader 。这样做是通过传递debug为True来实现的。 run()中参数有如下： 12345debug 是否开启调试模式，开启后修改python的代码会自动重启port 启动指定服务器的端口号host主机，默认是127.0.0.1 修改启动方式修改启动方式，使用命令行参数启动服务 安装插件1pip install flask-script 调整代码 manager = Manager(app=‘自定义的flask对象’) 启动的地方 manager.run() 启动命令1python hellow.py runserver -h 地址 -p 端口 -d -r 其中：-h表示地址。-p表示端口。-d表示debug模式。-r表示自动重启 route规则规则写法：converter:variable_name converter类型： 123456string 字符串int 整形float 浮点型path 接受路径，接收的时候是str，/也当做字符串的一个字符uuid 只接受uuid字符串any 可以同时指定多种路径，进行限定 例子： 123456789@app.route(&apos;/helloint/&lt;int:id&gt;/&apos;)@app.route(&apos;/getfloat/&lt;float:price&gt;/&apos;)@app.route(&apos;/getstr/&lt;string:name&gt;/&apos;，methods=[&apos;GET&apos;, &apos;POST&apos;])@app.route(&apos;/getpath/&lt;path:url_path&gt;/&apos;)@app.route(&apos;/getbyuuid/&lt;uuid:uu&gt;/&apos;，methods=[&apos;GET&apos;, &apos;POST&apos;]) 实现对应的视图函数： 123456789101112131415161718192021222324252627282930313233343536373839@blue.route('/hello/&lt;name&gt;/')def hello_man(name): print(type(name)) return 'hello name:%s type:%s' % (name, type(name))@blue.route('/helloint/&lt;int:id&gt;/')def hello_int(id): print(id) print(type(id)) return 'hello int: %s' % (id)@blue.route('/index/')def index(): return render_template('hello.html')@blue.route('/getfloat/&lt;float:price&gt;/')def hello_float(price): return 'float: %s' % price@blue.route('/getstr/&lt;string:name&gt;/')def hello_name(name): return 'hello name: %s' % name@blue.route('/getpath/&lt;path:url_path&gt;/')def hello_path(url_path): return 'path: %s' % url_path@blue.route('/getuuid/')def gello_get_uuid(): a = uuid.uuid4() return str(a)@blue.route('/getbyuuid/&lt;uuid:uu&gt;/')def hello_uuid(uu): return 'uu:%s' % uu methods请求方法常用的请求类型有如下几种 12345GET : 获取POST : 创建PUT : 修改(全部属性都修改)DELETE : 删除PATCH : 修改(修改部分属性) 定义url的请求类型: 1@blue.route(&apos;/getrequest/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]) 2、蓝图什么是蓝图在Flask项目中可以用Blueprint(蓝图)实现模块化的应用，使用蓝图可以让应用层次更清晰，开发者更容易去维护和开发项目。蓝图将作用于相同的URL前缀的请求地址，将具有相同前缀的请求都放在一个模块中，这样查找问题，一看路由就很快的可以找到对应的视图，并解决问题了。 使用蓝图安装1pip install flask_blueprint 实例化蓝图应用1blue = Blueprint(&apos;first&apos;，__name__) 注意：Blueprint中传入了两个参数，第一个是蓝图的名称，第二个是蓝图所在的包或模块，name代表当前模块名或者包名 注册123app = Flask(__name__)app.register_blueprint(blue, url_prefix=&apos;/user&apos;) 注意：第一个参数即我们定义初始化定义的蓝图对象，第二个参数url_prefix表示该蓝图下，所有的url请求必须以/user开始。这样对一个模块的url可以很好的进行统一管理 使用蓝图修改视图上的装饰器，修改为@blue.router(‘/’) 1234@blue.route('/', methods=['GET', 'POST'])def hello(): # 视图函数 return 'Hello World' 注意：该方法对应的url为127.0.0.1:5000/user/ url_for反向解析语法: 1url_for(&apos;蓝图中定义的第一个参数.函数名&apos;, 参数名=value) 定义跳转： 12345678from flask import url_for, redirect@blue.route(&apos;/redirect/&apos;)def make_redirect(): # 第一种方法 return redirect(&apos;/hello/index/&apos;) # 第二种方法 return redirect(url_for(&apos;first.index&apos;)) 3、访问请求数据请求request服务端在接收到客户端的请求后，会自动创建Request对象 由Flask框架创建，Requesy对象不可修改 属性： 1234567891011url：完整的请求地址base_url：去掉GET参数的urlhost_url：只有主机和端口号的urlpath：路由中的路径method：请求方法remote_addr：请求的客户端的地址args：GET请求参数form：POST请求参数files：文件上传headers：请求头cookies：请求中的cookie args–&gt;GET请求参数包装a）args是get请求参数的包装，args是一个ImmutableMultiDict对象，类字典结构对象 b）数据存储也是key-value form–&gt;POST请求参数包装a）form是post请求参数的包装，args是一个ImmutableMultiDict对象，类字典结构对象 b）数据存储也是key-value 重点：ImmutableMultiDict是类似字典的数据结构，但是与字典的区别是，可以存在相同的键。在ImmutableMultiDict中获取数据的方式，dict[‘key’]或者dict.get(‘key’)或者dict.getlist(‘key’) 响应ResponseResponse是由开发者自己创建的 创建方法： 123from flask import make_responsemake_response创建一个响应，是一个真正的Response对象 状态码： 格式：make_reponse(data，code)，其中data是返回的数据内容，code是状态码 123a）直接将内容当做make_response的第一个参数，第二个参数直接写返回的状态码b）直接在render后加返回的状态码 例子1： 定义一个获取GET请求的request的方法，并将返回成功的请求的状态码修改为200 123456@blue.route('/getrequest/', methods=['GET'])def get_request(): print(request) return '获取request', 200 例子2： 返回response响应，并添加返回结果的状态码200 1234@blue.route('/getresponse/')def get_response(): response = make_response('&lt;h2&gt;我是响应&lt;/h2&gt;', 500) return response 重定向/反向解析1url_for('蓝图定义的名称.方法名') 例子1: 定义跳转方法，跳转到get_response的方法上 1234@blue.route('/getredirect/')def get_redirect(): return redirect('getresponse') 例子2： 使用url_for反向解析 123456from flask import redirect, url_for@blue.route('/getredirect/')def get_redirect(): return redirect(url_for('first.get_response')) 终止/异常捕获自动抛出异常：abort(状态码) 捕获异常处理：errorhandler(状态码)，定义的函数中要包含一个参数，用于接收异常信息 定义终止程序1234@blue.route('/make_abort/')def get_abort(): abort(400) return '终止' 捕获定义的异常1234@blue.errorhandler(400)def handler(exception): return '捕获到异常信息:%s' % exception 4、session与cookie前言访问者的标识问题服务器需要识别来自同一访问者的请求。这主要是通过浏览器的cookie实现的。 访问者在第一次访问服务器时，服务器在其cookie中设置一个唯一的ID号——会话ID(session)。 这样，访问者后续对服务器的访问头中将自动包含该信息，服务器通过这个ID号，即可区 隔不同的访问者。 Cookie概念： 1234567891011a）客户端会话技术，浏览器的会话技术b）数据全部存储在客户端中c）存储使用的键值对结构进行存储特性： 支持过期时间 默认会自动携带本网站的cookie 不能跨域名 不能跨浏览器 创建： 123456789Cookie是通过服务器创建的Response来创建的设置：set_cookie(&apos;key&apos;, value, max_ages=&apos;&apos;, expires=&apos;&apos;)删除, 有三种删除方式 1. 直接清空浏览器的cookie 2. del_cookie(&apos;key&apos;) 直接使用del_cookie函数 3. set_cookie(&apos;key&apos;,&apos;&apos;,expires=0) 重新设置key的值为空，过期时间为0 获取： 123在每次请求中，url都会向服务器传递Request，在request中可以获取到cookie的信息request.cookies.get(&apos;name&apos;) 例子1，设置cookie： 12345678910import datetime@blue.route(&apos;/setcookie/&apos;)def set_cookie(): temp = render_template(&apos;index.html&apos;) response = make_response(temp) outdate=datetime.datetime.today() + datetime.timedelta(days=30) # 设置cookie中的name的存在时长，设置为30天才过期 response.set_cookie(&apos;name&apos;,&apos;cocoococo&apos;,expires=outdate) return response 例子2，删除cookie中的值 123456789@blue.route(&apos;/setcookie/&apos;)def set_cookie(): temp = render_template(&apos;index.html&apos;) response = make_response(temp) # 第一种方式，通过set_cookie去删除 response.set_cookie(&apos;name&apos;,&apos;&apos;,expires=0) # 第二种方式，del_cookie删除 response.del_cookie(&apos;name&apos;) return response 例子3，获取cookie中的值 1234@blue.route(&apos;/getcookie/&apos;) def get_cookie(): name=request.cookies.get(&apos;name&apos;) return name Sessionflask-session是flask框架的session组件 该组件则将支持session保存到多个地方 如： 1234567redis：保存数据的一种工具，五大类型。非关系型数据库memcachedmongodbsqlalchmey：那数据存到数据库表里面 安装1pip install flask-session 如果指定存session的类型为redis的话，需要安装redis 1pip install redis 语法设置session： 1session[&apos;key&apos;] = value 读取session： 123result = session[&apos;key&apos;] ：如果内容不存在，将会报异常result = session.get(&apos;key&apos;) ：如果内容不存在，将返回None 删除session： 1session.pop(&apos;key&apos;) 清空session中所有数据： 1session.clear 使用我们在初始化文件中创建一个方法，通过调用该方法来获取到Flask的app对象 1234567891011121314151617def create_app(): app = Flask(__name__) # SECRET_KEY 秘钥 app.config[&apos;SECRET_KEY&apos;] = &apos;secret_key&apos; # session类型为redis app.config[&apos;SESSION_TYPE&apos;] = &apos;redis&apos; # 添加前缀 app.config[&apos;SESSION_KEY_PREFIX&apos;] = &apos;flask&apos; # 加载app的第一种方式 se = Session() se.init_app(app=app) #加载app的第二种方式 Session(app=app) app.register_blueprint(blueprint=blue) return app 案例定义一个登陆的方法，post请求获取到username，直接写入到redis中，并且在页面中展示出redis中的username a）需要先启动redis，开启redis-server，使用redis-cli进入客户端 b）定义方法 12345678910@blue.route(&apos;/login/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def login(): if request.method == &apos;GET&apos;: username = session.get(&apos;username&apos;) return render_template(&apos;login.html&apos;, username=username) else: username = request.form.get(&apos;username&apos;) session[&apos;username&apos;] = username return redirect(url_for(&apos;first.login&apos;)) c）定义模板 1234567&lt;body&gt;&lt;h3&gt;欢迎:&#123;&#123; username &#125;&#125;&lt;/h3&gt;&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;请输入你的名字&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt; d）redis中数据 注意：我们在定义app.config的时候指定了SESSION_KEY_PREFIX为flask，表示存在session中的key都会加一个前缀名flask e) cookie和session的联系 访问者在第一次访问服务器时，服务器在其cookie中设置一个唯一的ID号——会话ID(session)。 这样，访问者后续对服务器的访问头中将自动包含该信息，服务器通过这个ID号，即可区 隔不同的访问者。然后根据不同的访问者来获取其中保存的value值信息。 4、模板jinja2Flask中使用jinja2模板引擎 jinja2是由Flask作者开发，模仿Django的模板引擎 优点： 1234567速度快，被广泛使用HTML设计和后端python分离非常灵活，快速和安全提供了控制，继承等高级功能 模板语法模板语法主要分为两种：变量和标签 模板中的变量： 1模板中的变量：&#123;&#123; var &#125;&#125; 12345视图传递给模板的数据前面定义出来的数据变量不存在，默认忽略 模板中的标签： 1模板中的标签：&#123;% tag %&#125; 1234567控制逻辑使用外部表达式创建变量宏定义 结构标签：block 123456&#123;% block xxx %&#125;&#123;% endblock %&#125;块操作 父模板挖坑，子模板填坑 extends 1234&#123;% extends ‘xxx.html’ %&#125;继承以后保留块中的内容&#123;&#123; super() &#125;&#125; 挖坑继承体现的化整为零的操作 macro 1234567&#123;% macro hello(name) %&#125; &#123;&#123; name &#125;&#125;&#123;% endmacro %&#125;宏定义，可以在模板中定义函数，在其他地方调用 宏定义可导入 1&#123;% from 'xxx' import xxx %&#125; 例子1： 在index.html中定义macro标签，定义一个方法，然后去调用方法，结果是展示商品的id和商品名称 12345678&#123;% macro show_goods(id, name) %&#125; 商品id：&#123;&#123; id &#125;&#125; 商品名称：&#123;&#123; name &#125;&#125;&#123;% endmacro %&#125;&#123;&#123; show_goods('1', '娃哈哈') &#125;&#125;&lt;br&gt;&#123;&#123; show_goods('2', '雪碧') &#125;&#125; 例子2： 在index.html页面中定义一个say()方法，然后解析该方法： 123456789&#123;% macro say() %&#125; &lt;h3&gt;今天天气气温回升&lt;/h3&gt; &lt;h3&gt;适合去游泳&lt;/h3&gt; &lt;h3&gt;适合去郊游&lt;/h3&gt;&#123;% endmacro %&#125;&#123;&#123; say() &#125;&#125; 例子3： 定义一个function.html中定义一个方法： 123&#123;% macro create_user(name) %&#125; 创建了一个用户:&#123;&#123; name &#125;&#125;&#123;% endmacro %&#125; 在index.html中引入function.html中定义的方法 123&#123;% from 'functions.html' import create_user %&#125;&#123;&#123; create_user('小花') &#125;&#125; 循环123456789&#123;% for item in cols %&#125; aa&#123;% else %&#125; bb&#123;% endfor %&#125; 也可以获取循环信息loop 1234567loop.firstloop.lastloop.indexloop.revindex 例子: 在视图中定义一个视图函数： 123456789101112@stu.route('/scores/')def scores(): scores_list = [21,34,32,67,89,43,22,13] content_h2 = '&lt;h2&gt;今天你们真帅&lt;/h2&gt;' content_h3 = ' &lt;h3&gt;今天你们真帅&lt;/h3&gt; ' return render_template('scores.html', scores=scores_list, content_h2=content_h2, content_h3=content_h3) (该视图函数，在下面讲解的过滤器中任然使用其返回的content_h2等参数) 首先: 在页面中进行解析scores的列表。题目要求：第一个成绩展示为红色，最后一个成绩展示为绿色，其他的不变 1234567891011&lt;ul&gt; &#123;% for score in scores %&#125; &#123;% if loop.first %&#125; &lt;li style=\"color:red;\"&gt;&#123;&#123; loop.revindex &#125;&#125;:&#123;&#123; loop.index &#125;&#125;:&#123;&#123; score &#125;&#125;&lt;/li&gt; &#123;% elif loop.last %&#125; &lt;li style=\"color:green;\"&gt;&#123;&#123; loop.revindex &#125;&#125;:&#123;&#123; loop.index &#125;&#125;:&#123;&#123; score &#125;&#125;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt; &#123;&#123; loop.revindex &#125;&#125;:&#123;&#123; loop.index &#125;&#125;:&#123;&#123; score &#125;&#125;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125;&lt;/ul&gt; 过滤器语法： 1&#123;&#123; 变量|过滤器|过滤器... &#125;&#125; capitalize 单词首字母大写 lower 单词变为小写 upper 单词变为大写 title trim 去掉字符串的前后的空格 reverse 单词反转 format striptags 渲染之前，将值中标签去掉 safe 讲样式渲染到页面中 default last 最后一个字母 first length sum sort 例子： 12345678910&lt;ul&gt; &lt;li&gt;&#123;&#123; content_h2 &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; content_h2|safe &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; content_h2|striptags &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; content_h3 &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; content_h3|length &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; content_h3|trim|safe &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; content_h3|trim|length &#125;&#125;&lt;/li&gt;&lt;/ul&gt; 定义模板定义基础模板base.html 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt; &#123;% block title %&#125; &#123;% endblock %&#125; &lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-3.2.1.min.js\"&gt;&lt;/script&gt; &#123;% block extCSS %&#125; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt;&#123;% block header %&#125;&#123;% endblock %&#125;&#123;% block content%&#125;&#123;% endblock %&#125;&#123;% block footer%&#125;&#123;% endblock %&#125;&#123;% block extJS %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 定义基础模板base_main.html 12345&#123;% extends &apos;base.html&apos; %&#125;&#123;% block extCSS %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; url_for(&apos;static&apos;, filename=&apos;css/main.css&apos;) &#125;&#125;&quot;&gt;&#123;% endblock %&#125; 静态文件信息配置django： 第一种方式： 12&#123;% load static %&#125;&lt;link rel=\"stylesheet\" href=\"&#123;% static 'css/index.css' %&#125;\"&gt; 第二种方式： 1&lt;link rel=\"stylesheet\" href=\"/static/css/index.css\"&gt; flask： 第一种方式： 1&lt;link rel=\"stylesheet\" href=\"/static/css/index.css\"&gt; 第二种方式： 1&lt;link rel=\"stylesheet\" href=\"&#123;&#123; url_for('static', filename='css/index.css') &#125;&#125;\"&gt; 5、模型Flask模型Flask默认并没有提供任何数据库操作的API 我们可以选择任何适合自己项目的数据库来使用 Flask中可以自己的选择数据，用原生语句实现功能，也可以选择ORM（SQLAlchemy，MongoEngine） SQLAlchemy是一个很强大的关系型数据库框架，支持多种数据库后台。SQLAlchemy提供了高层ORM，也提供了使用数据库原生SQL的低层功能。 ORM： 123456将对对象的操作转换为原生SQL优点 易用性，可以有效减少重复SQL 性能损耗少 设计灵活，可以轻松实现复杂查询 移植性好 针对于Flask的支持，官网地址 1pip install flask-sqlalchemy 安装驱动 1pip install pymysql 定义模型使用SQLALchemy的对象去创建字段 其中tablename指定创建的数据库的名称 1234567891011121314创建models.py文件，其中定义模型from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy()class Student(db.Model): s_id = db.Column(db.Integer, primary_key=True, autoincrement=True) s_name = db.Column(db.String(16), unique=True) s_age = db.Column(db.Integer, default=1) __tablename__ = &quot;student&quot; 其中： Integer表示创建的s_id字段的类型为整形， primary_key表示是否为主键 String表示该字段为字符串 unique表示该字段唯一 default表示默认值 autoincrement表示是否自增 创建数据表在视图函数中我们引入models.py中定义的db 1234567891011from App.models import db@blue.route(&quot;/createdb/&quot;)def create_db(): db.create_all() return &quot;创建成功&quot;@blue.route(&apos;/dropdb/&apos;)def drop_db(): db.drop_all() return &apos;删除成功&apos; 其中： db.create_all()表示创建定义模型中对应到数据库中的表 db.drop_all()表示删除数据库中的所有的表 初始化SQLALchemy在定义的init.py文件中使用SQLALchemy去整合一个或多个Flask的应用 有两种方式： 123456789101112131415第一种：from flask_sqlalchemy import SQLALchemyapp = Flask(__name__)db = SQLAlchemy(app)第二种：from App.models import dbdef create_app(): app = Flask(__name__) db.init_app(app) return app 配置数据库的访问地址官网配置参数 数据库连接的格式： 12345dialect+driver://username:password@host:port/databasedialect数据库实现driver数据库的驱动 例子： 访问mysql数据库，驱动为pymysql，用户为root，密码为123456，数据库的地址为本地，端口为3306，数据库名称HelloFlask 设置如下： “mysql+pymysql://root:123456@localhost:3306/HelloFlask” 在初始化init.py文件中如下配置： 123app.config[&apos;SQLALCHEMY_TRACK_MODIFICATIONS&apos;] = Falseapp.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] = &quot;mysql+pymysql://root:123456@localhost:3306/HelloFlask&quot; 对学生数据进行CRUD操作语法： 1类名.query.xxx 获取查询集： 12345all()filter(类名.属性名==xxx)filter_by(属性名=xxx) 数据操作： 1234567891011在事务中处理，数据插入db.session.add(object)db.session.add_all(list[object])db.session.delete(object)db.session.commit()修改和删除基于查询 想学生表中添加数据 1234567891011@blue.route(&apos;/createstu/&apos;)def create_stu(): s = Student() s.s_name = &apos;小花%d&apos; % random.randrange(100) s.s_age = &apos;%d&apos; % random.randrange(30) db.session.add(s) db.session.commit() return &apos;添加成功&apos; 提交事务，使用commit提交我们的添加数据的操作 获取所有学生信息 将学生的全部信息获取到，并且返回给页面，在页面中使用for循环去解析即可 1234@blue.route(&quot;/getstudents/&quot;)def get_students(): students = Student.query.all() return render_template(&quot;StudentList.html&quot;, students=students) 获取s_id=1的学生的信息 写法1： 1students = Student.query.filter(Student.s_id==1) 写法2： 1students = Student.query.filter_by(s_id=2) 注意：filter中可以接多个过滤条件 写法3： 12sql = &apos;select * from student where s_id=1&apos;students = db.session.execute(sql) 修改学生的信息 写法1： 123students = Student.query.filter_by(s_id=3).first()students.s_name = &apos;哈哈&apos;db.session.commit() 写法2： 123Student.query.filter_by(s_id=3).update(&#123;&apos;s_name&apos;:&apos;娃哈哈&apos;&#125;)db.session.commit() 删除一个学生的信息 写法1： 123students = Student.query.filter_by(s_id=2).first()db.session.delete(students)db.session.commit() 写法2： 123students = Student.query.filter_by(s_id=1).all()db.session.delete(students[0])db.session.commit() 注意：filter_by后的结果是一个list的结果集 重点注意：在增删改中如果不commit的话，数据库中的数据并不会更新，只会修改本地缓存中的数据，所以一定需要db.session.commit() 6、模型-一对多深入数据库增删改查定义模型，并定义初始化的函数： 1234567891011class Student(db.Model): s_id = db.Column(db.Integer, primary_key=True, autoincrement=True) s_name = db.Column(db.String(16), unique=True) s_age = db.Column(db.Integer, default=1) __tablename__ = &quot;student&quot; def __init__(self, name, age): self.s_name = name self.s_age = age 增–批量增加第一种方式： 12345678910111213141516@blue.route(&apos;/createstus/&apos;)def create_users(): stus = [] for i in range(5): # 实例化Student的对象 s = Student() # 对象的属性赋值 s.s_name = &apos;张三%s&apos; % random.randrange(10000) s.s_age = &apos;%d&apos; % random.randrange(100) stus.append(s) # 添加需要创建的数据 db.session.add_all(stus) # 提交事务到数据库 db.session.commit() return &apos;创建成功&apos; 注：在创建单条数据的时候使用db.session.add()，在创建多条数据的时候使用db.session.add_all() 第二种方式： 12345678910111213@blue.route(&apos;/createstus/&apos;)def create_users(): stus = [] for i in range(5): # 使用类的初始化去创建Student对象 s = Student(&apos;张三%s&apos; % random.randrange(10000), &apos;%d&apos; % random.randrange(100)) stus.append(s) db.session.add_all(stus) db.session.commit() return &apos;创建成功&apos; 查–使用运算符获取查询集 123filter(类名.属性名.运算符(‘xxx’))filter(类名.属性 数学运算符 值) 运算符： 123456789contains： 包含startswith：以什么开始endswith：以什么结束in_：在范围内like：模糊__gt__: 大于__ge__：大于等于__lt__：小于__le__：小于等于 筛选： 1234567891011offset()limit()order_by()get()first()paginate() 逻辑运算： 1234567891011与 and_ filter(and_(条件),条件…)或 or_ filter(or_(条件),条件…)非 not_ filter(not_(条件),条件…) 例子1： 查询学生的id为3，4，5，6，16的的学生信息，使用in_逻辑运算 12345@blue.route('/getstubyids/')def get_stu_by_ids(): students = Student.query.filter(Student.s_id.in_([3,4,5,6,16])) return render_template('StudentList.html', students=students) 查询学生的年龄小于18岁的学生的信息 1Student.query.filter(Student.s_age &lt; 18) 查询学生的年龄小于18岁的学生的信息，lt小于 1students = Student.query.filter(Student.s_age.__lt__(15)) 查询学生的年龄小于等于18岁的学生的信息，le小于等于 1students = Student.query.filter(Student.s_age.__le__(15)) 查询学生的姓名以什么开始或者以什么结尾的学生的信息startswith和endswith 12students = Student.query.filter(Student.s_name.startswith(&apos;张&apos;))students = Student.query.filter(Student.s_name.endswith(&apos;2&apos;)) 查询id=4的学生的信息 12Student.query.get(4)获取的结果是学生的对象 模糊搜索like 1234%：代表一个或者多个_：代表一个Student.query.filter(Student.s_name.like(&apos;%张%&apos;)) 分页，查询第二页的数据4条 12第一个参数是那一页，第二个参数是一页的条数，第三个参数是是否输出错误信息students = Student.query.paginate(2, 4, False).items 例子2： 跳过offset几个信息，截取limit结果的几个值 123456789101112131415161718# 按照id降序排列stus = Student.query.order_by(&apos;-s_id&apos;)# 按照id降序获取三个stus = Student.query.order_by(&apos;-s_id&apos;).limit(3)# 获取年龄最大的一个stus = Student.query.order_by(&apos;-s_age&apos;).first()# 跳过3个数据，查询5个信息stus = Student.query.order_by(&apos;-s_age&apos;).offset(3).limit(5)# 跳过3个数据stus = Student.query.order_by(&apos;-s_age&apos;).offset(3)# 获取id等于24的学生stus = Student.query.filter(Student.s_id==24)stus = Student.query.get(24) 例子3： 查询 from sqlalchemy import and_, or_, not_ 查询多个条件 stus = Student.query.filter(Student.s_age==18, Student.s_name==’雅典娜’) and_ 并且条件 stus = Student.query.filter(and_(Student.s_age==18, Student.s_name==’雅典娜’)) or_ 或者条件 stus = Student.query.filter(or_(Student.s_age==18, Student.s_name==’火神’)) not_ 非 stus = Student.query.filter(not_(Student.s_age==18), Student.s_name==’火神’) 例子4： 分页： 后端数据处理： 12345678910# 查询第几页的数据 page = int(request.args.get(&apos;page&apos;, 1))# 每一页的条数多少，默认为10条per_page = int(request.args.get(&apos;per_page&apos;, 10))# 查询当前第几个的多少条数据paginate = Student.query.order_by(&apos;-s_id&apos;).paginate(page, per_page, error_out=False)stus = paginate.items 前端数据展示： 123456789101112131415161718192021222324252627&lt;h2&gt;学生信息&lt;/h2&gt;&#123;% for stu in stus %&#125; id：&#123;&#123; stu.s_id &#125;&#125; 姓名：&#123;&#123; stu.s_name &#125;&#125; 年龄：&#123;&#123; stu.s_age &#125;&#125; &lt;br&gt;&#123;% endfor %&#125;&lt;br&gt;总页数: &#123;&#123; paginate.pages &#125;&#125;&lt;br&gt;一共&#123;&#123; paginate.total &#125;&#125;条数据&lt;br&gt;当前页数：&#123;&#123; paginate.page &#125;&#125;&lt;br&gt;&#123;% if paginate.has_prev %&#125; &lt;a href=&quot;/stupage/?page=&#123;&#123; paginate.prev_num &#125;&#125;&quot;&gt;上一页&lt;/a&gt;：&#123;&#123; paginate.prev_num &#125;&#125;&#123;% endif %&#125;&#123;% if paginate.has_next %&#125; &lt;a href=&quot;/stupage/?page=&#123;&#123; paginate.next_num &#125;&#125;&quot;&gt;下一页&lt;/a&gt;：&#123;&#123; paginate.next_num &#125;&#125;&#123;% endif %&#125;&lt;br&gt;&lt;br&gt;页码：&#123;% for i in paginate.iter_pages() %&#125; &lt;a href=&quot;/stupage/?page=&#123;&#123; i &#125;&#125;&quot;&gt;&#123;&#123; i &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; 关联关系一对多建立模型学生模型： 12345678class Student(db.Model): s_id = db.Column(db.Integer, primary_key=True, autoincrement=True) s_name = db.Column(db.String(20), unique=True) s_age = db.Column(db.Integer, default=18) s_g = db.Column(db.Integer, db.ForeignKey(&apos;grade.g_id&apos;), nullable=True) __tablename__ = &apos;student&apos; 班级模型： 123456789class Grade(db.Model): g_id = db.Column(db.Integer, primary_key=True, autoincrement=True) g_name = db.Column(db.String(10), unique=True) g_desc = db.Column(db.String(100), nullable=True) g_time = db.Column(db.Date, default=datetime.now) students = db.relationship(&apos;Student&apos;, backref=&apos;stu&apos;, lazy=True) __tablename__ = &apos;grade&apos; 官网解释有如下几个lazy的参数： lazy 决定了 SQLAlchemy 什么时候从数据库中加载数据:，有如下四个值: 1234567select/True: (which is the default) means that SQLAlchemy will load the data as necessary in one go using a standard select statement.joined/False: tells SQLAlchemy to load the relationship in the same query as the parent using a JOIN statement.subquery: works like ‘joined’ but instead SQLAlchemy will use a subquery.dynamic: is special and useful if you have many items. Instead of loading the items SQLAlchemy will return another query object which you can further refine before loading the items. This is usually what you want if you expect more than a handful of items for this relationship 12345select就是访问到属性的时候，就会全部加载该属性的数据。joined则是在对关联的两个表进行join操作，从而获取到所有相关的对象。dynamic则不一样，在访问属性的时候，并没有在内存中加载数据，而是返回一个query对象, 需要执行相应方法才可以获取对象， 通过班级查询学生信息 1234567891011@grade.route(&apos;/selectstubygrade/&lt;int:id&gt;/&apos;)def select_stu_by_grade(id): grade = Grade.query.get(id) # 通过班级对象.定义的relationship变量去获取学生的信息 stus = grade.students return render_template(&apos;grade_student.html&apos;, stus=stus, grade=grade ) 通过学生信息查询班级信息 1234567891011@stu.route(&apos;/selectgradebystu/&lt;int:id&gt;/&apos;) def select_grade_by_stu(id): stu = Student.query.get(id) # 通过学生对象.定义的backref参数去获取班级的信息 grade = stu.stu return render_template(&apos;student_grade.html&apos;, grade=grade, stu=stu) 注意：表的外键由db.ForeignKey指定，传入的参数是表的字段。db.relations它声明的属性不作为表字段，第一个参数是关联类的名字，backref是一个反向身份的代理,相当于在Student类中添加了stu的属性。例如，有Grade实例dept和Student实例stu。dept.students.count()将会返回学院学生人数;stu.stu.first()将会返回学生的学院信息的Grade类实例。一般来讲db.relationship()会放在一这一边。 数据库迁移在django中继承了makemigrations，可以通过migrate操作去更新数据库，修改我们定义的models，然后在将模型映射到数据库中。 在flask中也有migrate操作，它能跟踪模型的变化，并将变化映射到数据库中 安装migrate1pip install flask-migrate 配置使用migrate初始化，使用app和db进行migrate对象的初始化 1234from flask_migrate import Migrate#绑定app和数据库Migrate(app=app, db=db) 安装了flask-script的话，可以在Manager()对象上添加迁移指令 1234567from flask_migrate import Migrate, MigrateCommandapp = Flask(__name__)manage = Manager(app=app)manage.add_command(&apos;db&apos;, MigrateCommand) 操作： 123456789python manage.py db init 初始化出migrations的文件，只调用一次python manage.py db migrate 生成迁移文件python manage.py db upgrade 执行迁移文件中的升级python manage.py db downgrade 执行迁移文件中的降级python manage.py db --help 帮助文档 7、模型-多对多关联关系—多对多定义模型： 引入SLALchemy 123from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy() 创建中间表 1234sc = db.Table(&apos;sc&apos;, db.Column(&apos;s_id&apos;, db.Integer, db.ForeignKey(&apos;student.s_id&apos;), primary_key=True), db.Column(&apos;c_id&apos;, db.Integer, db.ForeignKey(&apos;courses.c_id&apos;), primary_key=True)) 创建学生类Student 1234567891011121314class Student(db.Model): s_id = db.Column(db.Integer, primary_key=True, autoincrement=True) s_name = db.Column(db.String(20), unique=True) s_age = db.Column(db.Integer, default=18) s_g = db.Column(db.Integer, db.ForeignKey(&apos;grade.g_id&apos;), nullable=True) __tablename__ = &apos;student&apos; def __init__(self, name, age): self.s_name = name self.s_age = age self.s_g = None 创建课程表的模型，Course类 12345678910111213class Course(db.Model): c_id = db.Column(db.Integer, primary_key=True, autoincrement=True) c_name = db.Column(db.String(20), unique=True) students = db.relationship(&apos;Student&apos;, secondary=sc, backref=&apos;cou&apos;) __tablename__ = &apos;courses&apos; def __init__(self, name): self.c_name = name sc表由db.Table声明，我们不需要关心这张表，因为这张表将会由SQLAlchemy接管，它唯一的作用是作为students表和courses表关联表，所以必须在db.relationship()中指出sencondary关联表参数。lazy是指查询时的惰性求值的方式，这里有详细的参数说明，而db.backref是声明反向身份代理，其中的lazy参数是指明反向查询的惰性求值方式. 添加学生和课程之间的关系 通过页面中传递学生的id和课程的id，分别获取学生的对象和课程的对象，在使用关联关系append去添加学生对象，并且add以后再commit后，就可以在中间表sc中查看到新增的关联关系了。 123456789userid = request.form.get(&apos;userid&apos;) courseid = request.form.get(&apos;courseid&apos;) stu = Student.query.get(userid) cou = Course.query.get(courseid) cou.students.append(stu) db.session.add(cou) db.session.commit() 删除学生和课程之间的关系 通过页面获取传递的学生的id和课程的id，分别获取学生对象和课程对象，在使用关联关系remove去删除学生对象，并commit将事务提交到数据库中 12345stu = Student.query.get(s_id)cou = Course.query.get(c_id)cou.students.remove(stu)db.session.commit() 通过课程查询学生的信息 以下定义在课程course的模型中，所以通过课程查询学生的信息，语法为课程的对象.studengs。如果知道学生的信息反过来找课程的信息，则使用backref的反向关联去查询，语语法为学生的对象.cou(反向) students = db.relationship(‘Student’,secondary=sc,backref=’cou’) 12cou = Course.query.get(2)stus = cou.students 通过学生去查询课程的信息 12stu = Student.query.get(id)cous = stu.cou 8、插件开发，页面调试工具debugtoolbar 1.1 安装 1pip install flask-debugtoolbar 1.2 配置 1234567891011from flask import Flaskfrom flask_debugtoolbar import DebugToolbarExtensionapp = Flask(__name__)app.debug = Trueapp.config[&apos;SECRET_KEY&apos;] = &apos;&lt;replace with a secret key&gt;&apos;toolbar = DebugToolbarExtension(app) 2. restfulFlask-RESTful 提供的最主要的基础就是资源(resources)。资源(Resources)是构建在 Flask 可拔插视图 之上，只要在你的资源(resource)上定义方法就能够容易地访问多个 HTTP 方法 官网上描述了一个最简单的restful风格的api，如下： 1234567891011121314from flask import Flaskfrom flask.ext import restfulapp = Flask(__name__)api = restful.Api(app)class HelloWorld(restful.Resource): def get(self): return &#123;&apos;hello&apos;: &apos;world&apos;&#125;api.add_resource(HelloWorld, &apos;/&apos;)if __name__ == &apos;__main__&apos;: app.run(debug=True) 2.1 安装 1pip install flask_restful 2.2 配置 在create_app()获取Flask(name)对象中，设置如下配置 12345from flask_restful import Apiapi = Api()api.init_app(app=app) 在views中需要引入配置的api还有Resource 123456789101112131415161718192021222324252627282930313233343536373839404142# 导入包和restful中的Api对象from flask_restful import Resourcefrom utils.functions import api# 定义类，启动包含了对数据处理的GET,POST,PATCH,PUT,DELETE请求class CreateCourse(Resource):def get(self, id): course = Course.query.get(id) return course.to_dict()def post(self): courses = [&apos;大学英语&apos;, &apos;大学物理&apos;, &apos;线性代数&apos;, &apos;高数&apos;, &apos;VHDL&apos;, &apos;ARM&apos;, &apos;马克思主义&apos;, &apos;农场劳动&apos;] course_list = [] for course in courses: c = Course() c.c_name = course course_list.append(c) db.session.add_all(course_list) db.session.commit() courses = Course.query.all() return [course.to_dict() for course in courses]def patch(self, id): c_name = request.form.get(&apos;c_name&apos;) course = Course.query.get(id) course.c_name = c_name db.session.commit() return &#123;&apos;code&apos;: 200, &apos;data&apos;: course.to_dict(), &apos;msg&apos;: &apos;请求成功&apos;&#125;def delete(self, id): course = Course.query.get(id) db.session.delete(course) db.session.commit() return &#123;&apos;code&apos;: 200, &apos;msg&apos;: &apos;删除成功&apos;&#125;# 绑定处理urlapi.add_resource(CreateCourse, &apos;/api/course/&lt;int:id&gt;/&apos;, &apos;/api/course/&apos;) 2.3 端点(Endpoints) 在一个 API 中，你的资源可以通过多个 URLs 访问。你可以把多个 URLs 传给 Api 对象的 Api.add_resource() 方法。每一个 URL 都能访问到你的 Resource 如： 1api.add_resource(CreateCourse, &apos;/api/course/&lt;int:id&gt;/&apos;, &apos;/api/course/&apos;) 2.4 返回响应 Flask-RESTful 支持视图方法多种类型的返回值。同 Flask 一样，你可以返回任一迭代器，它将会被转换成一个包含原始 Flask 响应对象的响应。Flask-RESTful 也支持使用多个返回值来设置响应代码和响应头 如： 123def get(self, id): course = Course.query.get(id) return course.to_dict(), 200","categories":[{"name":"Web框架","slug":"Web框架","permalink":"https://shuaixiaohao.github.io/categories/Web框架/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://shuaixiaohao.github.io/tags/Flask/"}]},{"title":"爬虫","slug":"爬虫","date":"2017-12-07T14:09:32.000Z","updated":"2019-02-01T12:05:19.550Z","comments":true,"path":"2017/12/07/爬虫/","link":"","permalink":"https://shuaixiaohao.github.io/2017/12/07/爬虫/","excerpt":"1、网络爬虫和相关工具1.1 网络爬虫网络爬虫（web crawler），以前经常称之为网络蜘蛛（spider），是按照一定的规则自动浏览万维网并获取信息的机器人程序（或脚本），曾经被广泛的应用于互联网搜索引擎。使用过互联网和浏览器的人都知道，网页中除了供用户阅读的文字信息之外，还包含一些超链接。网络爬虫系统正是通过网页中的超链接信息不断获得网络上的其它页面。正因如此，网络数据采集的过程就像一个爬虫或者蜘蛛在网络上漫游，所以才被形象的称为网络爬虫或者网络蜘蛛。","text":"1、网络爬虫和相关工具1.1 网络爬虫网络爬虫（web crawler），以前经常称之为网络蜘蛛（spider），是按照一定的规则自动浏览万维网并获取信息的机器人程序（或脚本），曾经被广泛的应用于互联网搜索引擎。使用过互联网和浏览器的人都知道，网页中除了供用户阅读的文字信息之外，还包含一些超链接。网络爬虫系统正是通过网页中的超链接信息不断获得网络上的其它页面。正因如此，网络数据采集的过程就像一个爬虫或者蜘蛛在网络上漫游，所以才被形象的称为网络爬虫或者网络蜘蛛。 爬虫的应用领域在理想的状态下，所有ICP（Internet Content Provider）都应该为自己的网站提供API接口来共享它们允许其他程序获取的数据，在这种情况下爬虫就不是必需品，国内比较有名的电商平台（如淘宝、京东等）、社交平台（如腾讯微博等）等网站都提供了自己的Open API，但是这类Open API通常会对可以抓取的数据以及抓取数据的频率进行限制。对于大多数的公司而言，及时的获取行业相关数据是企业生存的重要环节之一，然而大部分企业在行业数据方面的匮乏是其与生俱来的短板，合理的利用爬虫来获取数据并从中提取出有商业价值的信息是至关重要的。当然爬虫还有很多重要的应用领域，下面列举了其中的一部分： 搜索引擎 新闻聚合 社交应用 舆情监控 行业数据 1.2合法性和背景调研爬虫合法性探讨 网络爬虫领域目前还属于拓荒阶段，虽然互联网世界已经通过自己的游戏规则建立起一定的道德规范(Robots协议，全称是“网络爬虫排除标准”)，但法律部分还在建立和完善中，也就是说，现在这个领域暂时还是灰色地带。 “法不禁止即为许可”，如果爬虫就像浏览器一样获取的是前端显示的数据（网页上的公开信息）而不是网站后台的私密敏感信息，就不太担心法律法规的约束，因为目前大数据产业链的发展速度远远超过了法律的完善程度。 在爬取网站的时候，需要限制自己的爬虫遵守Robots协议，同时控制网络爬虫程序的抓取数据的速度；在使用数据的时候，必须要尊重网站的知识产权（从Web 2.0时代开始，虽然Web上的数据很多都是由用户提供的，但是网站平台是投入了运营成本的，当用户在注册和发布内容时，平台通常就已经获得了对数据的所有权、使用权和分发权）。如果违反了这些规定，在打官司的时候败诉几率相当高。 Robots.txt文件大多数网站都会定义robots.txt文件，下面以淘宝的robots.txt文件为例，看看该网站对爬虫有哪些限制。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152User-agent: BaiduspiderAllow: /articleAllow: /oshtmlDisallow: /product/Disallow: /User-Agent: GooglebotAllow: /articleAllow: /oshtmlAllow: /productAllow: /spuAllow: /dianpuAllow: /overseaAllow: /listDisallow: /User-agent: BingbotAllow: /articleAllow: /oshtmlAllow: /productAllow: /spuAllow: /dianpuAllow: /overseaAllow: /listDisallow: /User-Agent: 360SpiderAllow: /articleAllow: /oshtmlDisallow: /User-Agent: YisouspiderAllow: /articleAllow: /oshtmlDisallow: /User-Agent: SogouspiderAllow: /articleAllow: /oshtmlAllow: /productDisallow: /User-Agent: Yahoo! SlurpAllow: /productAllow: /spuAllow: /dianpuAllow: /overseaAllow: /listDisallow: /User-Agent: *Disallow: / 注意上面robots.txt第一段的最后一行，通过设置“Disallow: /”禁止百度爬虫访问除了“Allow”规定页面外的其他所有页面。因此当你在百度搜索“淘宝”的时候，搜索结果下方会出现：“由于该网站的robots.txt文件存在限制指令（限制搜索引擎抓取），系统无法提供该页面的内容描述”。百度作为一个搜索引擎，至少在表面上遵守了淘宝网的robots.txt协议，所以用户不能从百度上搜索到淘宝内部的产品信息。 1.3 相关工具介绍HTTP协议在开始讲解爬虫之前，我们稍微对HTTP（超文本传输协议）做一些回顾，因为我们在网页上看到的内容通常是浏览器执行HTML语言得到的结果，而HTTP就是传输HTML数据的协议。HTTP和其他很多应用级协议一样是构建在TCP（传输控制协议）之上的，它利用了TCP提供的可靠的传输服务实现了Web应用中的数据交换。按照维基百科上的介绍，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，也就是说这个协议是浏览器和Web服务器之间传输的数据的载体。关于这个协议的详细信息以及目前的发展状况，大家可以阅读阮一峰老师的《HTTP 协议入门》、《互联网协议入门》系列以及《图解HTTPS协议》进行了解，下图是我在四川省网络通信技术重点实验室工作期间用开源协议分析工具Ethereal（抓包工具WireShark的前身）截取的访问百度首页时的HTTP请求和响应的报文（协议数据），由于Ethereal截取的是经过网络适配器的数据，因此可以清晰的看到从物理链路层到应用层的协议数据。 HTTP请求（请求行+请求头+空行+[消息体]）： HTTP响应（响应行+响应头+空行+消息体）： 说明：但愿这两张如同泛黄的照片般的截图帮助你大概的了解到HTTP是一个怎样的协议。 相关工具 Chrome Developer Tools：谷歌浏览器内置的开发者工具。 POSTMAN：功能强大的网页调试与RESTful请求工具。 HTTPie：命令行HTTP客户端。 1234567891011121314151617$ http --header http://www.scu.edu.cnHTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, max-age=600Connection: Keep-AliveContent-Encoding: gzipContent-Language: zh-CNContent-Length: 14403Content-Type: text/htmlDate: Sun, 27 May 2018 15:38:25 GMTETag: &quot;e6ec-56d3032d70a32-gzip&quot;Expires: Sun, 27 May 2018 15:48:25 GMTKeep-Alive: timeout=5, max=100Last-Modified: Sun, 27 May 2018 13:44:22 GMTServer: VWebServerVary: User-Agent,Accept-EncodingX-Frame-Options: SAMEORIGIN BuiltWith：识别网站所用技术的工具。 123456789&gt;&gt;&gt;&gt;&gt;&gt; import builtwith&gt;&gt;&gt; builtwith.parse(&apos;http://www.bootcss.com/&apos;)&#123;&apos;web-servers&apos;: [&apos;Nginx&apos;], &apos;font-scripts&apos;: [&apos;Font Awesome&apos;], &apos;javascript-frameworks&apos;: [&apos;Lo-dash&apos;, &apos;Underscore.js&apos;, &apos;Vue.js&apos;, &apos;Zepto&apos;, &apos;jQuery&apos;], &apos;web-frameworks&apos;: [&apos;Twitter Bootstrap&apos;]&#125;&gt;&gt;&gt;&gt;&gt;&gt; import ssl&gt;&gt;&gt; ssl._create_default_https_context = ssl._create_unverified_context&gt;&gt;&gt; builtwith.parse(&apos;https://www.jianshu.com/&apos;)&#123;&apos;web-servers&apos;: [&apos;Tengine&apos;], &apos;web-frameworks&apos;: [&apos;Twitter Bootstrap&apos;, &apos;Ruby on Rails&apos;], &apos;programming-languages&apos;: [&apos;Ruby&apos;]&#125; python-whois：查询网站所有者的工具。 1234&gt;&gt;&gt;&gt;&gt;&gt; import whois&gt;&gt;&gt; whois.whois(&apos;baidu.com&apos;)&#123;&apos;domain_name&apos;: [&apos;BAIDU.COM&apos;, &apos;baidu.com&apos;], &apos;registrar&apos;: &apos;MarkMonitor, Inc.&apos;, &apos;whois_server&apos;: &apos;whois.markmonitor.com&apos;, &apos;referral_url&apos;: None, &apos;updated_date&apos;: [datetime.datetime(2017, 7, 28, 2, 36, 28), datetime.datetime(2017, 7, 27, 19, 36, 28)], &apos;creation_date&apos;: [datetime.datetime(1999, 10, 11, 11, 5, 17), datetime.datetime(1999, 10, 11, 4, 5, 17)], &apos;expiration_date&apos;: [datetime.datetime(2026, 10, 11, 11, 5, 17), datetime.datetime(2026, 10, 11, 0, 0)], &apos;name_servers&apos;: [&apos;DNS.BAIDU.COM&apos;, &apos;NS2.BAIDU.COM&apos;, &apos;NS3.BAIDU.COM&apos;, &apos;NS4.BAIDU.COM&apos;, &apos;NS7.BAIDU.COM&apos;, &apos;dns.baidu.com&apos;, &apos;ns4.baidu.com&apos;, &apos;ns3.baidu.com&apos;, &apos;ns7.baidu.com&apos;, &apos;ns2.baidu.com&apos;], &apos;status&apos;: [&apos;clientDeleteProhibited https://icann.org/epp#clientDeleteProhibited&apos;, &apos;clientTransferProhibited https://icann.org/epp#clientTransferProhibited&apos;, &apos;clientUpdateProhibited https://icann.org/epp#clientUpdateProhibited&apos;, &apos;serverDeleteProhibited https://icann.org/epp#serverDeleteProhibited&apos;, &apos;serverTransferProhibited https://icann.org/epp#serverTransferProhibited&apos;, &apos;serverUpdateProhibited https://icann.org/epp#serverUpdateProhibited&apos;, &apos;clientUpdateProhibited (https://www.icann.org/epp#clientUpdateProhibited)&apos;, &apos;clientTransferProhibited (https://www.icann.org/epp#clientTransferProhibited)&apos;, &apos;clientDeleteProhibited (https://www.icann.org/epp#clientDeleteProhibited)&apos;, &apos;serverUpdateProhibited (https://www.icann.org/epp#serverUpdateProhibited)&apos;, &apos;serverTransferProhibited (https://www.icann.org/epp#serverTransferProhibited)&apos;, &apos;serverDeleteProhibited (https://www.icann.org/epp#serverDeleteProhibited)&apos;], &apos;emails&apos;: [&apos;abusecomplaints@markmonitor.com&apos;, &apos;whoisrelay@markmonitor.com&apos;], &apos;dnssec&apos;: &apos;unsigned&apos;, &apos;name&apos;: None, &apos;org&apos;: &apos;Beijing Baidu Netcom Science Technology Co., Ltd.&apos;, &apos;address&apos;: None, &apos;city&apos;: None, &apos;state&apos;: &apos;Beijing&apos;, &apos;zipcode&apos;: None, &apos;country&apos;: &apos;CN&apos;&#125; robotparser：解析robots.txt的工具。 12345678910&gt;&gt;&gt; from urllib import robotparser&gt;&gt;&gt; parser = robotparser.RobotFileParser()&gt;&gt;&gt; parser.set_url(&apos;https://www.taobao.com/robots.txt&apos;)&gt;&gt;&gt; parser.read()&gt;&gt;&gt; parser.can_fetch(&apos;Hellokitty&apos;, &apos;http://www.taobao.com/article&apos;)False&gt;&gt;&gt; parser.can_fetch(&apos;Baiduspider&apos;, &apos;http://www.taobao.com/article&apos;)True&gt;&gt;&gt; parser.can_fetch(&apos;Baiduspider&apos;, &apos;http://www.taobao.com/product&apos;)False 一个简单的爬虫一个基本的爬虫通常分为数据采集（网页下载）、数据处理（网页解析）和数据存储（将有用的信息持久化）三个部分的内容，当然更为高级的爬虫在数据采集和处理时会使用并发编程或分布式技术，这就需要有调度器（安排线程或进程执行对应的任务）、后台管理程序（监控爬虫的工作状态以及检查数据抓取的结果）等的参与。 一般来说，爬虫的工作流程包括以下几个步骤： 设定抓取目标（种子页面/起始页面）并获取网页。 当服务器无法访问时，按照指定的重试次数尝试重新下载页面。 在需要的时候设置用户代理或隐藏真实IP，否则可能无法访问页面。 对获取的页面进行必要的解码操作然后抓取出需要的信息。 在获取的页面中通过某种方式（如正则表达式）抽取出页面中的链接信息。 对链接进行进一步的处理（获取页面并重复上面的动作）。 将有用的信息进行持久化以备后续的处理。 下面的例子给出了一个从“搜狐体育”上获取NBA新闻标题和链接的爬虫。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from urllib.error import URLErrorfrom urllib.request import urlopenimport reimport pymysqlimport sslfrom pymysql import Error# 通过指定的字符集对页面进行解码(不是每个网站都将字符集设置为utf-8)def decode_page(page_bytes, charsets=(&apos;utf-8&apos;,)): page_html = None for charset in charsets: try: page_html = page_bytes.decode(charset) break except UnicodeDecodeError: pass # logging.error(&apos;Decode:&apos;, error) return page_html# 获取页面的HTML代码(通过递归实现指定次数的重试操作)def get_page_html(seed_url, *, retry_times=3, charsets=(&apos;utf-8&apos;,)): page_html = None try: page_html = decode_page(urlopen(seed_url).read(), charsets) except URLError: # logging.error(&apos;URL:&apos;, error) if retry_times &gt; 0: return get_page_html(seed_url, retry_times=retry_times - 1, charsets=charsets) return page_html# 从页面中提取需要的部分(通常是链接也可以通过正则表达式进行指定)def get_matched_parts(page_html, pattern_str, pattern_ignore_case=re.I): pattern_regex = re.compile(pattern_str, pattern_ignore_case) return pattern_regex.findall(page_html) if page_html else []# 开始执行爬虫程序并对指定的数据进行持久化操作def start_crawl(seed_url, match_pattern, *, max_depth=-1): conn = pymysql.connect(host=&apos;localhost&apos;, port=3306, database=&apos;crawler&apos;, user=&apos;root&apos;, password=&apos;123456&apos;, charset=&apos;utf8&apos;) try: with conn.cursor() as cursor: url_list = [seed_url] # 通过下面的字典避免重复抓取并控制抓取深度 visited_url_list = &#123;seed_url: 0&#125; while url_list: current_url = url_list.pop(0) depth = visited_url_list[current_url] if depth != max_depth: # 尝试用utf-8/gbk/gb2312三种字符集进行页面解码 page_html = get_page_html(current_url, charsets=(&apos;utf-8&apos;, &apos;gbk&apos;, &apos;gb2312&apos;)) links_list = get_matched_parts(page_html, match_pattern) param_list = [] for link in links_list: if link not in visited_url_list: visited_url_list[link] = depth + 1 page_html = get_page_html(link, charsets=(&apos;utf-8&apos;, &apos;gbk&apos;, &apos;gb2312&apos;)) headings = get_matched_parts(page_html, r&apos;&lt;h1&gt;(.*)&lt;span&apos;) if headings: param_list.append((headings[0], link)) cursor.executemany(&apos;insert into tb_result values (default, %s, %s)&apos;, param_list) conn.commit() except Error: pass # logging.error(&apos;SQL:&apos;, error) finally: conn.close()def main(): ssl._create_default_https_context = ssl._create_unverified_context start_crawl(&apos;http://sports.sohu.com/nba_a.shtml&apos;, r&apos;&lt;a[^&gt;]+test=a\\s[^&gt;]*href=[&quot;\\&apos;](.*?)[&quot;\\&apos;]&apos;, max_depth=2)if __name__ == &apos;__main__&apos;: main() 由于使用了MySQL实现持久化操作，所以要先启动MySQL服务器再运行该程序。 爬虫注意事项通过上面的例子，我们对爬虫已经有了一个感性的认识，在编写爬虫时有以下一些注意事项： 处理相对链接。有的时候我们从页面中获取的链接不是一个完整的绝对链接而是一个相对链接，这种情况下需要将其与URL前缀进行拼接（urllib.parse中的urljoin()函数可以完成此项操作）。 设置代理服务。有些网站会限制访问的区域（例如美国的Netflix屏蔽了很多国家的访问），有些爬虫需要隐藏自己的身份，在这种情况下可以设置使用代理服务器，代理服务器有免费（如西刺代理、快代理）和付费两种（如讯代理、阿布云代理)，付费的一般稳定性和可用性都更好，可以通过urllib.request中的ProxyHandler来为请求设置代理。 限制下载速度。如果我们的爬虫获取网页的速度过快，可能就会面临被封禁或者产生“损害动产”的风险（这个可能会导致吃官司且败诉），可以在两次下载之间添加延时从而对爬虫进行限速。 避免爬虫陷阱。有些网站会动态生成页面内容，这会导致产生无限多的页面（例如在线万年历通常会有无穷无尽的链接）。可以通过记录到达当前页面经过了多少个链接（链接深度）来解决该问题，当达到事先设定的最大深度时爬虫就不再像队列中添加该网页中的链接了。 SSL相关问题。在使用urlopen打开一个HTTPS链接时会验证一次SSL证书，如果不做出处理会产生错误提示“SSL: CERTIFICATE_VERIFY_FAILED”，可以通过以下两种方式加以解决： 使用未经验证的上下文 12345import sslrequest = urllib.request.Request(url=&apos;...&apos;, headers=&#123;...&#125;) context = ssl._create_unverified_context()web_page = urllib.request.urlopen(request, context=context) 设置全局的取消证书验证 123import sslssl._create_default_https_context = ssl._create_unverified_context 2、前言2.1 数据分析爬取网页信息可以使用很多的技术： 获取网页信息：urllib、urllib3、requests 123requests为第三方的库，需要安装才能使用 pip install requests 解析网页信息：beautifulsoup4(bs4)、re、xpath、lxml 12345bs4为第三方的库，需要安装才能使用 pip install beautifulsoup4 使用的时候 from bs4 import BeautifulSoup 这样导入 Python 标准库中自带了 xml 模块，但是性能不够好，而且缺乏一些人性化的 API，相比之下，第三方库 lxml 是用 Cython 实现的，而且增加了很多实用的功能。 12345安装lxml，在新版本中无法使用from lxml import etreepip install lxml 并不推荐这样去安装lxml 推荐安装的方法：访问网站(https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml)下载lxml的安装whl文件，然后进行安装。 注意：下载文件必须与python版本号、位数一致 我这儿下载的是lxml-4.2.1-cp36-cp36m-win_amd64.whl，安装命令如下 1pip install lxml-4.2.1-cp36-cp36m-win_amd64.whl 截图： 动态数据解析 通用：selenium(自动化测试框架) 2.2 请求头分析123456789101112131415161718192021222324# 浏览器告诉服务器可以接收的文本类型, */*表示任何类型都可以接收Accept: text/html, */*;q=0.8# 浏览器告诉服务器，数据可以压缩，页面可以解压数据然后进行渲染。做爬虫的时候，最好不要写该参数Accept-Encoding: gzip, deflate # 语言类型Accept-Language: zh-CN,zh;q=0.9 Cache-Control: max-age=0# 保持连接Connection: keep-alive # 会话 Cookie: Hm_lvt_3bfcc098e0da26d58c321ba579b04b2f=1527581188,1528137133# 域名Host: www.cdtopspeed.com Upgrade-Insecure-Requests: 1# 用户代理, 使得服务器能够识别请求是通过浏览器请求过来的，其中包含浏览器的名称/版本等信息User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36 其中在爬虫中最重要的就是User-Agent：在下面urllib的使用中就会详细的解释User-Agent的使用 2.3 urllib的使用使用urllib来获取百度首页的源码 1234import urllib.requestr = urllib.request.urlopen('https://www.baidu.com')print(r.read().decode('utf-8')) 按照我们的想法来说，输出的结果应该是百度首页的源码才对，但是输出却不对(多请求几次，就会出现如下的结果)，如下结果： 12345678910&lt;html&gt;&lt;head&gt; &lt;script&gt; location.replace(location.href.replace(\"https://\",\"http://\")); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;noscript&gt;&lt;meta http-equiv=\"refresh\" content=\"0;url=http://www.baidu.com/\"&gt;&lt;/noscript&gt;&lt;/body&gt;&lt;/html&gt; 以上的结果并不是我们想要的，我们可以来查看一下为什么会出现这种问题的原因。我们可以想到刚才说的，请求头中的最重要的参数User-Agent参数，该参数是用来告诉服务器，请求的url是来源于哪儿的，是来源于浏览器还是来源于其他地方的。如果是来源于非浏览器的会就不会返回源码信息给你的，直接拦截掉你的请求 分析以上代码中，默认提交的请求头中的User-Agent到底传递了什么值： 接下来，就是优化以上的代码，实现目的就是告诉服务器我们这个请求是来源于浏览器的。 12345678header = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/65.0.3325.181 Safari/537.36'&#125;res = urllib.request.Request('https://www.baidu.com', headers=header)# 读取url的页面源码r = urllib.request.urlopen(res)# decode解码，encode编码print(r.read().decode('utf-8')) 按照这样去解析，就可以获取到百度的首页源代码了，展示部门代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;&lt;meta content=&quot;always&quot; name=&quot;referrer&quot;&gt;&lt;meta name=&quot;theme-color&quot; content=&quot;#2932e1&quot;&gt;&lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;&lt;link rel=&quot;search&quot; type=&quot;application/opensearchdescription+xml&quot; href=&quot;/content-search.xml&quot; title=&quot;百度搜索&quot; /&gt;&lt;link rel=&quot;icon&quot; sizes=&quot;any&quot; mask href=&quot;//www.baidu.com/img/baidu_85beaf5496f291521eb75ba38eacbd87.svg&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//s1.bdstatic.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t1.baidu.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t2.baidu.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t3.baidu.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t10.baidu.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t11.baidu.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t12.baidu.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//b1.bdstatic.com&quot;/&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;style id=&quot;css_index&quot; index=&quot;index&quot; type=&quot;text/css&quot;&gt;html,body&#123;height:100%&#125;html&#123;overflow-y:auto&#125;body&#123;font:12px arial;text-align:;background:#fff&#125;body,p,form,ul,li&#123;margin:0;padding:0;list-style:none&#125;body,form,#fm&#123;position:relative&#125;td&#123;text-align:left&#125;img&#123;border:0&#125;a&#123;color:#00c&#125;a:active&#123;color:#f60&#125;input&#123;border:0;padding:0&#125;#wrapper&#123;position:relative;_position:;min-height:100%&#125;#head&#123;padding-bottom:100px;text-align:center;*z-index:1&#125;...忽略.......忽略.......忽略....&lt;/body&gt;&lt;/html&gt; 2.4 requests官网地址 安装 1pip install requests 发送请求，GET、POST、PUT、PATCH、DELETE 使用请求发送网络请求非常简单。 一开始要导入请求模块： 1import requests 然后，尝试获取某个网页。本例子中，我们来获取Github的公共时间线： 1r = requests.get('https://api.github.com/events') 请求简便的API意味着所有HTTP请求类型都是显而易见的。例如，你可以这样发送一个HTTP POST请求： 1r = requests.post('http://httpbin.org/post', data = &#123;'key':'value'&#125;) 传递URL参数 你也许经常想为URL的查询字符串（query string）传递某种数据。如果你是手工构造URL，那么数据会以键/值对的形式置于URL中，跟在一个问号的后面。例如， httpbin.org/get?key=val。 请求允许你使用params关键字参数，以一个字符串字典来提供这些参数。 举例来说，如果你想传递key1 = value1和key2 = value2到httpbin.org/get，那么你可以使用如下代码： 123payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;r = requests.get(&quot;http://httpbin.org/get&quot;, params=payload) 通过打印输出该URL，你能看到URL已被正确确认编码： 123print(r.url)http://httpbin.org/get?key2=value2&amp;key1=value1 注意字典里值为无的键都不会被添加到URL的查询字符串里。 你还可以将一个列表作为值传入： 1234567payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: [&apos;value2&apos;, &apos;value3&apos;]&#125;r = requests.get(&apos;http://httpbin.org/get&apos;, params=payload)print(r.url)http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3 响应内容 我们能读取服务器响应的内容。再次以GitHub时间线为例： 12345import requestsr = requests.get(&apos;https://api.github.com/events&apos;)r.textu&apos;[&#123;&quot;repository&quot;:&#123;&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https://github.com/... 请求会自动解码来自服务器的内容。大多数unicode字符集都能被无缝地解码。 请求发出后，请求会基于HTTP头部对响应的编码作出有根据的推测。当你访问r.text之时，请求会使用其推测的文本编码。你可以找出请求使用了什么编码，并且能够使用r.encoding属性来改变它： 1234r.encoding&apos;utf-8&apos;r.encoding = &apos;ISO-8859-1&apos; 如果你改变了编码，每当你访问r.text，请求都将会使用r.encoding的新值。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如HTTP和XML自身可以指定编码。这样的话，你应该使用r.content来找到编码，然后设置r.encoding为相应的编码。这样就能使用正确的编码解析r.text了。 在你需要的情况下，请求也可以使用定制的编码。如果你创建了自己的编码，并使用编解码器模块进行注册，你就可以轻松地使用这个解码器名称作为r.encoding的值，然后由Requests来为你处理编码 2.5 ssl认证什么是 SSL 证书？ SSL 证书就是遵守 SSL 安全套接层协议的服务器数字证书。 而 SSL 安全协议最初是由美国网景 Netscape Communication 公司设计开发的，全称为：安全套接层协议 (Secure Sockets Layer) ， 它指定了在应用程序协议 ( 如 HTTP 、 Telnet 、 FTP) 和 TCP/IP 之间提供数据安全性分层的机制，它是在传输通信协议 (TCP/IP) 上实现的一种安全协议，采用公开密钥技术，它为 TCP/IP 连接提供数据加密、服务器认证、消息完整性以及可选的客户机认证。由于此协议很好地解决了互联网明文传输的不安全问题，很快得到了业界的支持，并已经成为国际标准。 SSL 证书由浏览器中“受信任的根证书颁发机构”在验证服务器身份后颁发，具有网站身份验证和加密传输双重功能。 如果能使用 https:// 来访问某个网站，就表示此网站是部署了SSL证书。一般来讲，如果此网站部署了SSL证书，则在需要加密的页面会自动从 http:// 变为 https:// ，如果没有变，你认为此页面应该加密，您也可以尝试直接手动在浏览器地址栏的http后面加上一个英文字母“ s ”后回车，如果能正常访问并出现安全锁，则表明此网站实际上是部署了SSL证书，只是此页面没有做 https:// 链接；如果不能访问，则表明此网站没有部署 SSL证书。 案例: 访问加密的12306的网站 如果不忽略ssl的安全认证的话，网页的源码会提示ssl认证问题，需要提供ssl认证。我们在做爬虫的时候，自动设置忽略掉ssl认证即可。代码如下： 1234567891011121314import sslimport urllib.requestdef main(): url = &apos;https://www.12306.cn/mormhweb/&apos; # 忽略未经审核的ssl认证 context = ssl._create_unverified_context() res = urllib.request.urlopen(url, context=context) print(res.read().decode(&apos;utf-8&apos;))if __name__ == &apos;__main__&apos;: main() 3、数据采集和解析通过《网络爬虫和相关工具》一文，我们已经了解到了开发一个爬虫需要做的工作以及一些常见的问题，至此我们可以对爬虫开发需要做的工作以及相关的技术做一个简单的汇总，这其中可能会有一些我们之前没有使用过的第三方库。 下载数据 - urllib / requests / aiohttp。 解析数据 - re / lxml / beautifulsoup4（bs4）/ pyquery。 缓存和持久化 - pymysql / sqlalchemy / peewee/ redis / pymongo。 生成数字签名 - hashlib。 序列化和压缩 - pickle / json / zlib。 调度器 - 进程（multiprocessing） / 线程（threading） / 协程（coroutine）。 四种采集方式 四种采集方式的比较 抓取方法 速度 使用难度 备注 正则表达式 快 困难 常用正则表达式在线正则表达式测试 lxml 快 一般 需要安装C语言依赖库唯一支持XML的解析器 Beautiful 较快/较慢（取决于解析器） 简单 PyQuery 较快 简单 Python版的jQuery 说明：Beautiful的解析器包括：Python标准库（html.parser）、lxml的HTML解析器、lxml的XML解析器和html5lib。 正则表达式如果你对正则表达式没有任何的概念，那么推荐先阅读《正则表达式30分钟入门教程》，然后再阅读我们之前讲解在Python中如何使用正则表达式一文。 re正则匹配 匹配规则：（原始字符串’booby123’） 123456789101112131415161718192021222324252627282930313233343536373839^ 开头 &apos;^b.*&apos;----以b开头的任意字符$ 结尾 &apos;^b.*3$&apos;----以b开头，3结尾的任意字符* 任意长度（次数），≥0 ? 非贪婪模式，非贪婪模式尽可能少的匹配所搜索的字符串 &apos;.*?(b.*?b).*&apos;----从左至右第一个b和的二个b之间的内容（包含b）+ 一次或多次&#123;2&#125; 指定出现次数2次&#123;2,&#125; 出现次数≥2次&#123;2,5&#125; 出现次数2≤x≤5| 或 例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[z|f]ood”则匹配“zood”或“food”或&quot;zood&quot;。[] 中括号中任意一个符合即可（中括号里面没有分转义字符） &apos;[abc]ooby123&apos;----只要开头符合[]中任意一个即可[^] 只要不出现[]的即可[a-Z] 从小a到大Z &apos;1[48357][0-9]&#123;9&#125;&apos;----电话号码. 任意字符\\s 匹配不可见字符 \\n \\t &apos;你\\s好&apos;----可以匹配‘你 好’\\S 匹配可见字符，即普通字符\\w 匹配下划线在内的任何单词字符\\W 和上一个相反[\\u4E00-\\u9FA5] 只能匹配汉字() 要取出的信息就用括号括起来\\d 数字 XPath语法与Lxml库XPATH 术语 中文文档地址 在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。 请看下面这个 XML 文档： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;bookstore&gt;&lt;book&gt; &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt;&lt;/book&gt;&lt;/bookstore&gt; 上面的XML文档中的节点例子： 12345&lt;bookstore&gt; （文档节点）&lt;author&gt;J K. Rowling&lt;/author&gt; （元素节点）lang=&quot;en&quot; （属性节点） 基本值（或称原子值，Atomic value）基本值是无父或无子的节点。 节点关系 父（Parent）、子（Children） 每个元素以及属性都有一个父。 例子: 12345678&lt;bookstore&gt; &lt;book&gt; &lt;title&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; book 元素是 title、author、year 以及 price 元素的父 title、author、year 以及 price 元素都是 book 元素的子 title、author、year 以及 price 元素都是同胞： title 元素的先辈是 book 元素和 bookstore 元素 bookstore 的后代是 book、title、author、year 以及 price 元素 选取节点 XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。 表达式 描述 nodename 选取此节点的所有子节点。 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 选取未知节点 XPath 通配符可用来选取未知的 XML 元素。 通配符 描述 * 匹配任何元素节点。 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 选取若干路径 通过在路径表达式中使用“|”运算符，您可以选取若干个路径。 爬取搜狐体育： 1234567891011121314151617181920212223242526272829303132import reimport urllibfrom urllib import requestfrom lxml import etreedef get_code(url): headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36' &#125; req = urllib.request.Request(url, headers=headers) res = urllib.request.urlopen(req) return resdef get_crawl(url): res = get_code(url) p1_url = re.findall(\"&lt;a test=a href='(.+?)'\", res.read().decode('GBK')) return p1_urldef get_content(url): res2 = get_code(url) tree = etree.HTML(res2.read().decode('utf-8')) p2_title = tree.xpath('//*[@id=\"article-container\"]/div[2]/div[1]/div[1]/h1/text()') p2_content = tree.xpath('//*[@id=\"mp-editor\"]/p/text()') return p2_title, p2_contentif __name__ == '__main__': url = 'http://sports.sohu.com/nba_a.shtml' p_urls = get_crawl(url) for p_url in p_urls: result = get_content(p_url) print(result) BeautifulSoupBeautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间.—–引入官网地址的一句话 安装 Beautiful Soup 4 通过PyPi发布,所以如果你无法使用系统包管理安装,那么也可以通过 easy_install 或 pip 来安装.包的名字是 beautifulsoup4 ,这个包兼容Python2和Python3. 1pip install beautifulsoup4 创建 Beautiful Soup 对象 1234567891011from bs4 import BeautifulSoup # 首先必须要导入 bs4 库html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\" soups = BeautifulSoup(html) # 创建 beautifulsoup 对象# 另外，我们还可以用本地 HTML 文件来创建对象，例如# soup = BeautifulSoup(open('index.html')) 解析语法、find、find_all find_all( name , attrs , recursive , text , kwargs )** find_all() 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件 123456781. 查询所有a标签的内容 soup.find_all(&apos;a&apos;)2. 查询所有a标签下class样式为bb的内容 soup.find_all(&apos;a&apos;, &apos;bb&apos;)3. 查询所有id样式为cc的内容 soup.find_all(id=&apos;cc&apos; PyQuerypyquery相当于jQuery的Python实现，可以用于解析HTML网页。 官方文档jQuery参考文档 存储：mysql、redis、mongodb、sqlalchemy 序列化：json 调度器：进程、线程、协程 PyQuery的基本使用 1.安装方法 1pip install pyquery 2.引用方法 1from pyquery import PyQuery as pq 3.简介 pyquery 是类型jquery 的一个专供python使用的html解析的库，使用方法类似bs4。 4.使用方法 4.1 初始化方法： 1234from pyquery import PyQuery as pqdoc =pq(html) #解析html字符串doc =pq(\"http://news.baidu.com/\") #解析网页doc =pq(\"./a.html\") #解析html 文本 4.2 基本CSS选择器 12345678910111213from pyquery import PyQuery as pqhtml = &apos;&apos;&apos; &lt;div id=&quot;wrap&quot;&gt; &lt;ul class=&quot;s_from&quot;&gt; asdasd &lt;link href=&quot;http://asda.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;link href=&quot;http://asda1.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;link href=&quot;http://asda2.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;/ul&gt; &lt;/div&gt;&apos;&apos;&apos;doc = pq(html)print doc(&quot;#wrap .s_from link&quot;) 运行结果： 123&lt;link href=&quot;http://asda.com&quot;&gt;asdadasdad12312&lt;/link&gt;&lt;link href=&quot;http://asda1.com&quot;&gt;asdadasdad12312&lt;/link&gt;&lt;link href=&quot;http://asda2.com&quot;&gt;asdadasdad12312&lt;/link&gt; #是查找id的标签 .是查找class 的标签 link 是查找link 标签 中间的空格表示里层（注意层级关系以空格隔开） 4.3 查找子元素 1234567891011121314151617181920from pyquery import PyQuery as pqhtml = &apos;&apos;&apos; &lt;div id=&quot;wrap&quot;&gt; &lt;ul class=&quot;s_from&quot;&gt; asdasd &lt;link href=&quot;http://asda.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;link href=&quot;http://asda1.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;link href=&quot;http://asda2.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;/ul&gt; &lt;/div&gt;&apos;&apos;&apos;#查找子元素doc = pq(html)items=doc(&quot;#wrap&quot;)print(items)print(&quot;类型为:%s&quot;%type(items))link = items.find(&apos;.s_from&apos;)print(link)link = items.children()print(link) ​ 运行结果： 123456789101112131415161718192021&lt;div id=&quot;wrap&quot;&gt; &lt;ul class=&quot;s_from&quot;&gt; asdasd &lt;link href=&quot;http://asda.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;link href=&quot;http://asda1.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;link href=&quot;http://asda2.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;/ul&gt; &lt;/div&gt;类型为:&lt;class &apos;pyquery.pyquery.PyQuery&apos;&gt;&lt;ul class=&quot;s_from&quot;&gt; asdasd &lt;link href=&quot;http://asda.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;link href=&quot;http://asda1.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;link href=&quot;http://asda2.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;/ul&gt;&lt;ul class=&quot;s_from&quot;&gt; asdasd &lt;link href=&quot;http://asda.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;link href=&quot;http://asda1.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;link href=&quot;http://asda2.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;/ul&gt; 根据运行结果可以发现返回结果类型为pyquery，并且find方法和children 方法都可以获取里层标签 4.4查找父元素 12345doc = pq(html)items=doc(\".s_from\")print(items)#查找父元素parent_href=items.parent() parent可以查找出外层标签包括的内容，与之类似的还有parents,可以获取所有外层节点 4.5 查找兄弟元素 12345doc = pq(html)items=doc(&quot;link.active1.a123&quot;)print(items)#查找兄弟元素siblings_href=items.siblings() ​ 根据运行结果可以看出，siblings 返回了同级的其他标签 结论：子元素查找，父元素查找，兄弟元素查找，这些方法返回的结果类型都是pyquery类型，可以针对结果再次进行选择 4.6 遍历查找结果 1234doc = pq(html)its=doc(&quot;link&quot;).items()for it in its: print(it) ​ 运行结果： 123&lt;link class=&quot;active1 a123&quot; href=&quot;http://asda.com&quot;&gt;asdadasdad12312&lt;/link&gt;&lt;link class=&quot;active2&quot; href=&quot;http://asda1.com&quot;&gt;asdadasdad12312&lt;/link&gt; &lt;link class=&quot;movie1&quot; href=&quot;http://asda2.com&quot;&gt;asdadasdad12312&lt;/link&gt; 4.7获取属性信息 12345doc = pq(html)its=doc(&quot;link&quot;).items()for it in its: print(it.attr(&apos;href&apos;)) print(it.attr.href) #两种写法结果都一样 4.8 获取文本 1234doc = pq(html)its=doc(&quot;link&quot;).items()for it in its: print(it.text()) 4.9 获取 HTML信息 1234doc = pq(html)its=doc(&quot;link&quot;).items()for it in its: print(it.html()) ​ 运行结果： 123&lt;a&gt;asdadasdad12312&lt;/a&gt;asdadasdad12312asdadasdad12312 5.常用DOM操作 5.1 addClass removeClass 添加，移除class标签 12345doc = pq(html)its=doc(&quot;link&quot;).items()for it in its: print(&quot;添加:%s&quot;%it.addClass(&apos;active1&apos;)) print(&quot;移除:%s&quot;%it.removeClass(&apos;active1&apos;)) 需要注意的是已经存在的class标签不会继续添加 5.2 attr css attr 为获取/修改属性 css 添加style属性 12345doc = pq(html)its=doc(&quot;link&quot;).items()for it in its: print(&quot;修改:%s&quot;%it.attr(&apos;class&apos;,&apos;active&apos;)) print(&quot;添加:%s&quot;%it.css(&apos;font-size&apos;,&apos;14px&apos;) attr css操作直接修改对象的 5.3 remove 移除标签 12345doc = pq(html)its=doc(&quot;div&quot;)print(&apos;移除前获取文本结果:\\n%s&apos;%its.text())it=its.remove(&apos;ul&apos;)print(&apos;移除后获取文本结果:\\n%s&apos;%it.text()) 4、并发、并行、同步、异步线程、进程4.1 同步和异步、阻塞和非阻塞同步和异步同步和异步是相对于操作结果来说，会不会等待结果 阻塞和非阻塞阻塞是在煮稀饭的过程中，你不能去干其他的事情。非阻塞是在煮稀饭的过程中，你还可以去做其他的事情。阻塞和非阻塞是相对于线程是否被阻塞 同步和阻塞的区别同步是一个过程，阻塞是线程的一个状态。 当多个线程操作同一公共变量的时候可能会出现竞争的情况，这时候需要使用同步来防止多个线程同时占用资源的情况，让一个线程在运行状态中，另外的线程处于就绪状态，当前一个线程处于暂停状态的时候，后面的处于就绪状态的线程，获取到资源以后，获取到时间片以后就会处于运行状态了。所以阻塞是线程的一个状态而已 并发和并行并发：从点餐系统看，该肯德基店只有一个负责点餐的收银员，而有2台收银点餐设备，服务员同时操作2个收银点餐终端，这叫并发操作收银点餐终端。 并行：肯德基为了拓展业务，提高同时服务的能力，在全世界开设分店，这叫并行。 如何实现并发呢：需要引入多进程，多线程，协程 4.2 进程概念： 进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。 python实现进程： multiprocessing模块就是跨平台版本的多进程模块。 multiprocessing模块提供了一个Process类来代表一个进程对象， 代码： 12345678910111213141516171819202122232425262728293031323334353637383940import osimport timefrom random import randintfrom multiprocessing import Processdef coding(): while True: print(&apos;开始撸代码，PID是%s&apos; % os.getpid()) time.sleep(randint(1, 3)) print(&apos;写累了，不撸了，PID是%s&apos; % os.getpid())def play_weixin(): while True: print(&apos;玩一会微信，PID是%s&apos; % os.getpid()) time.sleep(randint(1,2)) print(&apos;不玩微信了，开始撸代码，PID是%s&apos; % os.getpid())if __name__ == &apos;__main__&apos;: # 创建进程 p1 = Process(target=coding) p2 = Process(target=coding) p3 = Process(target=play_weixin) # 启动进程 p1.start() # 阻塞进程p1 p1.join() # 启动进程 p2.start() p3.start() # 主进程 while True: time.sleep(3) print(&apos;我是主进程，PID是%s&apos; % os.getpid()) 杀掉进程按照上面案例代码运行的话，p1进程会一直阻塞，后面的p2和p3并不会执行。如果在windows中运行的代码，则直接运行‘启动任务管理器’去杀掉进程，这时候p2和p3的进程就会执行了，说明进程之间是相互没有关联的，互不影响的。如果在linux系统中，直接kill -9 PID，就可以杀掉进程了 4.3 线程一个进程中的多个线程可以共享一个资源内存空间 Python的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。 启动一个线程,创建threading的实例，然后直接start()就可以启动我们定义的线程了。 多线程定义一个线程类，继承自threading.Thread 其中打印一下当前线程的名称，使用threading.current_thread().name来获取当前线程的名称。默认的Python就自动给线程命名为Thread-1，Thread-2……。当然我们也可以自定义线程的名称 1234567891011121314151617import threadingclass DataCopy(threading.Thread): def __init__(self, dbname): super(DataCopy, self).__init__() self.dbName = dbname def run(self): print(&apos;Thread %s is running&apos; % threading.current_thread().name) print(&apos;开始备份数据库:%s&apos; % self.dbName) time.sleep(5) print(&apos;数据库%s备份结束&apos; % self.dbName) print(&apos;Thread %s is ended&apos; % threading.current_thread().name) 启动一个线程： 123456thread1 = DataCopy(&apos;database1&apos;)thread1.start()# 线程执行结束的输出提示print(&apos;备份结束&apos;) 运行结果： 守护线程当定义子线程为守护线程的话，当主线程结束了，不管子线程是否执行完，都会被直接给暂停掉。默认daemon为False 代码： 12345678910111213thread1 = DataCopy(&apos;database1&apos;)thread2 = DataCopy(&apos;database2&apos;)# 设置守护线程thread1.daemon = Truethread2.daemon = True# 运行线程thread1.start()thread2.start()# 线程执行结束的输出提示print(&apos;备份结束&apos;) 线程启动解释: start和run的区别 start() 方法是启动一个子线程，线程名就是我们定义的name，或者默认的线程名Thread-1， Thread-2…… run() 方法并不启动一个新线程，就是在主线程中调用了一个普通函数而已。 代码1，先使用start()启动线程，并且打印当前线程的名称： 123456789thread1 = DataCopy(&apos;database1&apos;)thread2 = DataCopy(&apos;database2&apos;)# 使用start启动，两个线程同时执行thread1.start()thread2.start()# 线程执行结束的输出提示print(&apos;备份结束&apos;) 运行结果： 代码2，使用run()启动线程，并且打印当前线程的名称： 12345678thread1 = DataCopy(&apos;database1&apos;)thread2 = DataCopy(&apos;database2&apos;) thread1.run()thread2.run()# 线程执行结束的输出提示print(&apos;备份结束&apos;) 运行结果： 4.4 线程锁使用线程时最不愿意遇到的情况就是多个线程竞争资源，在这种情况下为了保证资源状态的正确性，我们可能需要对资源进行加锁保护的处理，这一方面会导致程序失去并发性，另外如果多个线程竞争多个资源时，还有可能因为加锁方式的不当导致死锁。 要实现将资源和持有资源的线程进行绑定的操作，最简单的做法就是使用threading模块的local类，在网络爬虫开发中，就可以使用local类为每个线程绑定一个MySQL数据库连接或Redis客户端对象，这样通过线程可以直接获得这些资源，既解决了资源竞争的问题，又避免了在函数和方法调用时传递这些资源。 锁的概念线程锁：其实并不是给资源加锁, 而是用锁去锁定资源，你可以定义多个锁,当你需要独占某一资源时，任何一个锁都可以锁这个资源，就好比你用不同的锁都可以把相同的一个门锁住是一个道理 基本语法： 123456#创建锁mutex = threading.Lock()#锁定mutex.acquire([timeout])#释放mutex.release() 代码：怎么使用锁去锁住资源，释放锁 12345678910111213141516171819202122232425262728293031323334import threadingimport timecounter = 0# 只是定义一个锁,并不是给资源加锁,你可以定义多个锁,像下两行代码,当你需要占用这个资源时，任何一个锁都可以锁这个资源counter_lock = threading.Lock()counter_lock2 = threading.Lock()counter_lock3 = threading.Lock()# 可以使用上边三个锁的任何一个来锁定资源class MyThread(threading.Thread): # 使用类定义thread，继承threading.Thread def __init__(self, name): super(MyThread, self).__init__() self.name = &quot;Thread-&quot; + str(name) def run(self): # run函数必须实现 # 多线程是共享资源的，使用全局变量 global counter, counter_lock # 当需要独占counter资源时，必须先锁定，这个锁可以是任意的一个锁，可以使用上边定义的3个锁中的任意一个 time.sleep(1); if counter_lock.acquire(): counter += 1 print(&quot;I am %s, set counter:%s&quot; % (self.name, counter)) # 使用完counter资源必须要将这个锁打开，让其他线程使用 counter_lock.release()if __name__ == &quot;__main__&quot;: for i in range(1, 101): my_thread = MyThread(i) my_thread.start() 以上代码，只是教会你怎么去使用锁，锁住资源，当一个线程在使用锁住的资源的时候，其他线程则无法再使用该资源了，起到了很好的避免资源的竞争。 多线程去打印输出自增的全局变量 定义一个简单的多线程，主要功能是用于打印全局递增的变量参数，并打印线程名。 可以不妨想想，如果启动多线程对同一全局变量进行递增操作的话，就有可能多个线程同时获取到全局变量，然后进行递增操作。可想而知，如果是这样的话，那么打印出来的变量就有可能会重复。这就是出现了一个进程中，多线程同时共享一个资源的时候，出现的资源竞争的问题了。我们先查看一下代码的运行结果，然后进行分析： 12345678910111213141516171819202122232425262728293031323334353637383940import threadingimport timeclass MyThread(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): global n, lock # 休眠1秒钟 time.sleep(1) # 线程主要打印循环地址的n值，和对于的线程的名称，线程名也可以使用self.name来获取 print(n, threading.current_thread().name) n += 1if __name__ == &apos;__main__&apos;: # 设置全局变量 n = 1 ThreadList = [] # 创建线程锁 lock = threading.Lock() # 创建20个线程 for i in range(1, 20): t = MyThread() ThreadList.append(t) # 启动线程 for t in ThreadList: t.start() # 阻塞线程 for t in ThreadList: t.join() 运行结果： 1234567891011121314151617181920211 Thread-21 Thread-31 Thread-14 Thread-74 Thread-54 Thread-94 Thread-45 Thread-66 Thread-117 Thread-109 Thread-812 Thread-1512 Thread-1912 Thread-1812 Thread-1612 Thread-1714 Thread-1218 Thread-1419 Thread-13Process finished with exit code 0 分析： 很明显的在我们的执行结果中，打印的全局变量n中有很多重复的，这就印证了我们的多线程在共享资源上存在不可避免的资源竞争的关系。为了解决这种资源的竞争，我们可以采取线程锁的形式去避免对资源的竞争 优化多线程打印输出自增的全局变量 代码优化： 12345678910111213def run(self): global n, lock time.sleep(1) # 判断是否锁定了资源 if lock.acquire(): # 如果锁定了资源，则打印如下的全局变量n和线程名，并且全局变量n自增1 print(n, self.name) n += 1 # 释放锁 lock.release() 运行结果： 1234567891011121314151617181920211 Thread-22 Thread-33 Thread-14 Thread-45 Thread-56 Thread-87 Thread-98 Thread-129 Thread-1310 Thread-611 Thread-1612 Thread-1713 Thread-1814 Thread-715 Thread-1916 Thread-1117 Thread-1018 Thread-1519 Thread-14Process finished with exit code 0 分析：在优化的代码中，我们先建立了一个threading.Lock类对象lock,在run方法里，我们使用lock.acquire()获得了这个锁。此时，其他的线程就无法再获得该锁了，他们就会阻塞在“if lock.acquire()”这里，直到锁被另一个线程释放：lock.release()。所以，if语句中的内容就是一块完整的代码，不会再存在执行了一半就暂停去执行别的线程的情况。所以最后结果是整齐的。完美的解决了多线程竞争同一资源造成的问题了。 5、异步I/O协程的概念协程（coroutine）通常又称之为微线程或纤程，它是相互协作的一组子程序（函数）。所谓相互协作指的是在执行函数A时，可以随时中断去执行函数B，然后又中断继续执行函数A。注意，这一过程并不是函数调用（因为没有调用语句），整个过程看似像多线程，然而协程只有一个线程执行。协程通过yield关键字和 send()操作来转移执行权，协程之间不是调用者与被调用者的关系。 协程的优势在于以下两点： 执行效率极高，因为子程序（函数）切换不是线程切换，由程序自身控制，没有切换线程的开销。 不需要多线程的锁机制，因为只有一个线程，也不存在竞争资源的问题，当然也就不需要对资源加锁保护，因此执行效率高很多。 说明：协程适合处理的是I/O密集型任务，处理CPU密集型任务并不是它的长处，如果要提升CPU的利用率可以考虑“多进程+协程”的模式。 历史回顾 Python 2.2：第一次提出了生成器（最初称之为迭代器）的概念（PEP 255）。 Python 2.5：引入了将对象发送回暂停了的生成器这一特性即生成器的send()方法（PEP 342）。 Python 3.3：添加了yield from特性，允许从迭代器中返回任何值（注意生成器本身也是迭代器），这样我们就可以串联生成器并且重构出更好的生成器。 Python 3.4：引入asyncio.coroutine装饰器用来标记作为协程的函数，协程函数和asyncio及其事件循环一起使用，来实现异步I/O操作。 Python 3.5：引入了async和await，可以使用async def来定义一个协程函数，这个函数中不能包含任何形式的yield语句，但是可以使用return或await从协程中返回值。 在将协程的时候，需要分别引入迭代器和生成器的含义以及案例 迭代器 迭代器和生成器都是python中最重要的知识点。迭代器可以遍历整个对象，在你需要取值的时候，调用next就可以依次获取迭代器中的下一个值，在迭代中中只能往下取值，不能再往上取值的 案例代码： 声明一个列表[1，2，3，4]，然后使用iter()去创建一个迭代器，然后依次调用next()就可以获取到迭代器中的下一个值了 1234567s = iter([1, 2, 3, 4])print(type([1, 2, 3, 4]))print(type(s))print(s.__next__())print(s.__next__())print(s.__next__()) 运行结果： 1234567&lt;class &apos;list&apos;&gt;&lt;class &apos;list_iterator&apos;&gt;123Process finished with exit code 0 生成器 什么是生成器：使用了 yield 的函数被称为生成器（generator）。生成器函数返回的结果就是一个迭代器，只能用于迭代操作。既然是迭代器了，就有next()的属性了。 那生成器是怎么工作的呢：在调用生成器运行的过程中，当在第一次运行的时候，在遇到yield时函数会暂停并保持当前所有的运行信息，返回一个yield的值，当再次next()的时候，才会在当前代码位置进行运行。 案例代码： 实现斐波那契算法 0 1 1 2 3 5 8 13 21 34 55 12345678910111213141516171819202122232425import sysdef fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if counter &gt; n: return yield a a, b = b, a + b counter += 1if __name__ == &apos;__main__&apos;: f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: # print(next(f), end=&quot; &quot;) print(f.__next__(), end=&quot; &quot;) except StopIteration: # 如果获取到最后一个的时候，再获取next就会提示StopIteration的异常了 sys.exit() 运行结果为： 1230 1 1 2 3 5 8 13 21 34 55 Process finished with exit code 0 执行线路图： 查看执行的流程可以使用debug模式去运行，通过断点调试可以很清晰的了解到整个代码的运行流程。 协程例子 案例代码： 消费者和生产者模式 12345678910111213141516171819202122232425262728293031323334import timedef consumer(): r = &apos;1xx&apos; while True: n = yield r if not n: return print(&apos;[CONSUMER] 吃鸡翅 %s...&apos; % n) time.sleep(1) r = &apos;吃完啦，饱饱的了&apos;def produce(customer): # 启动迭代器 customer.__next__() # 设置变量参数为0 n = 0 while n &lt; 3: n = n + 1 print(&apos;[PRODUCER] 做鸡翅 %s...&apos; % n) # 想customer中传递变量n，直接跳到consumer中执行 r = customer.send(n) print(&apos;[PRODUCER] 吃鸡翅状态 return: %s&apos; % r) # 关闭消费者 customer.close()if __name__ == &apos;__main__&apos;: print(&apos;开始协程&apos;) customer = consumer() produce(customer) print(&apos;结束协程&apos;) 运行结果： 12345678910111213开始协程[PRODUCER] 做鸡翅 1...[CONSUMER] 吃鸡翅 1...[PRODUCER] 吃鸡翅状态 return: 吃完啦，饱饱的了[PRODUCER] 做鸡翅 2...[CONSUMER] 吃鸡翅 2...[PRODUCER] 吃鸡翅状态 return: 吃完啦，饱饱的了[PRODUCER] 做鸡翅 3...[CONSUMER] 吃鸡翅 3...[PRODUCER] 吃鸡翅状态 return: 吃完啦，饱饱的了结束协程Process finished with exit code 0 代码分析： 在获取迭代器的时候，有三种获取方式 next(customer) customer.send(None) customer.next() 注意: 12345678910111213customer函数是一个generator（生成器），把一个customer传入produce后：首先调用next()启动生成器；然后，一旦生产了东西，通过customer.send(n)切换到consumer执行；customer通过yield拿到消息，处理，又通过yield把结果传回；produce拿到customer处理的结果，继续生产下一条消息；produce决定不生产了，通过c.close()关闭consumer，整个过程结束。整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。 重点：区分next()和send()的区别 其实next()和send()在一定意义上作用是相似的，区别是send()可以传递yield表达式的值进去，而next()不能传递特定的值，只能传递None进去。因此，我们可以看做next() 和 send(None) 作用是一样的。需要提醒的是，第一次调用时，请使用next()语句或是send(None)，不能使用send发送一个非None的值，否则会直接报错 aiohttp官方文档 aiohttp是什么，官网上有这样一句话介绍：Async HTTP client/server for asyncio and Python，是异步的HTTP框架 安装 1pip install aiohttp 爬取豆瓣电影资源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import aiohttpimport jsonimport asynciofrom pymongo import MongoClientclass DouBan(object): def __init__(self): self.tag_url = &apos;https://movie.douban.com/j/search_tags?type=movie&amp;source=&apos; self.bash_url = &apos;https://movie.douban.com/j/search_subjects?type=movie&amp;tag=&#123;tag&#125;&amp;sort=recommend&amp;page_limit=20&amp;page_start=&#123;page_start&#125;&apos; self.tag_key = [] self.max_page = 10 client = MongoClient(host=&apos;127.0.0.1&apos;, port=27017) db = client[&apos;unsplash&apos;] self.collection = db[&apos;images&apos;] async def get_img_info(self): async with aiohttp.ClientSession() as session: # 获取电影分类的信息 async with session.get(self.tag_url) as tag_rsponse: self.tag_key = self.parse_tag(await tag_rsponse.text()) print(self.tag_key) # 循环去获取网页api内容信息 for key in self.tag_key: for page in range(0, self.max_page): async with session.get(self.bash_url.format(tag=key, page_start=page*20)) as response: await self.parse(await response.text()) def parse_tag(self, response): json_data = json.loads(response)[&apos;tags&apos;] return json_data async def parse(self,response): json_data = json.loads(response)[&apos;subjects&apos;] for data in json_data: await self.do_insert(data) async def do_insert(self, document): try: result = self.collection.insert_one(document) except BaseException as e: print(&apos;error%s&apos; % e) else: print(&apos;result %s&apos; % repr(result.inserted_id)) def run(self): loop = asyncio.get_event_loop() tasks = [self.get_img_info()] loop.run_until_complete(asyncio.wait(tasks))if __name__ == &apos;__main__&apos;: us = DouBan() us.run() 6、数据持久化1.Redis介绍Redis是REmote DIctionary Server的缩写，它是一个用ANSI C编写的高性能的key-value存储系统，与其他的key-value存储系统相比，Redis有以下一些特点（也是优点）： 的Redis的读写性能极高，并且有丰富的特性（发布/订阅，事务，通知等）。 Redis的支持数据的持久化（RDB和AOF两种方式），可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis的不仅仅支持简单的键 - 值类型的数据，同时还提供哈希，列表，设置，zset，hyperloglog，地理等数据类型。 Redis的支持主从复制（实现读写分析）以及哨兵模式（监控主是否宕机并调整配置）。 Redis的在CentOS的中的安装配置已经上章文章中已经整理好了，如需查看自行跳转过去查看，地址 .Redis有着非常丰富的数据类型，也有很多的命令来操作这些数据，具体的内容可以查看Redis的命令参考，在这个网站上，除了Redis的的命令参考，还有Redis的的详细文档，其中包括了通知，事务，主从复制，持久化，哨兵，集群等内容。 在Python程序中使用Redis 可以使用画中画安装Redis的模块.redis模块的核心是名为Redis的的类，该类的对象代表一个Redis的客户端，通过该客户端可以向Redis的服务器发送命令并获取执行的结果。我们在Redis的客户端中使用的命令基本上就是Redis的对象可以接收的消息。 首先：安装的Redis 1pip3 install redis 简单案例 该案例：用户在登录的时候，先验证传入的用户名和密码是否在Redis的中，是否能验证通过，如果不能验证通过的话，就去MySQL的数据库中验证，如果验证成功则同步的Redis中用户的信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding:utf-8 -*-import sysimport pymysqlimport redis# 访问mysql数据库def con_mysql(sql): db = pymysql.connect( host=&apos;127.0.0.1&apos;, user=&apos;root&apos;, passwd=&apos;123456&apos;, port=3306, db=&apos;srs&apos;, charset=&apos;utf8&apos;) cursor = db.cursor() cursor.execute(sql) data = cursor.fetchall() db.close() return datadef con_redis() r = redis.Redis(host=&apos;47.92.164.198&apos;, port=6379) return rdef excute_redis(r, passwd, name): r_name = r.hget(&apos;user&apos;,&apos;name&apos;) r_passwd = r.hget(&apos;user&apos;, &apos;passwd&apos;) r_name = r_name.decode(&apos;utf8&apos;) r_passwd = r_passwd.decode(&apos;utf8&apos;) if name == r_name and passwd == r_passwd: return True, &apos;登录成功&apos; else: return False, &apos;登录失败&apos;if __name__ == &apos;__main__&apos;: # 获取传入的姓名和密码参数 if len(sys.argv): name = sys.argv[1] passwd = sys.argv[2] # 传入redis中，进行校验 r = con_redis() result = excute_redis(r, passwd, name) if not result[0]: # 查询mysql数据库 sql = &apos;&apos;&apos;select * from stu where name=&quot;%s&quot; and passwd=&quot;%s&quot;&apos;&apos;&apos; % (name, passwd) print(sql) data = con_mysql(sql) if data: r = con_redis() # r = redis.Redis(host=&apos;47.92.164.198&apos;, port=6379) r.hset(&apos;user&apos;, &apos;name&apos;, name) r.hset(&apos;user&apos;, &apos;passwd&apos;, passwd) print(&apos;刷新redis，登录成功&apos;) else: print(&apos;用户名和密码错误&apos;) else: print(&apos;redis中数据正确，登录成功&apos;) 2. mongodb介绍MongoDB的是2009年年问世的一个面向文档的数据库管理系统，由C ++语言编写，旨在为网络应用提供可扩展的高性能数据存储解决方案。虽然在划分类别的时候后，MongoDB的被认为是的NoSQL的产品，但是它更像一个介于关系数据库和非关系数据库之间的产品，在非关系数据库中它功能最丰富，最像关系数据库。 MongoDB的将数据存储为一个文档，一个文档由一系列的“键值对”组成，其文档类似于JSON对象，但是MongoDB的对JSON进行了二进制处理（能够更快的定位键和值），因此其文档的存储格式称为BSON。关于JSON和BSON的差别大家可以看看MongoDB官方网站的文章“JSON和BSON”。 目前，MongoDB中已经提供了对Windows中的MacOS，Linux和Solaris等多个平台的支持，而且也提供了多种开发语言的驱动程序，Python的当然是其中之一。 MongoDB中安装的配置以及语法操作都整理好了，可以自行前往回顾，熟悉语法。 在python中操作mongodb 通过PIP安装pymongo来实现对MongoDB中的操作。 1pip install pymongo 简单的访问蒙戈，并打印文档中的信息 1234567from pymongo import MongoClientclient = MongoClient(&apos;mongodb://45.76.206.145:27017&apos;)db = client.spiderfor student in db.students.find(): print(student) 7、动态解析根据权威机构发布的全球互联网可访问性审计报告，全球约有四分之三的网站其内容或部分内容是通过JavaScript动态生成的，这就意味着在浏览器窗口中“查看网页源代码”时无法在HTML代码中找到这些内容，也就是说我们之前用的抓取数据的方式无法正常运转了。解决这样的问题基本上有两种方案： 一是JavaScript逆向工程； 另一种是渲染JavaScript获得渲染后的内容。 JavaScript逆向工程我们以豆瓣电影为例，说明什么是JavaScript逆向工程。其实所谓的JavaScript逆向工程就是找到通过Ajax请求动态获取数据的接口。 但是当我们在浏览器中通过右键菜单“显示网页源代码”的时候，居然惊奇的发现页面的HTML代码中连一个电影的名称都搜索不到。 那网页中的数据到底是怎么加载出来的呢，其实网页中的数据就是一个动态加载出来的。可以在浏览器的“开发人员工具”的“网络”中可以找到获取这些图片数据的网络API接口，如下图所示。 那么结论就很简单了，只要我们找到了这些网络API接口，那么就能通过这些接口获取到数据，当然实际开发的时候可能还要对这些接口的参数以及接口返回的数据进行分析，了解每个参数的意义以及返回的JSON数据的格式，这样才能在我们的爬虫中使用这些数据。 selenium自动框架使用自动化测试工具Selenium，它提供了浏览器自动化的API接口，这样就可以通过操控浏览器来获取动态内容。首先可以使用pip来安装Selenium。 安装1pip install selenium 使用我们通过Selenium实现对Chrome浏览器的操控，如果要操控其他的浏览器，可以创对应的浏览器对象，例如Chrome、Firefox、Edge等，还有手机端的浏览器Android、BlackBerry等，另外无界面浏览器PhantomJS也同样支持。 1234567from selenium import webdriverbrowser = webdriver.Firefox()browser = webdriver.Ie()browser = webdriver.Opera()browser = webdriver.Chrome()browser = webdriver.PhantomJS() 这样我们就完成了一个浏览器对象的初始化，接下来我们要做的就是调用browser对象，让其执行各个动作，就可以模拟浏览器操作了。 案例中我们使用Chrome浏览器，在模拟Chrome浏览器的时候，如果报如下的错误的话，说明你没有Chrome的驱动。接下来就是添加Chrome的驱动到我们的环境变频path中，或者在程序中指定Chrome驱动的位置 1selenium.common.exceptions.WebDriverException: Message: &apos;chromedriver&apos; executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home 驱动已经下载好了，保存地址在(spider/chromedriver_win32/)中 访问url可以用get()方法来请求一个网页，参数传入链接URL即可 获取元素在浏览器中的操作，都可以通过selenium来完成，比如填充表单，模拟点击等等。那我们在进行这些操作的时候，首先需要知道我们要填充表单的位置在哪儿，模拟点击的按钮在哪儿。那怎么去获取这些信息呢。selenium中获取元素的方法有很多。 获取单个元素 大概解释一下如下用法: find_element_by_name()是根据Name值获取 ind_element_by_id()是根据ID获取 find_element_by_xpath()是根据Xpath提取 find_element_by_css_selector(‘#xxx’)是根据id=xxx来获取 find_element()方法，它需要传入两个参数，一个是查找的方式By，另一个就是值，实际上它就是find_element_by_id()这种方法的通用函数版本。 注意： from selenium.webdriver.common.by import By 12345find_element_by_id(id)就等价于find_element(By.ID, id)find_element_by_css_selector(&apos;#xxx&apos;)等价于find_elements(By.CSS_SELECTOR, &apos;.service-bd li&apos;) 获取多个元素 find_elements_by_css_selector(‘#xxx li’)是根据id=xxx来获取下面的所有li的结果 查找淘宝导航条的所有条目案例代码： 123456789101112from selenium import webdriverchromedriver = &apos;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver&apos;browser = webdriver.Chrome(chromedriver)browser.get(&apos;https://www.taobao.com&apos;)lis = browser.find_elements_by_css_selector(&apos;.service-bd li a&apos;)for li in lis: # 获取文本信息 print(li.text) # 获取属性 print(li.get_attribute(&apos;href&apos;))browser.close() 延时等待在Selenium中，get()方法会在网页框架加载结束之后就结束执行，此时如果获取page_source可能并不是浏览器完全加载完成的页面，如果某些页面有额外的Ajax请求，我们在网页源代码中也不一定能成功获取到。所以这里我们需要延时等待一定时间确保元素已经加载出来。在这里等待的方式有两种，一种隐式等待，一种显式等待。 以访问知乎发现页面为案例： 1234567891011from selenium import webdriverchromedriver = &apos;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver&apos;browser = webdriver.Chrome(chromedriver)# 用implicitly_wait()方法实现了隐式等待。browser.implicitly_wait(10)browser.get(&apos;https://www.zhihu.com/explore&apos;)input = browser.find_element_by_class_name(&apos;zu-top-add-question&apos;)print(input) 前进后退使用back()方法可以后退，forward()方法可以前进 123browser.back()time.sleep(1)browser.forward() Cookies操作12345678910111213141516from selenium import webdriverchromedriver = &apos;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver&apos;browser = webdriver.Chrome(chromedriver)browser.get(&apos;https://www.zhihu.com/explore&apos;)# 获取所有cookies信息print(browser.get_cookies())# 添加一个Cookie信息browser.add_cookie(&#123;&apos;name&apos;: &apos;王大帅&apos;, &apos;value&apos;: &apos;16&apos;&#125;)print(browser.get_cookies())# 删除所有的Cookiesbrowser.delete_all_cookies()print(browser.get_cookies())browser.close() 切换窗口以淘宝为例： 打开浏览器在主页中点击女装案例，再切换回主页再点击男装按钮，然后主页进行back()和froward()操作，最后退出整个浏览器quit() 12345678910111213141516171819202122232425262728293031323334353637383940import timefrom selenium import webdriverchromedriver = &apos;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver&apos;browser = webdriver.Chrome(chromedriver)# 隐式延迟browser.implicitly_wait(20)browser.get(&apos;https://www.taobao.com&apos;)# 获取主窗口taobao_handler = browser.current_window_handle# 点击导航栏女装按钮browser.find_element_by_xpath(&apos;/html/body/div[4]/div[1]/div[1]/div[1]/div/ul/li[1]/a[1]&apos;).click()time.sleep(3)# 获取当前窗口text_browser_handler_nv = browser.current_window_handle# 切换窗口继续点击男装案例browser.switch_to_window(taobao_handler)# # 点击导航栏男装按钮browser.find_element_by_xpath(&apos;/html/body/div[4]/div[1]/div[1]/div[1]/div/ul/li[1]/a[2]&apos;).click()time.sleep(3)# 后退browser.back()time.sleep(3)# 前进browser.forward()# 关闭浏览器browser.quit() 获取一共启动了多少窗口： 1browser.window_handles 8、scrapy框架Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。 其最初是为了 页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据或者通用的网络爬虫。 Scrapy 使用了 Twisted异步网络库来处理网络通讯。整体架构大致如下: 中文官网 初窥Scrapy1. 安装1pip install Scrapy 安装过程中会安装如下一些包，在之前的安装过程中，偶尔会出现Twisted失败的话，需要自己手动去安装。 在此也先安装另外一个必备的包pywin32，如果不安装该包的话，在运行爬虫的时候可能会提示“ModuleNotFoundError: No module named ‘win32api’”，因为Python没有自带访问windows系统API的库的，需要下载第三方库。库的名称叫pywin32。可以去网站上下载，下载地址 按照自己电脑上的python版本，进行下载安装。安装的时候，先进入虚拟环境中，然后执行easy_install pywin32-221.win-amd64-py3.6.exe 命令即可将包安装在我们当前的虚拟环境中了。 2. Scrapy组件1. 引擎(Scrapy)用来处理整个系统的数据流处理, 触发事务(框架核心) 2. 调度器(Scheduler)用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列,由它来决定下一个要抓取的网址是什么, 同时去除重复的网址 3. 下载器(Downloader)用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的) 4. 爬虫(Spiders)爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面 5. 项目管道(Pipeline)负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。 6. 下载器中间件(Downloader Middlewares)位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。 7. 爬虫中间件(Spider Middlewares)介于Scrapy引擎和爬虫之间的框架，主要工作是处理蜘蛛的响应输入和请求输出。 8. 调度中间件(Scheduler Middewares)介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。 3. 处理流程Scrapy的整个数据处理流程由Scrapy引擎进行控制，通常的运转流程包括以下的步骤： 引擎询问蜘蛛需要处理哪个网站，并让蜘蛛将第一个需要处理的URL交给它。 引擎让调度器将需要处理的URL放在队列中。 引擎从调度那获取接下来进行爬取的页面。 调度将下一个爬取的URL返回给引擎，引擎将它通过下载中间件发送到下载器。 当网页被下载器下载完成以后，响应内容通过下载中间件被发送到引擎；如果下载失败了，引擎会通知调度器记录这个URL，待会再重新下载。 引擎收到下载器的响应并将它通过蜘蛛中间件发送到蜘蛛进行处理。 蜘蛛处理响应并返回爬取到的数据条目，此外还要将需要跟进的新的URL发送给引擎。 引擎将抓取到的数据条目送入条目管道，把新的URL发送给调度器放入队列中。 上述操作中的2-8步会一直重复直到调度器中没有需要请求的URL，爬虫停止工作。 4. Scrapy项目在创建项目开始，我们先确认一下之前安装的scrapy能否正常运行，如下情况即安装成功： 4.1 创建项目1scrapy startproject dbspider 创建成功以后，在我们的文件夹中会发现一个dbspider的目录，这个项目文件就是我们的爬虫项目了。可以先看看它的构成，接下来详细讲解一下每一个文件代表的意思。 4.2 文件解释文件说明： scrapy.cfg:项目的配置信息，主要为Scrapy命令行工具提供一个基础的配置信息。（真正爬虫相关的配置信息在settings.py文件中） items.py:设置数据存储模板，用于结构化数据，如：Django的Model pipelines:数据处理行为，如：一般结构化的数据持久化 settings.py:配置文件，如：递归的层数、并发数，延迟下载等 spiders:爬虫目录，如：创建文件，编写爬虫规则。 在spiders文件中创建爬虫的时候，一般以爬取的网站的域名为爬虫的名称 5. 编写爬虫爬取起点中文网的网页源码,爬取小说分类名称以及url 案例代码： 12import scrapyfrom scrapy.selector import Selector class QiDianSpider(scrapy.spiders.Spider): name = “qidian” start_urls = [ “https://www.qidian.com/“, ] 1234567891011121314151617def parse(self, response): # 爬取时请求的url current_url = response.url # 返回的html body = response.body # 返回的html unicode编码 unicode_body = response.body_as_unicode() res = Selector(response) # 获取小说的分类信息 xiaoshuo_type = res.xpath(&apos;//*[@id=&quot;pin-nav&quot;]/div/div[1]/ul/li/a/text()&apos;).extract() xiaoshuo_href = res.xpath(&apos;//*[@id=&quot;pin-nav&quot;]/div/div[1]/ul/li/a/@href&apos;).extract() print(xiaoshuo_type, xiaoshuo_href) 5.1 运行命令：1scrapy crawl qidian 启动命令中 ‘qidian’参数为我们定义爬虫中的name属性的值 执行流程： name: spider对应不同的name start_urls:是spider抓取网页的起始点，可以包括多个url。 parse()：spider抓到一个网页以后默认调用的callback，避免使用这个名字来定义自己的方法。当spider拿到url的内容以后，会调用parse方法，并且传递一个response参数给它，response包含了抓到的网页的内容，在parse方法里，你可以从抓到的网页里面解析数据。 运行结果： 9、分布式爬虫说到分布式系统的时候，要和集中式系统进行对比的学习，下面就先介绍下集中式系统，对比它们的优缺点进行学习。 集中式系统集中式系统： 集中式系统中整个项目就是一个独立的应用，整个应用也就是整个项目，所有的业务逻辑功能都在一个应用里面。如果遇到并发的瓶颈的时候，就多增加几台服务器来部署项目，以此来解决并发分问题。在nginx中进行负载均衡即可。 缺点： a) 不易于扩展 b) 如果发现你的项目代码中有bug的话，那么你的所有的服务器中的项目代码都是有问题的，这时候要更新这个bug的时候，就需要同时更新所有的服务器了。 优点： 维护方便 分布式系统分布式系统: 分布式系统中，我们的整个项目可以拆分成很多业务块，每一个业务块单独进行集群的部署。这样就将整个项目分开了，在进行拓展的时候，系统是很容易横向拓展的。在并发的时候，也很好的将用户的并发量提上去。 缺点： a) 项目拆分的过于复杂，给运维带来了很高的维护成本 b) 数据的一致性，分布式事务，分布式锁等问题不能得到很好的解决 优点： a) 一个业务模块崩了，并不影响其他的业务 b) 利于扩展 c) 在上线某个新功能的时候，只需要新增对应的分布式的节点即可，测试也只需要测试该业务功能即可。很好的避免了测试在上线之前需要将整个系统进行全方面的测试 1. scrapy的分布式原理我们还是先回顾下scrapy的运行原理的构造图: 该图很好的阐释了在不是scrapy的服务器中的运行结构图，在维护爬取的url队列的时候，使用scheduler进行调度的。那么如果要修改为分布式的scrapy爬虫的话，其实就是将爬取的队列进行共享，多台部署了scrapy爬虫的服务器共享该爬取队列。 2. 分布式架构： master-主机：维护爬虫队列。 slave-从机：数据爬取，数据处理，数据存储。 3. 搭建分布式爬虫我们使用scrapy_redis进行分布式爬虫的搭建。 scrapy_redis是scrapy框架下的一个插件，通过重构调度器来使我们的爬虫运行的更快 3.1 安装安装scrapy_redis： 1pip install scrapy_redis 安装redis： 123# redis可以仅在master主机上安装pip install redis 安装数据存储数据库，采用mongodb 见: 安装配置地址 3.2 redis在维护爬虫队列的时候，很多爬虫项目同时读取队列中的信息，就造成了可能读数据重复了，比如同时读取同一个url。为了避免这种情况，我们建议使用redis去维护队列。而且redis的集合中的元素还不是重复的，可以很好的利用这一点，进行url爬取地址的存储 3.3 分布式爬虫改造3.3.1 mastermaster主机改造： 在master主机上安装redis并启动，最好设置密码 spiders文件中定义的爬虫py文件修改如下：如下爬虫实现的功能是拿到需要爬取的成都各大区县的二手房页面url地址，包括分页的地址。并将数据存储到redis中 123456789101112131415161718192021222324252627282930313233343536373839404142import jsonfrom scrapy import Requestfrom scrapy.spiders import Spiderfrom scrapy.selector import Selectorfrom lianjiaspider.items import LianjiaspiderItem, MasterItemclass LianJiaSpider(Spider): name = &apos;lianjia&apos; # allowed_domains = [&apos;lianjia.com&apos;] domains_url = &apos;https://cd.lianjia.com&apos; start_linjia_url = &apos;https://cd.lianjia.com/ershoufang&apos; def start_requests(self): yield Request(self.start_linjia_url) def parse(self, response): sel = Selector(response) ershoufang_aera = sel.xpath(&apos;//div[@data-role=&quot;ershoufang&quot;]&apos;) area_info = ershoufang_aera.xpath(&apos;./div/a&apos;) for area in area_info: area_href = area.xpath(&apos;./@href&apos;).extract()[0] area_name = area.xpath(&apos;./text()&apos;).extract()[0] yield Request(self.domains_url + area_href, callback=self.parse_house_info, meta=&#123;&apos;name&apos;: area_name, &apos;href&apos;: area_href&#125;) def parse_house_info(self, response): sel = Selector(response) page_box = sel.xpath(&apos;//div[@class=&quot;page-box house-lst-page-box&quot;]/@page-data&apos;).extract() total_page = json.loads(page_box[0]).get(&apos;totalPage&apos;) for i in range(1, int(total_page)+1): item = MasterItem() item[&apos;url&apos;] = self.domains_url + response.meta.get(&apos;href&apos;) + &apos;pg&apos; + str(i) yield item 定义Item接收一个地址url参数： 12class MasterItem(scrapy.Item): url = scrapy.Field() 新增redis存储中间件123456789class MasterPipeline(object): def __init__(self): # 链接redis self.r = redis.Redis(host=&apos;127.0.0.1&apos;, port=6379) def process_item(self, item, spider): # 向redis中插入需要爬取的链接地址 self.r.lpush(&apos;lianjia:start_urls&apos;, item[&apos;url&apos;]) 3.3.2 slave改造：slave从机改造：slave从机访问redis，直接去访问master主机上的redis的地址，以及端口密码等信息 spiders爬虫文件改造继承改为继承Redisspider 1from scrapy_redis.spiders import RedisSpider 具体代码优化如下： 123456789101112131415161718192021222324252627282930313233343536from scrapy_redis.spiders import RedisSpiderfrom scrapy.selector import Selectorfrom lianjiaspider.items import LianjiaspiderItemclass LianJiaSpider(RedisSpider): name = &apos;lianjia&apos; # 指定访问redis的爬取urls的队列 redis_key = &apos;lianjia:start_urls&apos; def parse(self, response): sel = Selector(response) lis = sel.xpath(&apos;//html/body/div[4]/div[1]/ul/li[@class=&quot;clear&quot;]&apos;) for li in lis: item = LianjiaspiderItem() item[&apos;house_code&apos;] = li.xpath(&apos;./a/@data-housecode&apos;).extract()[0] if li.xpath(&apos;./a/img/@src&apos;).extract(): item[&apos;img_src&apos;] = li.xpath(&apos;./a/img/@src&apos;).extract()[0] if li.xpath(&apos;./div/div/a/text()&apos;).extract(): item[&apos;title&apos;] = li.xpath(&apos;./div/div/a/text()&apos;).extract()[0] item[&apos;address&apos;] = li.xpath(&apos;./div/div[2]/div/a/text()&apos;).extract() item[&apos;info&apos;] = li.xpath(&apos;./div/div[2]/div/text()&apos;).extract() item[&apos;flood&apos;] = li.xpath(&apos;./div/div[3]/div/text()&apos;).extract() item[&apos;tag&apos;] = li.xpath(&apos;.//div[@class=&quot;tag&quot;]/span/text()&apos;).extract() item[&apos;type&apos;] = &apos;ershoufang&apos; item[&apos;city&apos;] = &apos;成都&apos; yield item def split_house_info(self, info): return [i.strip() for i in info.split(&apos;|&apos;)[1:]] settings.py配置改造新增如下的配置： 12345678910111213141516171819202122232425262728# scrapy-redisREDIS_URL = &apos;redis://:yzd@127.0.0.1:6379&apos; # for master# REDIS_URL = &apos;redis://:yzd@10.140.0.2:6379&apos; # for slave (master&apos;s ip)# SCHEDULER 是任务分发与调度，把所有的爬虫开始的请求都放在redis里面，所有爬虫都去redis里面读取请求。SCHEDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;# 如果这一项设为True，那么在Redis中的URL队列不会被清理掉，但是在分布式爬虫共享URL时，要防止重复爬取。如果设为False，那么每一次读取URL后都会将其删掉，但弊端是爬虫暂停后重新启动，他会重新开始爬取。 SCHEDULER_PERSIST = True# REDIS_START_URLS_AS_SET指的是使用redis里面的set类型（简单完成去重），如果你没有设置，默认会选用list。REDIS_START_URLS_AS_SET = True# DUPEFILTER_CLASS 是去重队列，负责所有请求的去重DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;# 爬虫的请求调度算法，有三种可供选择# scrapy_redis.queue.SpiderQueue：队列。先入先出队列，先放入Redis的请求优先爬取；# scrapy_redis.queue.SpiderStack：栈。后放入Redis的请求会优先爬取；# scrapy_redis.queue.SpiderPriorityQueue：优先级队列。根据优先级算法计算哪个先爬哪个后爬SCHEDULER_QUEUE_CLASS = &quot;scrapy_redis.queue.SpiderQueue&quot;# 设置链接redis的配置，或者如下分别设置端口和IP地址REDIS_URL = &apos;redis://127.0.0.1:6379&apos;# 分布式爬虫设置Ip端口REDIS_HOST = &apos;127.0.0.1&apos;REDIS_PORT = 6379","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://shuaixiaohao.github.io/categories/数据分析/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://shuaixiaohao.github.io/tags/爬虫/"}]},{"title":"HTML","slug":"HTML学习","date":"2017-11-29T02:01:19.000Z","updated":"2018-08-05T08:36:43.383Z","comments":true,"path":"2017/11/29/HTML学习/","link":"","permalink":"https://shuaixiaohao.github.io/2017/11/29/HTML学习/","excerpt":"什么是HTML?HTML 是用来描述网页的一种语言。 Tag: Content 装内容装数据 CSS: Display 渲染,显示 JavaScript: Behavior 交互,行为","text":"什么是HTML?HTML 是用来描述网页的一种语言。 Tag: Content 装内容装数据 CSS: Display 渲染,显示 JavaScript: Behavior 交互,行为 HTML 指的是超文本标记语言: Hyper Text Markup Language HTML 不是一种编程语言，而是一种标记语言 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML 文档包含了HTML 标签及文本 内容 HTML文档也叫做web 页面 HTML格式1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;主题title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 解析&lt;!DOCTYPE html&gt; 声明为 HTML5 文档 元素是 HTML 页面的根元素 元素包含了文档的元（meta）数据 元素描述了文档的标题 元素包含了可见的页面内容 元素定义一个大标题 元素定义一个段落 水平分割线 折行符 \\ 下标标签 \\ 上标标签 \\ 强调标签,变粗 \\ 强调标签,斜体 列表无序列表12345&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt; &lt;li&gt;芒果&lt;/li&gt;&lt;/ul&gt; 浏览器显示: 苹果 草莓 芒果 有序列表12345&lt;ol&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt; &lt;li&gt;芒果&lt;/li&gt;&lt;/ol&gt; 浏览器显示: 苹果 草莓 芒果 自定义列表 标签定义一个描述列表。 标签与 （定义项目/名字）和 （描述每一个项目/名字）一起使用。 123456&lt;dl&gt; &lt;dt&gt;星期&lt;/dt&gt; &lt;dd&gt;1 2 3 4 5 6 7&lt;/dd&gt; &lt;dt&gt;月份&lt;/dt&gt; &lt;dd&gt;1 2 3 4 5 6 7 8 9 10 11 12&lt;/dd&gt; &lt;/dl&gt; 浏览器显示: 星期​ 1 2 3 4 5 6 7月份​ 1 2 3 4 5 6 7 8 9 10 11 12 链接1&lt;a href=\"url\"&gt;链接文本&lt;/a&gt; href属性描述了链接的目标。 页面链接 12345当前页面跳转,target=\"_self\"可以不写&lt;a href=\"http://www.baidu.com\" target=\"_self\"&gt;百度&lt;/a&gt;&lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt;打开新页面跳转&lt;a href=\"http://www.qq.com\" target=\"_blank\"&gt;腾讯&lt;/a&gt; 锚点链接(id属性) id属性可用于创建在一个HTML文档书签标记。 id=”tips” tips-提示部分,自己定义 123&lt;h1 id=\"top\"&gt;Hello,word!&lt;/h1&gt;&lt;a href=\"#top\"&gt;回顶部&lt;/a&gt; 功能性链接1234自动弹出发邮箱功能&lt;a href=\"mailto:fenghao1994@163.com\"&gt;联系站长&lt;/a&gt;发起消息会话,wp.qq.com网站自动生成&lt;a target=\"_blank\" href=\"http://wpa.qq.com/msgrd?v=3&amp;uin=&amp;site=qq&amp;menu=yes\"&gt;&lt;img border=\"0\" src=\"http://wpa.qq.com/pa?p=2::52\" alt=\"联系客服\" title=\"联系客服\"/&gt;&lt;/a&gt; 图像定义图像的语法是: 1&lt;img src=\"url\" alt=\"som_text\" &gt; src 指 “source”。源属性的值是图像的 URL 地址,或图片的相对路径。 alt 为图像定义一串预备的可替换的文本。在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。 height（高度） 与 width（宽度）属性用于设置图像的高度与宽度，属性值默认单位为像素，也可以不设置。 1&lt;img src=\"./mm.jpg\" alt=\"这是一个女的\" width=\"300\" height=\"500\"&gt; 表格1234567891011121314151617181920212223&lt;table border=\"1\"&gt; &lt;caption&gt;个人信息统计&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;身高&lt;/th&gt; th&lt;th&gt;体重&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;王大锤&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td colspan=\"2\" align=\"center\"&gt;170&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=\"..jpg\" width=\"60\" height=\"20\"&gt; &lt;div&gt;李小刀&lt;/div&gt; &lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;180&lt;/td&gt; &lt;td&gt;58&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;caption&gt; 定义表格标题 &lt;th&gt; 定义表格的表头 &lt;tr&gt; 定义表格的行 &lt;td&gt; 定义表格单元 align=&quot;center&quot; 居中 colspan=&quot;&quot; 合并 音频1234&lt;audio controls&gt; &lt;source src=\"horse.ogg\"&gt; &lt;source src=\"horse.mp3\"&gt;&lt;/audio&gt; controls 属性供添加播放、暂停和音量控件；可以换成autoplay 自动播放；autoplay loop自动循环播放。 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件 视频1234&lt;video width=\"320\" height=\"240\" controls&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"movie.ogg\" type=\"video/ogg\"&gt;&lt;/video&gt; controls 元素提供了 播放、暂停和音量控件来控制视频。 width 和 height 属性控制视频的尺寸.尽量不要写 区块区块元素 大多数 HTML 元素被定义为块级元素或内联元素。 块级元素在浏览器显示时，通常会以新行来开始（和结束）。 实例: , , , , 内联元素 内联元素在显示时通常不会以新行开始。 实例: , , , 元素 元素是块级元素，它可用于组合其他 HTML 元素的容器。 元素 元素是内联元素，可用作文本的容器 表单 表单用于收集不同类型的用户输入。表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。表单使用表单标签 \\ 来设置 输入元素多数情况下被用到的表单标签是输入标签（）。 输入类型是由类型属性（type）定义的。 文本域（Text Fields）文本域通过 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。 123456789101112131415161718&lt;form action=\"\" method=\"post\" enctype=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;必填信息&lt;/legend&gt; &lt;p&gt; &lt;label&gt;用户名: &lt;/label&gt; &lt;input type=\"text\" name=\"uid\" placeholder=\"请输入用户名\" required&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;密码 &lt;/label&gt; &lt;input type=\"password\" name=\"pwd\"&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;性别: &lt;/label&gt; &lt;input type=\"radio\" name=\"sex\"&gt;男 &lt;input type=\"radio\" name=\"sex\" checked&gt;女 &lt;/p&gt; &lt;/fieldset&gt;&lt;/form&gt; action “”里面是要提交的地址 method 规定如何发送表单数据（表单数据发送到 action属性所规定的页面）。共有两种方法：post 方法和 get 方法 – get get是从服务器上获取数据 get是把参数数据队列加到提交表单的action属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到 get传送的数据量较小。 get安全性非常低。 – post post是向服务器传送数据 post是通过HTTP post机制,将表单内各个字段与其内容放置在HTML HEADER内一起传送到action属性所指的URL地址。用户看不到这个过程。 post传送的数据量较大，一般被默认为不受限制。 post安全性较高。 enctype 属性规定在将表单数据发送到服务器之前如何对其进行编码。 注意：只有 method=”post” 时才使用 enctype 属性。 &lt;fieldset&gt;&lt;/fieldset&gt; 定义了一组相关的表单元素，并使用外框包含起来 &lt;legend&gt;&lt;/legend&gt; 定义了 \\ 元素的标题 &lt;label&gt; 定义了 \\ 元素的标签，一般为输入标题 &lt;input&gt; 输入标签输入类型是由类型属性（type）定义的。 name 属性规定表单的名称,用于在 JavaScript 中引用元素，或者在表单提交之后引用表单数据。 placeholder 属性规定可描述输入字段预期值的简短的提示信息,该提示会在用户输入值之前显示在输入字段中。 注意：placeholder 属性适用于下面的 input 类型：text、search、url、tel、email 和 password。 required 属性是一个布尔属性,规定必需在提交表单之前填写输入字段。 注意：required 属性适用于下面的 input 类型：text、search、url、tel、email、password、date pickers、number、checkbox、radio 和 file。 密码字段密码字段通过标签 来定义 单选按钮&lt;input type=&quot;radio&quot;&gt; 标签定义了表单单选框选项 checked选框默认选项 复选框 定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项 123456&lt;label&gt;爱好: &lt;/label&gt;&lt;input type=\"checkbox\" name=\"fav\"&gt;游戏&lt;input type=\"checkbox\" name=\"fav\" checked&gt;阅读&lt;input type=\"checkbox\" name=\"fav\" checked disabled&gt;旅游&lt;input type=\"checkbox\" name=\"fav\"&gt;运动&lt;input type=\"checkbox\" name=\"fav\"&gt;其他 checked disabled 默认必选项,不能取消. 文件上传1&lt;input type=\"file\" name=\"photo1\" multiple&gt; multiple 可接受多个值的文件上传字段 日期1&lt;input type=\"date\" name=\"b\"&gt; 下拉列表选项定义了下拉选项列表 定义下拉列表中的选项 12345678&lt;label&gt;籍贯: &lt;/label&gt;&lt;select&gt;name=\"prov\" &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option selected&gt;四川&lt;/option&gt; &lt;option&gt;云南&lt;/option&gt; &lt;option&gt;海南&lt;/option&gt;&lt;/select&gt; selected 默认选项 多行文本框 标签定义一个多行的文本输入控件。文本区域中可容纳无限数量的文本，其中的文本的默认字体是等宽字体（通常是 Courier）。可以通过 cols 和 rows 属性来规定 textarea 的尺寸大小 字符实体12345678910111213141516 空格 &amp;nbsp;&lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt;&amp; 和号 &amp;amp;&quot; 引号 &amp;quot;&apos; 撇号 &amp;apos; (IE不支持)￠ 分 &amp;cent;£ 镑 &amp;pound; ¥ 人民币/日元 € 欧元 &amp;euro;§ 小节 &amp;sect;× 乘号 &amp;times; ÷ 除号 &amp;divide;© 版权 &amp;copy;® 注册商标 &amp;reg;™ 商标 &amp;trade; CSS什么是 CSS? CSS 指层叠样式表 (Cascading Style Sheets) 样式定义如何显示 HTML 元素 样式通常存储在样式表中 把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题 外部样式表可以极大提高工作效率 外部样式表通常存储在 CSS 文件中 多个样式定义可层叠为一 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明，声明总是以分号(;)结束，声明组以大括号({})括起来 就近原则 具体性原则 id选择器&gt;类选择器&gt;标签选择器&gt;通配符选择器 重要性原则 盒子模型 1content（内容） - padding（内边距） - border（边框） - background-image（背景图片） - background-color（背景颜色） - margin（外边距） 边框和轮廓border 设置对象边框的特性 border-collapse : collapse 设置表格的边框合并为一个单一的边框 border-color 设置或检索对象的边框颜色 outline 设置或检索对象外的线条轮廓。 字体font-size 设置字体属性 font-family 规定文本的字体系列 font-style 规定文本的字体尺寸 font-weight 规定字体的粗细 文本color 指定文本的颜色 line-height 设置行高 text-align 规定文本的水平对齐方式 text-decoration 规定添加到文本的装饰效果，：none取消下划线 内边距padding 简写属性在一个声明中设置所有填充属性。该属性可以有1到4个值 padding-bottom 设置元素的底填充padding-left 设置元素的左填充padding-right 设置元素的右填充padding-top 设置元素的顶部填充 背景div是不支持background-color 的，background-color是table等的属性，你要用background：#（这里是颜色代码）；这样来写 background 复合属性，设置对象的背景特性 background-color 设置或检索对象的背景颜色background-image 设置或检索对象的背景图像 外边距margin 在一个声明中设置所有外边距属性，该属性可以有1到4个值 display属性display：none 此元素不会被显示。 display：block 此元素将显示为块级元素，此元素前后会带有换行符。 display：inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 hidden 元素是不可见的。 列表list-style 在一个声明中设置所有的列表属性list-style-position 设置列表项标记的放置位置 定位position:static; 正常文档流 position:relative; 相对定位 相对于元素原来的位置定位没有脱离文档流,对兄弟元素没有影响 position:absolute; 绝对定位(相对于父元素来设置位置 脱离了文档流 position:fixd； 固定定位（相对于浏览器窗口摆放） z-index 属性指定一个元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 float：left 元素向左浮动。 float：right 元素向右浮动。 黑科技 overflow: auto; 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 overflow: hidden 兄弟选择器 ~ 相邻兄弟选择器 + 12345安装字体@font-face &#123; font-family: '给字体起个名 '; src: url(路径);&#125; JavaScript​ ECMAScript - 语法规范 - ES5 (ECMA欧洲计算机制造商协会) ​ BOM - Browser Object Model - 浏览器对象模型 - window ​ DOM - Document Object Model - 文档对象模型 - document 编程范式(理念) 面向对象编程 函数式编程 层叠样式表前置, JS后置 外部脚本不能包含 \\ 标签。 document.getElementById(“some id”) 。这个方法是 HTML DOM 中定义的, 是用于访问 HTML 元素的正式 W3C 标准x.innerHTML=”Hello JavaScript”; //改变内容 输出JavaScript 显示数据 JavaScript 可以通过不同的方式来输出数据： 使用 window.alert() 弹出警告框。 alert() 方法用于显示带有一条指定消息和一个 确认 按钮的警告框。 使用 document.write() 方法将内容写到 HTML 文档中。 使用 innerHTML 写入到 HTML 元素。 使用 console.log() 写入到浏览器的控制台。 操作 HTML 元素 如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(id) 方法。 请使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容： 语法JavaScript 使用关键字 var 来定义变量， 使用等号来为变量赋值 JavaScript 对大小写是敏感的 分号用于分隔 JavaScript 语句。通常我们在每条可执行的语句结尾添加分号。使用分号的另一用处是在一行中编写多条语句。 在文本字符串中使用反斜杠对代码行进行换行 注释单行注释以 // 开头 多行注释以 / 开始，以 / 结尾 数据类型和变量简单数据类型:字符串（String） 、数字(Number) 、布尔(Boolean) 、数组(Array) 、 空（Null） 、未定义（Undefined） 复杂数据类型: 对象(Object) 当声明新变量时，可以使用关键词 “new” 来声明其类型： JavaScript中有隐式的类型转换 ==比较，它会自动转换数据类型再比较 ===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 ===(全等于/严格等) !==(严格不等) 逻辑运算符: &amp;&amp;(短路与) 只有所有都为true，&amp;&amp;运算结果才是true，第一个为false后面的不再判断 ||(短路或) 只要其中有一个为true，||运算结果就是true，第一个为true后面的不再判断 ! (非) 作用域局部作用域变量在函数内声明，变量为局部作用域。 局部变量：只能在函数内部访问。 全局作用域变量在函数外定义，即为全局变量。 全局变量有 全局作用域 : 网页中所有脚本和函数均可使用。 如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。 JavaScript 变量生命周期JavaScript 变量生命周期在它声明时初始化。 局部变量在函数执行完毕后销毁。 全局变量在页面关闭后销毁。 JavaScript全局函数isNaN() - 是不是不是一个数 parseInt() - 取整数如果取不出返回NaN parseFloat() - 取小数如果取不出返回NaN isFinite() - 是不是有限数值 eval() - 非常强大的函数 evaluate - XSS(跨站脚本攻击) encodeURIComponent() - 处理成百分号编码 decodeURIComponent() - 将百分号编码解码还原 Date 对象创建 Date 对象： new Date() 方法 描述 getFullYear() 从 Date 对象以四位数字返回年份 getMonth() 从 Date 对象返回月份 (0 ~ 11) getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31) getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6) getHours() 返回 Date 对象的小时 (0 ~ 23) getMinutes() 返回 Date 对象的分钟 (0 ~ 59) getSeconds() 返回 Date 对象的秒数 (0 ~ 59) window对象alert() 浏览器弹出带有一段消息和一个确认按钮的警告框 prompt() 显示可提示用户输入的对话框 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框 open() 打开一个新的浏览器窗口或查找一个已命名的窗口 close() 关闭浏览器窗口 setTimeout() 在指定的毫秒数后调用函数或计算表达式 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式 clearTimeout() 取消由 setTimeout() 方法设置的 timeout clearInterval() 取消由 setInterval() 设置的 timeout moveTo() 把窗口的左上角移动到一个指定的坐标 moveBy() 可相对窗口的当前坐标把它移动指定的像素 resizeBy() 按照指定的像素调整窗口的大小 window对象属性location - 用于窗口或框架的 Location 对象 属性: location.href 设置或返回当前显示的文档的完整 URL 1document.write(location.href); Location 对象方法: assign() 载入一个新的文档 // window.location.assign(URL) reload() 重新载入当前文档 // location.reload(); replace() 用新的文档替换当前文档 // location.replace(newURL) history - go() / fofward / back screen = avaiwidth / avaiHeight Document 对象查找元素的方法 getElementById() 返回对拥有指定 id 的第一个对象的引用 getElementsByTagName() 返回带有指定标签名的对象集合 getElementsByClassName() 返回文档中所有指定类名的元素集合 querySelector() 根据指定的选择器查找单个元素 querySelectorAll() 根据指定的选择器查找所有元素 绑定事件与取消绑定 document.addEventListener() 方法用于向文档添加事件句柄 document.removeEventListener() 方法来移除 addEventListener() 方法添加的事件句柄 element.addEventListener() 方法为指定元素添加事件句柄 1document.addEventListener(event, function) ​ - event 必需。描述事件名称的字符串。’click’ - 当用户点击某个对象时调用的事件句柄 ​ - function 必需。描述了事件触发后执行的函数 修改节点的内容和属性 textContent / innerHTML / nodeValue 访问成员运算符 setAttribute() / getAttribute() / removeAttribute() 创建新节点 - ()追加新的子节点 - appendChild() / insertBefore()删除子节点 - removeChild() 如果已经获得一个节点 如何访问它的父节点、子节点、兄弟节点parentNodechildren / firstChild / lastChildnextSibling / prevSibling DOM事件对象鼠标事件 onmousedown 鼠标按钮被按下 target 事件属性可返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口 1event.target 事件捕获 - 从外向里传播事件 事件冒泡 - 从里向外传播事件 jQuery jQuery的$函数的作用: 1、 $(function() {}) - \\$函数中传入的参数是一个函数作用: 绑定页面加载完成之后要执行的回调函数 2、 $(selector) - \\$函数中传入的参数是一个选择器 ​ 作用: 通过选择器获得对应的元素并将其处理成jQuery对象jQuery对象本质是一个数组 ​ 如果需要将jQuery对象还原成原生的JS对象一[index]/get(index) 3、 $(elem) - \\$函数中传入的参数是原生JS对象 ​ 作用: 将原生JS对象转换成jQuery对象(更多的属性更多的方法) 4、 $(tag) - \\$函数中传入的参数是一个标签 ​ 作用: 和标签对应的元素(得到的是jQuery对身) 通过jQuery对象的方法可以用更少的代码做更多的事情 在写代码的时候不需要考虑浏览器兼容性问题(jQuery已经做了处理） 引入多个JS库出现冲突时可以通过下面的方式让出$函数 ​ jQuery.noConfict() ; 让出$函数以后原来用\\$函数的地方全部换成jQuery 查找元素 选择器 * / element / #id / .class / selector1, selector2 ancestor descendant / parent&gt;child / previous+next / previous~siblings 筛选器 基本筛选器：:not(selector) / :first / :last / :even / :odd / :eq(index) / :gt(index) / :lt(index) / :animated / :focus 内容筛选器：:contains(‘…’) / :empty / :parent / :has(selector) 可见性筛选器：:hidden / :visible 子节点筛选器：:nth-child(expr) / :first-child / :last-child / :only-child 属性筛选器：[attribute] / [attribute=’value’] / [attribute!=’value’] / [attribute^=’value’] / [attribute$=’value’] / [attribute|=’value’] / [attribute~=’value’] 表单： :input / :text / :password / :radio / :checkbox / :submit / :image / :reset / :button / :file / :selected / :enabled / :disabled / :checked 执行操作 内容操作 获取/修改内容：html() / text() / replaceWith() / remove() 获取/设置元素：before() / after() / prepend() / append() / remove() / clone() / unwrap() / detach() / empty() / add() 获取/修改属性：attr() / removeAttr() / addClass() / removeClass() / css() 获取/设置表单值：val() 查找操作 查找方法：find() / parent() / children() / siblings() / next() / nextAll() / prev() / prevAll() 筛选器：filter() / not() / has() / is() / contains() 索引编号：eq() 尺寸和位置 尺寸相关：height() / width() / innerHeight() / innerWidth() / outerWidth() / outerHeight() 位置相关：offset() / position() / scrollLeft() / scrollTop() 特效和动画 基本动画：show() / hide() / toggle() 消失出现：fadeIn() / fadeOut() / fadeTo() / fadeToggle() 滑动效果：slideDown() / slideUp() / slideToggle() 自定义：delay() / stop() / animate() 事件 文档加载：ready() / load() 用户交互：on() / off() 回调函数 evt参数代表的是事件对象 - 绑定了和事件相关的所有信息 如果事件回调函数中要用到和事件相关的属性和方法就最好指定evt参数 target / clientX / button / keyCode preventDefault() / stopPropagation() 不管函数是否指定了evt参数当事件发生回调该函数时都会传入该参数 调构造函数 前面加new 数组里删元素要从后往前循环 Ajax原生Ajax - Asynchronous JavaScript and XML 让浏览器向服务器发出异步请求(非阻塞式请求)，等服务器返回了响应数据(JSON/XML)后就可以对页面进行局部刷 新，这样就可以在不中断用户体验的前提下刷新页面数据 JavaScript发送HTTP请求获取数据默认只支持同源数据(同源策略) http://www.abc.com/index.html -&gt; JavaScript 如果要跨域取数据是需要对方提供数据的服务器支持的 JSONP / 服务器端设置支持跨域取数据(RESTful)","categories":[{"name":"HTML","slug":"HTML","permalink":"https://shuaixiaohao.github.io/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://shuaixiaohao.github.io/tags/HTML/"}]},{"title":"通讯录","slug":"通讯录","date":"2017-11-15T10:29:31.000Z","updated":"2018-06-27T15:38:02.250Z","comments":true,"path":"2017/11/15/通讯录/","link":"","permalink":"https://shuaixiaohao.github.io/2017/11/15/通讯录/","excerpt":"用 pymysql 写了一个简单的通讯录。","text":"用 pymysql 写了一个简单的通讯录。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import pymysql#connection（连接）/ cursor（游标）conn = pymysql.connect(host='localhost', port=3306, user='root', passwd='123456', db='homework', charset='utf8', cursorclass=pymysql.cursors.DictCursor)class Contacts(): def __init__(self): self.cursor = conn.cursor() def add(self): name = input('姓名:') tel = input('电话号码:') addr = input('地址:') birth = input('出生日期:') result = self.cursor.execute('insert into tb_contacts (cname, ctel, caddr, cbirth) values (%s, %s, %s, %s)' , (name, tel, addr, birth)) print('添加成功' if result == 1 else '添加失败') conn.commit() def search(self, name): self.cursor.execute('select cname 姓名, ctel 电话, caddr 地址, cbirth 出生日期 from tb_contacts where cname like (%s)', (name)) result = self.cursor.fetchone() print(result if result else '没有该联系人') return result def delete(self): name = input('姓名:') if self.search(name): result = self.cursor.execute('delete from tb_contacts where cname=%s', (name,)) t = input('确认删除？(确认请输入: y)') if t == 'y' or t == 'Y': print('删除成功' if result == 1 else '删除失败') conn.commit() else: print('取消删除') def modify(self): name = input('需要编辑的联系人姓名:') if self.search(name): judg = True while judg: num = int(input('请输入编辑项:1.姓名 2.电话 3.地址 4.出生日期 5.退出 \\n:')) if num == 1: m_name = input('姓名:') result = self.cursor.execute('update tb_contacts set cname=%s where cname=%s',(m_name, name)) print('已更改' if result ==1 else '更改失败') conn.commit() self.search(m_name) elif num == 2: m_tel = input('电话:') result = self.cursor.execute('update tb_contacts set ctel=%s where cname=%s', (m_tel, name)) print('已更改' if result == 1 else '更改失败') conn.commit() self.search(name) elif num == 3: m_addr = input('地址:') result = self.cursor.execute('update tb_contacts set caddr=%s where cname=%s', (m_addr, name)) print('已更改' if result == 1 else '更改失败') conn.commit() self.search(name) elif num == 4: m_birth = input('地址:') result = self.cursor.execute('update tb_contacts set cbirth=%s where cname=%s', (m_birth, name)) print('已更改' if result == 1 else '更改失败') conn.commit() self.search(name) elif num == 5: judg = False else: print('没有该联系人请选择添加') def all(self): self.cursor.execute('select cname 姓名, ctel 电话, caddr 地址, cbirth 出生日期 from tb_contacts') result = self.cursor.fetchall() for a in result: print(a)def menu(): print('通讯录：\\n1.添加 \\n2.查询 \\n3.删除 \\n4.编辑 \\n5.查看所有联系人 \\n6.退出 ')contact = Contacts()def main(): menu() try: with conn.cursor() as cursor: while True: put = int(input('请输入相应数字操作:')) if put == 1: contact.add() elif put == 2: name = input('姓名:') contact.search(name) elif put == 3: contact.delete() elif put == 4: contact.modify() elif put == 5: contact.all() elif put == 6: break # conn.close() else: print('输入无效') finally: conn.close()if __name__ == '__main__': main()","categories":[],"tags":[{"name":"小练习","slug":"小练习","permalink":"https://shuaixiaohao.github.io/tags/小练习/"}]},{"title":"python学习","slug":"python学习","date":"2017-10-25T10:29:15.000Z","updated":"2018-08-05T08:36:03.276Z","comments":true,"path":"2017/10/25/python学习/","link":"","permalink":"https://shuaixiaohao.github.io/2017/10/25/python学习/","excerpt":"数据类型数字型(Number) 字符型(String) 布尔型(boolean) 空类型(None) 列表型(list) 元组型(tuple) 字典型(dict) 集合型(set) 标准数据类型Python3 中有六个标准的数据类型： Number（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） Sets（集合）","text":"数据类型数字型(Number) 字符型(String) 布尔型(boolean) 空类型(None) 列表型(list) 元组型(tuple) 字典型(dict) 集合型(set) 标准数据类型Python3 中有六个标准的数据类型： Number（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） Sets（集合） 变量对变量类型进行转换时可以使用Python的内置函数 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 Number（数字）整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）复数(complex) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型 数学函数函数 返回值 ( 描述 )abs(x) 返回数字的绝对值，如abs(-10) 返回 10ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5cmp(x, y) 如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 Python 3 已废弃 。使用 使用 (x&gt;y)- (x&lt;y) 替换。 exp(x) 返回e的x次幂(ex), 如math.exp(1) 返回2.718281828459045fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0max(x1, x2,...) 返回给定参数的最大值，参数可以为序列。min(x1, x2,...) 返回给定参数的最小值，参数可以为序列。modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。pow(x, y) x**y 运算后的值。round(x [,n]) 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。sqrt(x) 返回数字x的平方根。 String（字符串）字符串常用内建函数 str1 = ‘’hello, world!’ str1.split( ) 通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串 len() len函数计算字符串的长度 len(str1) # 13 str1.capitalize() 获得字符串首字母大写的拷贝 str1.capitalize() # Hello, world! str1.upper() 获得字符串变大写后的拷贝 str1.upper() # HELLO, WORLD! str1.find(str2, beg=0 end=len(string)) 检测 str2 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 12345678&gt;&gt;&gt;str1 = 'abca'&gt;&gt;&gt; print(str1.find('a')) # 从下标0开始，查找在字符串里第一个出现的子串，返回结果：00&gt;&gt;&gt; print(str1.find('a', 1)) # 从下标1开始，查找在字符串里第一个出现的子串：返回结果33&gt;&gt;&gt; print(str1.find('3')) # 查找不到返回-1-1&gt;&gt;&gt; index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在字符串中会报一个异常. str1.startswith(str2) 检查字符串是否以指定的字符串开头 12print(str1.startswith('He')) # Falseprint(str1.startswith('hel')) # True str1.endswith(str2) 检查字符串是否以指定的字符串结尾 1print(str1.endswith('!')) # True str1.center(width, &#39;=&#39;) 将字符串以指定的宽度居中并在两侧填充指定的字符 1print(str1.center(20, '=')) #===hello, world!==== rjust ljust 右对齐/左对齐 str1.rjust(width, &#39; &#39;) 将字符串以指定的宽度靠右放置左侧填充指定的字符 str1.isdigit() 检查字符串是否只由数字构成 ,返回 True 或 False str1.isalpha() 检查字符串是否只由字母构成 ,返回 True 或 False str1.isalnum() 检查字符串是否以数字和字母构成 ,返回 True 或 False str1.strip() 获得字符串修剪左右两侧空格的拷贝 12str1 = ' jackf1234@166.com 'print(str1.strip()) # jackf1234@166.com List（列表）list1 = [1, 3, 5, 7, 100] len(list1) 列表元素个数 list1.index(obj) 从列表中找出某个值第一个匹配项的索引位置 max(list1) 返回列表元素最大值 min(list1) 返回列表元素最小值 list(对象) 将对象转换为列表 , 对象:字符串,元组,集合; 字典只能把键转成列表 list1.append(元素) 在列表末尾添加新的元素list1.insert(下标, 元素) 在指定下标出添加一个元素,原来位置处的元素往后移动 list1.pop() 将列表中指定下标的元素删除, 如果默认不传递参数,则删除的是最后一个元素 list1.remove() 移除列表中指定的元素 list1.clear() 清除列表中所有的元素 list1.reverse() 用于反向列表中元素 等同于[::-1] reversed(seq) 函数返回一个反转的迭代器。 seq – 要转换的序列，可以是 tuple, string, list 或 range list1.sort() 应用在 list 上的方法, 返回的是对已经存在的列表进行操作 12345list1 = [4, 1, 45, 21, 2, 7]# print(list1.sort()) 打印为None,没有返回值,只对原来列表排序list2 = list1.sort()print(list2) #结果还是为None print(list1) #[1, 2, 4, 7, 21, 45] 123456# 0 1 2 3 4 5 6 7 8a = [1, 2, 3, 4, 5, 6, 7, 8, 9]b = a[7:3:-1]print(b) #[8, 7, 6, 5]print(a[1:3:-1]) #Noneprint(a[3:1:-1]) #[4, 3] Tuple（元组）元组中的元素值是不允许修改的，但我们可以对元组进行连接组合 len(tuple) 计算元组元素个数。 max(tuple) 返回元组中元素最大值。 min(tuple) 返回元组中元素最小值。 tuple(seq) 将列表转换为元组。 Dictionary（字典）无序集合, key唯一,必须是不可变类型访问获取方式: ​ dict[key] ​ dict.get(key) 添加元素: ​ dict[key] = value # key为原字典中不存在的键 修改: ​ dict[key] = balue # key为原字典中存在的键 dict.keys() 以列表返回字典中所有的键dict.values() 以列表返回字典中所有的值dict.items() 以列表返回可遍历的(键, 值) 元组数组 [(键, 值), (键, 值), (键, 值)]dict.setdefault() 返回指定键的值,如果键不存在于字典中，将会添加键并将值设为默认值dict.pop([key]) 删除指定键值对, 需传入参数 # 没有remove()方法enumerate()用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 字典内置函数dict1 = {‘name’:’shuaixiaohao’, ‘age’:22, ‘weight’:60} len(dict) 计算字典元素个数，即键的总数。 print(len(dict1)) # 3 str(dict) 输出字典，以可打印的字符串表示。 print(str(dict1)) #{‘name’: ‘shuaixiaohao’, ‘age’: 22, ‘weight’: 60}print(type(str(dict1))) # type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 字典内置函数radiansdict.clear()删除字典内所有元素radiansdict.copy()返回一个字典的浅复制radiansdict.fromkeys()创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值radiansdict.get(key, default=None)返回指定键的值，如果值不在字典中返回default值key in dict如果键在字典dict里返回true，否则返回falseradiansdict.items()以列表返回可遍历的(键, 值) 元组数组radiansdict.keys()以列表返回一个字典所有的键radiansdict.setdefault(key, default=None)和get()类似, 但如果键不存在于字典中，将会添加键并将值设为defaultradiansdict.update(dict2)把字典dict2的键/值对更新到dict里radiansdict.values()以列表返回字典中的所有值pop(key[,default])删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。popitem()随机返回并删除字典中的一对键和值(一般删除末尾对)。 Sets（集合）set是无序,没有重复元素set集合是不可改变的创建一个空的集合 set1 = set(()); set1 = set([]); set1 = set({}) 注意：如果要创建一个空集合，你必须用 set() 而不是 {} ；后者创建一个空的字典set.add(): 增加一个元素(重复元素不能添加) # 没有append()方法set.remove():删除元素, 参数是元素set.pop():删除最后一个元素set1 &amp; set2 交集set1 | set2 并集set1 - set2 差集set1 ^ set2 交并集 12dict--&gt;set 取字典的键, 传入集合set --&gt; dict(错误) # 不能将集合转换成字典, 只有键, 没有值 三元条件运算python中: 1value1 if condition else value2 JavaScript中: conditon ? valuel1 : value2 问号前面的条件如果成立 123function getStyle(elem) &#123; return window.getComputedStyle ? window.getComputedStyle(elem): elem.currentStyle;&#125; 迭代器与生成器迭代器迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 next()。 字符串，列表或元组对象都可用于创建迭代器 生成器 yield 函数被称为生成器（generator）, 生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器 , 每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。调用一个生成器函数，返回的是一个迭代器对象。 函数*args 可变参数(参数不确定) - 元组 **kwargs 关键字参数(给了参数名和参数值的参数) - 字典 匿名函数python 使用 lambda 来创建匿名函数。 所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。 1lambda [arg1 [,arg2,.....argn]]:expression #arg-参数 ,expression-表达式 变量作用域变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的 L （Local） 局部作用域 E （Enclosing） 闭包函数外的函数中 G （Global） 全局作用域 B （Built-in） 内建作用域 以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。 全局变量和局部变量定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域 global 和 nonlocal关键字 当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了 1234567import randomrandom.choice():返回列表,元祖,字典中的某一个值random.choices():返回列表,元祖,字典中的指定个数值个值 k 关键字参数random.random():返回0-1之间的数, [0, 1) random.uniform():返回指定的一个区间范围的随机数 [, )random.randint():返回指定区间范围的随机整数 [, ]random.shuffle():将列表中的数据进行打乱排序 123451. 不定长参数: *args2. 关键字参数: **kw3. 偏函数: 导入模块 import functools functools.partical()就是创建一个新的函数.不需要自行定义函数.直接将结果赋值给一个变量,而 这个变量就是一个函数.这个函数的目的是将默认参数给固定住4. 回调函数: 定义函数时,将函数名作为参数传递过来,然后在函数里边再次调用函数 偏函数正则表达式 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 \\ 匹配字符串的结束\\ .exe\\ 匹配字符串的结束\\ .exe 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 [^] 匹配不在字符集中的任意单一字符 [^aeiou] 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} \\ 分支 foo\\ bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?\\exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I’m dancing中的danc (?&lt;=exp) 匹配exp后面的位置 (?&lt;=\\bdanc)\\w+\\b 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (? 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.ba.?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 re模块中的核心函数 1234re.match(pattern, string, flags=0)pattern 匹配的正则表达式string 要匹配的字符串flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记 面向对象面向对象的三个基本特征是：封装、继承、多态 封装： ​ 封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。被封装的对象通常被称为抽象数据类型。 隐藏复杂的现实细节，暴露简单的调用接口。 封装的意义： 封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。 保护数据成员，不让类以外的程序直接访问或修改，只能通过提供的公共的接口访问==&gt;数据封装。 方法的细节对用户是隐藏的，只要接口不变，内容的修改不会影响到外部的调用者==&gt;方法封装。 当对象含有完整的属性和与之对应的方法时称为封装。 从对象外面不能直接访问对象的属性，只能通过和该属性对应的方法访问。 对象的方法可以接收对象外面的消息。 继承： ​ 从已有的类创建新类的过程 提供继承信息的称为父类(超类/基类) 得到继承信息的称为子类(派生类)。继承主要实现重用代码，节省开发时间。 在类名后边的括号里一般写的是基类的类名 子类中继承自父类(基类),则父类的成员属性和成员方法都可以被子类所继承 父类中私有的成员属性不能继承给子类的 多态： “一个接口，多种方法” ​ 同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。 多态的三个条件: 继承的存在(继承是多态的基础,没有继承就没有多态) 子类重写父类的方法(多态下调用子类重写的方法) 父类引用变量指向子类对象(子类到父类的类型转换) 数据抽象一找到和对象相关的数据一属性( 名词） 行为抽象一 找到和对象相关的行为一方法（动词） __slots__ ​ 限定自定义类型的对象只能绑定某些属性，可以通过在类中定义_slots\\_变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 123class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = ('_name', '_age', '_gender') 魔法方法区分开函数和方法的含义： 1.函数：类外部定义的，跟类没有直接关系的；形式： def func(*argv): 2.方法：class内部定义的函数（对象的方法也可以认为是属性）；分为两种： ① python自动产生的（魔法方法）：一般形式为 __func__()，python会在对应的时机自动调用该函数； ② 人为自定义的方法：一般和普通函数没有区别，只是定义在了class中而已 3.方法与函数的区别： 方法可认为是函数的特殊情况； ① 方法定义在class内部 ② 方法的第一个参数应为 cls(类方法) 或者 self(实例方法) 列出几个基本魔法方法： __new__(cls[,*argv]) __new__ 是在一个对象实例化的时候所调用的第一个方法 它的第一个参数是这个类，其他的参数是用来直接传递给 __init__ 方法 _new__ 决定是否要使用该 \\_init__方法，因为 __new__ 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __new__ 没有返回实例对象，则 __init__ 不会被调用 __new__ 主要是用于继承一个不可变的类型比如一个 tuple 或者 string __init__(self,[…]) 类的初始化方法 ，当一个实例对象被定义时调用 *__del__(self)** 析构器，当一个实例被析构时调用 _new__ 和 \\_init__ 是对象的构造器， __del__ 是对象的销毁器 Python内置装饰器在Python中有三个内置的装饰器，都是跟class相关的：staticmethod、classmethod 和property。 staticmethod 是类静态方法，其跟成员方法的区别是没有 self 参数，并且可以在类不进行实例化的情况下调用 classmethod 与成员方法的区别在于所接收的第一个参数不是 self （类实例的指针），而是cls（当前类的具体类型） property 是属性的意思，表示可以通过通过类实例直接访问的信息 类方法、静方法 都是通过给类发消息来调用的 实例方法 发给对象的消息 在类创建对象后，实例方法才能被使用，使用格式为：对象名.实例方法 ​ 名。实例方法可以使用该方法所在类的所有静态成员和实例成员。 异常处理123456789try: print('try...') r = 10 / 0 print('result:', r)except ZeroDivisionError as e: print('except:', e)finally: print('finally...')print('END') try语句按照如下方式工作； 首先，执行try子句（在关键字try和关键字except之间的语句） 如果没有异常发生，忽略except子句，try子句执行后结束。 如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。 如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。 无论有没有异常finally语句被执行。 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。 处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如: 12except (RuntimeError, TypeError, NameError): pass ​ try except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行 ​ 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。 异常处理并不仅仅处理那些直接发生在try子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。 文件读、写文件1open(filename, mode) mode：决定了打开文件的模式：只读，写入，追加等 操作模式 具体含义 ‘r’ 读取 （默认） ‘w’ 写入（会先截断之前的内容） ‘x’ 写入，如果文件已经存在会产生异常 ‘a’ 追加，将内容写入到已有文件的末尾 ‘b’ 二进制模式 ‘t’ 文本模式（默认） ‘+’ 更新（既可以读又可以写） with语句来自动帮我们调用close()方法 （关闭文件） with 语句就可以保证文件之类的对象在使用完之后一定会正确的执行他的清理方法 1with open(\"myfile.txt\") as f: 文件对象的方法fileObject.read([size]) ​ 从文件读取指定的字节数，如果未给定或为负则读取所有。 fileObject.write() ​ 写文件 # 如果要写入字符串以外的数据,先将他转换为字符串 fileObject.close() ​ 关闭文件 fileObject.readline([size]) ​ 读取整行内容,包括\\n字符, 如果给定参数则从文件开始读取指定的字符个数 fileObject.readlines([sizeint]) ​ 读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 f.tell() ​ 返回一个整数,表示当前文件指针的位置(就是到文件头的比特数). f.seek(偏移量,[起始位置]) ​ 用来移动文件指针 #偏移量:单位:比特,可正可负起始位置:0-文件头,默认值;1-当前位置;2-文件尾 操作文件和目录os模块:在这个模块中给我们封装好了系统操作的功能函数(方法) import os os.getcwd() 返回当前的工作目录 # 获取绝对路径 os.listdir(path) 返回指定的文件夹包含的文件或文件夹的名字的列表 os.mkdir(path) 在当前目录下创建新的目录 os.rmdir(path) 删除目录, 只能删除空目录 os.rename(src, dst) 对文件进行重命名 os.stat(file) 获取文件属性 os.remove(file) 删除文件 #可以将本文件删除 os.path.join(path1, path2) 路径拼接 os.path.split(path) 拆分路径 # 返回一个元组(目录, 最后一个文件/目录名称) os.path.splitext(path) 获取文件的或站名 os.path.exists(path) 判断文件/目录是否存在 os.path.isfile(path) 判断是否是文件 os.path.getsize(file) 获取文件的大小 os.path.dirname(path) 获取当前文件的目录 os.path.basename(path) 获取当前文件/目录名 StringIO很多时候，数据读写不一定是文件，也可以在内存中读写 StringIO模块主要用于在内存缓冲区中读写数据。模块是用类编写的，只有一个StringIO类， # 所以它的可用方法都在类中。此类中的大部分函数都与对文件的操作方法类似。 12345678910&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write('hello')5&gt;&gt;&gt; f.write(' ')1&gt;&gt;&gt; f.write('world!')6&gt;&gt;&gt; print(f.getvalue())hello world! getvalue()方法用于获得写入后的str。 BytesIOStringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。 BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes 123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write('中文'.encode('utf-8'))6&gt;&gt;&gt; print(f.getvalue())b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 进程和线程进程：是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位 线程：是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源 一个程序至少有一个进程,一个进程至少有一个线程。线程是最小的执行单元，而进程由至少一个线程组成。 多进程​ Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 fork()是os模块里的函数。 ​ 子进程永远返回 0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。 Windows没有 fork调用，multiprocessing模块就是跨平台版本的多进程模块。 multiprocessing模块提供了一个Process类来代表一个进程对象 1234567891011121314from multiprocessing import Processimport os# 子进程要执行的代码def run_proc(name): print('Run child process %s (%s)...' % (name, os.getpid()))if __name__=='__main__': print('Parent process %s.' % os.getpid()) #getpid()取得进程识别码 p = Process(target=run_proc, args=('test',)) #创建一个Process实例 print('Child process will start.') p.start() #启动子进程 p.join() #等待子进程结束后再继续往下运行 print('Child process end.') 执行结果如下： 1234Parent process 928.Process will start.Run child process test (929)...Process end. 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用 start()方法启动。 join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步 Pool如果要启动大量的子进程，可以用进程池的方式批量创建子进程： 多线程Python的标准库提供了两个模块：_thread 和 threading，_thread 是低级模块，threading 是高级模块，对 _thread 进行了封装。绝大多数情况下，我们只需要使用 threading 这个高级模块。 启动一个线程就是把一个函数传入并创建 Thread 实例，然后调用 start() 开始执行 网络编程协议- protocol- 通信双方对话的规范和标准 IP.Internet Protocol- 寻址和路由www.baidu.com---&gt; 180.97.33.108 TCP和UDP是在IP协议之上构建的传输协议它们能够提供传输数据的服务TCP提供了可靠传输服务TCP- Transfer Control Protocol握手机制+冗余校验—&gt; 重发一次 TCP.Transfer Control Protocol I1.可靠通信[数据不传丢也不传错]滑动窗口机制2.流量控制(自动调节发送数据的速度3.拥塞控制(网络拥堵时会降低发送速度) QQ 微信.应用级QQ— ICQ— OICQHTTP— Hyper-Text Transfer ProtocolHTTPS— SecureSMTP– Simple Mail Transfer ProtocolPOP3— Post Office Protocol version 3IMAP—Internet Mail Access Protocolxerox— macintosh— Windows URL— Uniform Resource Locator协议://域名或IP地址:80/路径/资源名 网络API(应用程序编程接口) / 网络 123456789requests.get()用于请求目标网站，类型是一个HTTPresponse类型import requestsresponse = requests.get('http://www.baidu.com')print(response.status_code) # 打印状态码print(response.url) # 打印请求urlprint(response.headers) # 打印头信息print(response.cookies) # 打印cookie信息print(response.text) #以文本形式打印网页源码print(response.content) #以字节流形式打印 TCP编程Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。 服务器12345678910111213141516171819202122232425262728293031323334353637#创建服务器发文件from io import SEEK_ENDfrom socket import socket, SOCK_STREAM, AF_INETfrom datetime import datetimefrom time import sleepdef main(): # 1.创建套接字对象并指定使用哪种传输服务 server = socket(family=AF_INET, type=SOCK_STREAM) # 2.绑定IP地址和端口(区分不同的服务) server.bind(('10.7.152.130', 9090)) # 3.开启监听 - 监听客户端连接到服务器 server.listen(512) print('服务器启动开始监听...') with open('guido.jpg', 'rb') as f: data = f.read() f.seek(0, SEEK_END)#设置文件读取指针在文件当前位置 file_len = f.tell()#返回文件当前位置指针 # 4.通过循环接收客户端的连接并作出相应的处理(提供服务) while True: # accept方法是一个阻塞方法 如果没有客户端连接到服务器这个方法就会阻塞代码不会向下执行 client, addr = server.accept() # 5.发送数据 client.send('guido.jpg'.encode('utf-8')) client.send(str(file_len).encode('utf-8')) total = 0 while total &lt; file_len: client.send(data[total:total+1024]) total += 1024 sleep(0.001) # 6.断开连接 client.close()if __name__ == '__main__': main() 客户端12345678910111213141516171819202122from socket import socketdef main(): # 创建一个socket client = socket() # 建立连接: client.connect(('10.7.152.130', 9090)) filename = client.recv(1024).decode('utf-8') print(filename) file_len = int(client.recv(1024).decode('utf-8')) print(file_len) with open('C:/Users/Administrator/Desktop/' + filename,'wb') as f: total = 0 while total &lt; file_len: date = client.recv(1024) f.write(date) total += 1024 print('图片已保存')if __name__ == '__main__': main() UDP编程","categories":[{"name":"语言","slug":"语言","permalink":"https://shuaixiaohao.github.io/categories/语言/"}],"tags":[{"name":"python","slug":"python","permalink":"https://shuaixiaohao.github.io/tags/python/"}]}]}