<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>数据分析</title>
      <link href="/2018/01/21/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
      <url>/2018/01/21/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>数据分析三剑客 numpy、 pandas、 matplotlib </p><h1 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h1><h2 id="NumPy-是什么？"><a href="#NumPy-是什么？" class="headerlink" title="NumPy 是什么？"></a>NumPy 是什么？</h2><p>​    NumPy是Python中用于科学计算的基础包。它是一个Python库，提供多维数组对象，各种派生的对象（如掩码数组和矩阵），以及数组快速操作的各种各样的例程，包括数学、逻辑、图形操作，排序、选择、I/O、离散傅里叶变换、基本线性代数、基本统计操作，随机模拟以及其他。</p><a id="more"></a> <p>​    <u>NumPy包的核心是ndarray对象。</u>它封装了均匀数据类型的n维数组，带有一些在编译过的代码中执行的操作。NumPy数组和Python标准列表有一些重要的差异：</p><ul><li>NumPy数组在创建时有固定的大小，不像Python列表（可动态增长）。改变一个ndarray的大小将创建一个新数组，并删除原有数组。</li><li>NumPy数组中的元素都必须是相同的数据类型，从而具有相同的内存大小。但有个例外：（Python，包括NumPy）对象数组的元素大小是不同的。</li><li>NumPy数组使大量数据上的高级数学运算和其他类型的操作变得容易。通常情况下，这样的操作可能比使用Python的内置列表效率更高，执行的代码更少。</li><li>越来越多的基于Python的科学和数学包使用NumPy数组；虽然它们通常支持Python列表作为输入，但他们会在处理之前将这些输入转换为NumPy数组，并总是输出NumPy数组。换句话说，为了高效使用许多（也许甚至是大多数）当今基于Python的科学/数学软件，只要知道如何使用Python的内置列表类型是不够的————你还需要知道如何使用NumPy数组。</li></ul><h2 id="Ndarray-对象"><a href="#Ndarray-对象" class="headerlink" title="Ndarray 对象"></a>Ndarray 对象</h2><p>NumPy 中定义的最重要的对象是称为 <code>ndarray</code> 的 N 维数组类型。 它描述相同类型的元素集合。 可以使用基于零的索引访问集合中的项目。</p><p><code>ndarray</code>中的每个元素在内存中使用相同大小的块。 <code>ndarray</code>中的每个元素是数据类型对象的对象(称为 <code>dtype</code>)。</p><h3 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h3><p>导入numpy库 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p><strong>使用np.array()创建多维数组</strong> </p><p>参数为列表： np.array([1,2,3])</p><p>注意：</p><ul><li>numpy默认ndarray的所有元素的类型是相同的</li><li>如果传进来的列表中包含不同的类型，则统一为同一类型，优先级：str&gt;float&gt;int</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="string">"3"</span>])</span><br><span class="line">&gt;&gt;&gt;array([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>], dtype=<span class="string">'&lt;U11'</span>)</span><br></pre></td></tr></table></figure><p><strong>使用np的常用函数(routines)创建</strong> </p><p>包含以下常见创建方法：</p><p>​    <strong>1、np.ones(shape, dtype=None, order=’C’)</strong> </p><p>功能：按照指定形状创建多维数组，并用1填充</p><p>参数：</p><p>shape 用于指定创建的多维数组的形状 可以传入2 或者 (2,3)</p><p>dtype 数据的类型 np.int8 np.float64</p><p>返回值：返沪创建好的多维数组数组</p><p>​    <strong>2、np.zeros(shape, dtype=float, order=’C’)</strong> </p><p>功能类似np.zeros只不过不是用1填充 而是用0填充</p><p>​    <strong>3、np.full(shape, fill_value, dtype=None, order=’C’)</strong> </p><p>shape指定形状 一般可以是 2 或者 (2,3) 之类的</p><p>fill_value指定填充的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.full(shape=(2,3),fill_value=5)</span><br><span class="line">&gt;&gt;&gt;array([[5, 5, 5],</span><br><span class="line">         [5, 5, 5]])</span><br></pre></td></tr></table></figure><p>​    <strong>4、np.eye(N, M=None, k=0, dtype=floa</strong> </p><p>功能：创建一个方阵（行和列的数量相等）</p><p>N 指定矩阵中有多少行和列</p><p>对角线为1其他的位置为0（单位矩阵）</p><p>​    <strong>5、 np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</strong> </p><p>功能：把start到stop的这个范围的数，等分成num份儿，填入数组</p><p>​    <strong>6、np.logspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</strong> </p><p>功能：把start到stop的这个范围的数，等分成num份儿，获得的值作为10的指数，求出来的值，填入数组</p><p>​    <strong>7、 np.arange([start, ]stop, [step, ]dtype=None) </strong></p><p>从start，到end，每隔step去一个值，放入一个数组</p><p>​    <strong>8、np.random.randint(low, high=None, size=None, dtype=’l’)</strong> </p><p>从low到high的范围随机取整数，填充多维数组 size用于指定数组的形状 如 2 (2,3)</p><p>​    <strong>9、np.random.randn(d0, d1, …, dn)</strong> </p><p>传入几个参数，就创建几维数组</p><p>产生以0为中心 方差为1 的 标准正太分布 的随机数 填充数组</p><p>如 np.random.randn(2,3,3) 产生一个三维数组 数组中有两个数组 两个数组中分别有三个数组 三个数组中每个都有三个元素</p><p>​    <strong>10、np.random.normal(loc=0.0, scale=1.0, size=None)</strong> </p><p>np.random.randn是标准正态分布（以0为中心，方差是1） normal可以指定中心和方差</p><p>loc 正态分别的中心</p><p>scale 正态分布的变化范围</p><p>size 数组的形状 如 2 (2,3)</p><p>​    <strong>11、np.random.random(size=None)</strong> </p><p>size指定三维数组的形状 如 2 (2,3)</p><p>函数随机生成0到1的随机数（左闭右开）填充数组</p><h3 id="ndarray的属性"><a href="#ndarray的属性" class="headerlink" title="ndarray的属性"></a>ndarray的属性</h3><p>4个必记参数：</p><p>ndim：维度</p><p>shape：形状（各维度的长度）</p><p>size：总长度</p><p>dtype：元素类型</p><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>Matplotlib 是 Python 的绘图库。 它可与 NumPy 一起使用，提供了一种有效的 MatLab 开源替代方案。 它也可以和图形工具包一起使用，如 PyQt 和 wxPython。</p><p><strong>1.引入matplotlib.pyplot</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p><strong>2.读取图片 pyplot.imread(要读取的文件路的径字)</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jin = plt.imread(&quot;./jin.png&quot;)</span><br></pre></td></tr></table></figure><p><strong>3.查看引入的图片的属性（其实图片就是一个三维数组）</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jin <span class="comment"># 其实图片就是一个三维数组 </span></span><br><span class="line">jin.ndim <span class="comment"># ndarray的ndim属性可以查看当前多维数组的维度</span></span><br><span class="line">jin.shape <span class="comment">#一个多维数组 里面有273个数组 这273个数组里面分别有411个数组 411个数组中有三个元素 这个三个元素分别对应 r g b 的值</span></span><br><span class="line">jin.size <span class="comment">#多维数组的总长度</span></span><br><span class="line">jin.dtype <span class="comment">#里面元素的数据类型</span></span><br><span class="line">jin.shape</span><br></pre></td></tr></table></figure><p><strong>4.根据传入的数据去绘制图片 pyplot.imshow(传入多维数组数据)</strong> </p><h2 id="ndarray的基本操作"><a href="#ndarray的基本操作" class="headerlink" title="ndarray的基本操作"></a>ndarray的基本操作</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p><code>ndarray</code>对象的内容可以通过索引或切片来访问和修改，就像 Python 的内置容器对象一样。</p><p>如前所述，<code>ndarray</code>对象中的元素遵循基于零的索引。 有三种可用的索引方法类型： <strong>字段访问，基本切片</strong>和<strong>高级索引</strong>。</p><p>基本切片是 Python 中基本切片概念到 n 维的扩展。 通过将<code>start</code>，<code>stop</code>和<code>step</code>参数提供给内置的<code>slice</code>函数来构造一个 Python <code>slice</code>对象。 此<code>slice</code>对象被传递给数组来提取数组的一部分。</p><p>基本索引：一维与列表完全一致 多维时同理</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p> 一维与列表切片完全一致 多维时同理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nd = np.random.randint(0,10,size=(5,4))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">nd[1:3]</span><br><span class="line">nd[1:3,0:2] # 从外往里 层层切片</span><br><span class="line"># start:end</span><br><span class="line">#  start:end:step</span><br><span class="line">nd[0:4:2,0:4:2]</span><br><span class="line">nd[::2,::2]</span><br><span class="line">nd[::-1] # 把最外围的顺序颠倒</span><br><span class="line">nd[:,::-1] #把往里一维的内部元素的顺序颠倒</span><br></pre></td></tr></table></figure><h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><p>使用reshape函数，注意参数是一个tuple！</p><h3 id="连结"><a href="#连结" class="headerlink" title="连结"></a>连结</h3><ol><li>np.concatenate() 连结需要注意的点：</li><li>连结的参数是列表：一定要加小括号</li><li>维度必须相同</li><li>形状相符</li><li>连结的方向默认是shape这个tuple的第一个值所代表的维度方向</li><li>可通过axis参数改变连结的方向</li></ol><h3 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h3><p>与级联类似，三个函数完成切分工作：</p><ul><li>np.split</li></ul><p>参数 1.要切分的数组 ；2.要分成几份； 3切分时候的轴（axis默认是0）</p><ul><li>np.vsplit</li></ul><p>vertical ，对垂直方向的元素进行切割（切割的时候是水平去切的）</p><ul><li>np.hsplit</li></ul><p>horizon ，对水平方向上的元素进行切割（切的时候垂直切）</p><h3 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h3><p>所有赋值运算不会为ndarray的任何元素创建副本。对赋值后的对象的操作也对原来的对象生效。</p><p>可使用copy()函数创建副本 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ndarr2 = ndarr.copy() #多维数组调用自身的copy()方法 就会返回一个一模一样 但是完全独立的数组</span><br></pre></td></tr></table></figure><h2 id="ndarray的聚合操作"><a href="#ndarray的聚合操作" class="headerlink" title="ndarray的聚合操作"></a>ndarray的聚合操作</h2><h3 id="求和np-sum"><a href="#求和np-sum" class="headerlink" title="求和np.sum"></a>求和np.sum</h3><h3 id="最大最小值：np-max-np-min"><a href="#最大最小值：np-max-np-min" class="headerlink" title="最大最小值：np.max/ np.min"></a>最大最小值：np.max/ np.min</h3><h3 id="其他聚合操作"><a href="#其他聚合操作" class="headerlink" title="其他聚合操作"></a>其他聚合操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function Name    NaN-safe Version    Description</span><br><span class="line">np.sum    np.nansum    Compute sum of elements</span><br><span class="line">np.prod    np.nanprod    Compute product of elements</span><br><span class="line">np.mean    np.nanmean    Compute mean of elements</span><br><span class="line">np.std    np.nanstd    Compute standard deviation</span><br><span class="line">np.var    np.nanvar    Compute variance</span><br><span class="line">np.min    np.nanmin    Find minimum value</span><br><span class="line">np.max    np.nanmax    Find maximum value</span><br><span class="line">np.argmin    np.nanargmin    Find index of minimum value</span><br><span class="line">np.argmax    np.nanargmax    Find index of maximum value</span><br><span class="line">np.median    np.nanmedian    Compute median of elements</span><br><span class="line">np.percentile    np.nanpercentile    Compute rank-based statistics of elements</span><br><span class="line">np.any    N/A    Evaluate whether any elements are true</span><br><span class="line">np.all    N/A    Evaluate whether all elements are true</span><br><span class="line">np.power 幂运算</span><br></pre></td></tr></table></figure><h4 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h4><p>使用pandas打开文件president_heights.csv 获取文件中的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># csv comma seperated value 逗号 分隔 的 值</span></span><br><span class="line">data = pd.read_csv(<span class="string">"./president_heights.csv"</span>)</span><br></pre></td></tr></table></figure><h2 id="ndarray的矩阵操作"><a href="#ndarray的矩阵操作" class="headerlink" title="ndarray的矩阵操作"></a>ndarray的矩阵操作</h2><h3 id="基本矩阵操作"><a href="#基本矩阵操作" class="headerlink" title="基本矩阵操作"></a>基本矩阵操作</h3><p>1) 算术运算符：</p><ul><li>加减乘除</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ndarr = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,size=(<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">ndarr</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">array([[<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="comment"># 矩阵和数值的运算</span></span><br><span class="line">ndarr + <span class="number">1</span> <span class="comment"># 矩阵和数值做加法 给矩阵中所有的值都加上这个数 广播机制</span></span><br><span class="line">ndarr - <span class="number">1</span> <span class="comment"># 矩阵中每一个值都减这个数值</span></span><br><span class="line">ndarr * <span class="number">2</span> <span class="comment"># 每个值都乘以这个数值</span></span><br><span class="line">ndarr / <span class="number">2</span> <span class="comment"># 每个值都除以这个数值</span></span><br></pre></td></tr></table></figure><p>2) 矩阵积<code>numpy.dot()</code> </p><p>此函数返回两个数组的点积。 对于二维向量，其等效于矩阵乘法。 对于一维数组，它是向量的内积。 对于 N 维数组，它是<code>a</code>的最后一个轴上的和与<code>b</code>的倒数第二个轴的乘积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]) </span><br><span class="line">b = np.array([[<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>]]) </span><br><span class="line">np.dot(a,b)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">37</span>  <span class="number">40</span>] </span><br><span class="line"> [<span class="number">85</span>  <span class="number">92</span>]]   <span class="comment">#[[1*11+2*13, 1*12+2*14],[3*11+4*13, 3*12+4*14]]</span></span><br></pre></td></tr></table></figure><h3 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h3><p><strong>广播</strong>是指 NumPy 在算术运算期间处理不同形状的数组的能力。 对数组的算术运算通常在相应的元素上进行。 如果两个阵列具有完全相同的形状，则这些操作被无缝执行。 </p><p>如果两个数组的维数不相同，则元素到元素的操作是不可能的。 然而，在 NumPy 中仍然可以对形状不相似的数组进行操作，因为它拥有广播功能。 较小的数组会<strong>广播</strong>到较大数组的大小，以便使它们的形状可兼容。</p><p>如果满足以下规则，可以进行广播：</p><ul><li><code>ndim</code>较小的数组会在前面追加一个长度为 1 的维度。</li><li>输出数组的每个维度的大小是输入数组该维度大小的最大值。</li><li>如果输入在每个维度中的大小与输出大小匹配，或其值正好为 1，则在计算中可它。</li><li>如果输入的某个维度大小为 1，则该维度中的第一个数据元素将用于该维度的所有计算。</li></ul><p>如果上述规则产生有效结果，并且满足以下条件之一，那么数组被称为<strong>可广播的</strong>。</p><ul><li>数组拥有相同形状。</li><li>数组拥有相同的维数，每个维度拥有相同长度，或者长度为 1。</li><li>数组拥有极少的维度，可以在其前面追加长度为 1 的维度，使上述条件成立。</li></ul><p>【重要】ndarray广播机制规则</p><ul><li><strong>缺失元素用已有值填充</strong> </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">3</span>).reshape((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">array([[<span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>]])</span><br><span class="line">b = np.arange(<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">a + b</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]])</span><br></pre></td></tr></table></figure><h2 id="ndarray的排序"><a href="#ndarray的排序" class="headerlink" title="ndarray的排序"></a>ndarray的排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>numpy.sort()与ndarray.sort()都可以，但有区别：</p><ul><li>numpy.sort()不改变输入</li><li>ndarray.sort()本地处理，不占用空间，但改变输入</li></ul><h3 id="部分排序"><a href="#部分排序" class="headerlink" title="部分排序"></a>部分排序</h3><p>np.partition(a,k)</p><p>有的时候我们不是对全部数据感兴趣，我们可能只对最小或最大的一部分感兴趣。</p><ul><li>当k为正时，我们想要得到最小的k个数</li><li>当k为负时，我们想要得到最大的k个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ndarr3 = np.random.randint(<span class="number">0</span>,<span class="number">100</span>,size=<span class="number">15</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>array([<span class="number">89</span>,  <span class="number">2</span>, <span class="number">20</span>, <span class="number">55</span>, <span class="number">76</span>, <span class="number">96</span>, <span class="number">92</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">92</span>, <span class="number">13</span>, <span class="number">65</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">52</span>])</span><br><span class="line"></span><br><span class="line">numpy.partition(ndarr3,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>array([ <span class="number">2</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">52</span>, <span class="number">92</span>, <span class="number">92</span>, <span class="number">96</span>, <span class="number">65</span>, <span class="number">76</span>, <span class="number">55</span>, <span class="number">89</span>]) <span class="comment"># 前面三个最小排序</span></span><br><span class="line"></span><br><span class="line">numpy.partition(ndarr3,<span class="number">-5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>array([ <span class="number">2</span>, <span class="number">22</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">23</span>, <span class="number">52</span>, <span class="number">55</span>, <span class="number">65</span>, <span class="number">76</span>, <span class="number">89</span>, <span class="number">92</span>, <span class="number">96</span>, <span class="number">92</span>]) <span class="comment"># 后面五个最大排序</span></span><br></pre></td></tr></table></figure><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>以下函数用于对<code>dtype</code>为<code>numpy.string_</code>或<code>numpy.unicode_</code>的数组执行向量化字符串操作。 它们基于 Python 内置库中的标准字符串函数。</p><table><thead><tr><th>序号</th><th>函数及描述</th></tr></thead><tbody><tr><td>1.</td><td><code>add()</code> 返回两个<code>str</code>或<code>Unicode</code>数组的逐个字符串连接</td></tr><tr><td>2.</td><td><code>multiply()</code> 返回按元素多重连接后的字符串</td></tr><tr><td>3.</td><td><code>center()</code> 返回给定字符串的副本，其中元素位于特定字符串的中央</td></tr><tr><td>4.</td><td><code>capitalize()</code> 返回给定字符串的副本，其中只有第一个字符串大写</td></tr><tr><td>5.</td><td><code>title()</code> 返回字符串或 Unicode 的按元素标题转换版本</td></tr><tr><td>6.</td><td><code>lower()</code> 返回一个数组，其元素转换为小写</td></tr><tr><td>7.</td><td><code>upper()</code> 返回一个数组，其元素转换为大写</td></tr><tr><td>8.</td><td><code>split()</code> 返回字符串中的单词列表，并使用分隔符来分割</td></tr><tr><td>9.</td><td><code>splitlines()</code> 返回元素中的行列表，以换行符分割</td></tr><tr><td>10.</td><td><code>strip()</code> 返回数组副本，其中元素移除了开头或者结尾处的特定字符</td></tr><tr><td>11.</td><td><code>join()</code> 返回一个字符串，它是序列中字符串的连接</td></tr><tr><td>12.</td><td><code>replace()</code> 返回字符串的副本，其中所有子字符串的出现位置都被新字符串取代</td></tr><tr><td>13.</td><td><code>decode()</code> 按元素调用<code>str.decode</code></td></tr><tr><td>14.</td><td><code>encode()</code> 按元素调用<code>str.encode</code></td></tr></tbody></table><p>这些函数在字符数组类(<code>numpy.char</code>)中定义。 较旧的 Numarray 包包含<code>chararray</code>类。 <code>numpy.char</code>类中的上述函数在执行向量化字符串操作时非常有用。</p><h3 id="numpy-char-add"><a href="#numpy-char-add" class="headerlink" title="numpy.char.add()"></a><code>numpy.char.add()</code></h3><p>函数执行按元素的字符串连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">print &apos;连接两个字符串：&apos; </span><br><span class="line">print np.char.add([&apos;hello&apos;],[&apos; xyz&apos;]) </span><br><span class="line">print &apos;\n&apos;</span><br><span class="line"></span><br><span class="line">print &apos;连接示例：&apos; </span><br><span class="line">print np.char.add([&apos;hello&apos;, &apos;hi&apos;],[&apos; abc&apos;, &apos; xyz&apos;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">连接两个字符串：</span><br><span class="line">[&apos;hello xyz&apos;]</span><br><span class="line"></span><br><span class="line">连接示例：</span><br><span class="line">[&apos;hello abc&apos; &apos;hi xyz&apos;]</span><br></pre></td></tr></table></figure><h3 id="numpy-char-multiply"><a href="#numpy-char-multiply" class="headerlink" title="numpy.char.multiply()"></a><code>numpy.char.multiply()</code></h3><p>这个函数执行多重连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">print np.char.multiply(&apos;Hello &apos;,3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello Hello Hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><h3 id="numpy-char-center"><a href="#numpy-char-center" class="headerlink" title="numpy.char.center()"></a><code>numpy.char.center()</code></h3><p>此函数返回所需宽度的数组，以便输入字符串位于中心，并使用<code>fillchar</code>在左侧和右侧进行填充。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line"># np.char.center(arr, width,fillchar) </span><br><span class="line">print np.char.center(&apos;hello&apos;, 20,fillchar = &apos;*&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*******hello********</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><h3 id="numpy-char-capitalize"><a href="#numpy-char-capitalize" class="headerlink" title="numpy.char.capitalize()"></a><code>numpy.char.capitalize()</code></h3><p>函数返回字符串的副本，其中第一个字母大写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">print np.char.capitalize(&apos;hello world&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello world</span><br></pre></td></tr></table></figure><h3 id="numpy-char-title"><a href="#numpy-char-title" class="headerlink" title="numpy.char.title()"></a><code>numpy.char.title()</code></h3><p>返回输入字符串的按元素标题转换版本，其中每个单词的首字母都大写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">print np.char.title(&apos;hello how are you?&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello How Are You?</span><br></pre></td></tr></table></figure><h3 id="numpy-char-lower"><a href="#numpy-char-lower" class="headerlink" title="numpy.char.lower()"></a><code>numpy.char.lower()</code></h3><p>函数返回一个数组，其元素转换为小写。它对每个元素调用<code>str.lower</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">print np.char.lower([&apos;HELLO&apos;,&apos;WORLD&apos;]) </span><br><span class="line">print np.char.lower(&apos;HELLO&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&apos;hello&apos; &apos;world&apos;]</span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><h3 id="numpy-char-upper"><a href="#numpy-char-upper" class="headerlink" title="numpy.char.upper()"></a><code>numpy.char.upper()</code></h3><p>函数返回一个数组，其元素转换为大写。它对每个元素调用<code>str.upper</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">print np.char.upper(&apos;hello&apos;) </span><br><span class="line">print np.char.upper([&apos;hello&apos;,&apos;world&apos;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HELLO</span><br><span class="line">[&apos;HELLO&apos; &apos;WORLD&apos;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><h3 id="numpy-char-split"><a href="#numpy-char-split" class="headerlink" title="numpy.char.split()"></a><code>numpy.char.split()</code></h3><p>此函数返回输入字符串中的单词列表。 默认情况下，空格用作分隔符。 否则，指定的分隔符字符用于分割字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">print np.char.split (&apos;hello how are you?&apos;) </span><br><span class="line">print np.char.split (&apos;YiibaiPoint,Hyderabad,Telangana&apos;, sep = &apos;,&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&apos;hello&apos;, &apos;how&apos;, &apos;are&apos;, &apos;you?&apos;]</span><br><span class="line">[&apos;YiibaiPoint&apos;, &apos;Hyderabad&apos;, &apos;Telangana&apos;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><h3 id="numpy-char-splitlines"><a href="#numpy-char-splitlines" class="headerlink" title="numpy.char.splitlines()"></a><code>numpy.char.splitlines()</code></h3><p>函数返回数组中元素的单词列表，以换行符分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">print np.char.splitlines(&apos;hello\nhow are you?&apos;) </span><br><span class="line">print np.char.splitlines(&apos;hello\rhow are you?&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&apos;hello&apos;, &apos;how are you?&apos;]</span><br><span class="line">[&apos;hello&apos;, &apos;how are you?&apos;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p><code>&#39;\n&#39;</code>，<code>&#39;\r&#39;</code>，<code>&#39;\r\n&#39;</code>都会用作换行符。</p><h3 id="numpy-char-strip"><a href="#numpy-char-strip" class="headerlink" title="numpy.char.strip()"></a><code>numpy.char.strip()</code></h3><p>函数返回数组的副本，其中元素移除了开头或结尾处的特定字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">print np.char.strip(&apos;ashok arora&apos;,&apos;a&apos;) </span><br><span class="line">print np.char.strip([&apos;arora&apos;,&apos;admin&apos;,&apos;java&apos;],&apos;a&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shok aror</span><br><span class="line">[&apos;ror&apos; &apos;dmin&apos; &apos;jav&apos;]</span><br></pre></td></tr></table></figure><h3 id="numpy-char-join"><a href="#numpy-char-join" class="headerlink" title="numpy.char.join()"></a><code>numpy.char.join()</code></h3><p>这个函数返回一个字符串，其中单个字符由特定的分隔符连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">print np.char.join(&apos;:&apos;,&apos;dmy&apos;) </span><br><span class="line">print np.char.join([&apos;:&apos;,&apos;-&apos;],[&apos;dmy&apos;,&apos;ymd&apos;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d:m:y</span><br><span class="line">[&apos;d:m:y&apos; &apos;y-m-d&apos;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><h3 id="numpy-char-replace"><a href="#numpy-char-replace" class="headerlink" title="numpy.char.replace()"></a><code>numpy.char.replace()</code></h3><p>这个函数返回字符串副本，其中所有字符序列的出现位置都被另一个给定的字符序列取代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">print np.char.replace (&apos;He is a good boy&apos;, &apos;is&apos;, &apos;was&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">He was a good boy</span><br></pre></td></tr></table></figure><h3 id="numpy-char-decode"><a href="#numpy-char-decode" class="headerlink" title="numpy.char.decode()"></a><code>numpy.char.decode()</code></h3><p>这个函数在给定的字符串中使用特定编码调用<code>str.decode()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line"></span><br><span class="line">a = np.char.encode(&apos;hello&apos;, &apos;cp500&apos;) </span><br><span class="line">print a </span><br><span class="line">print np.char.decode(a,&apos;cp500&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\x88\x85\x93\x93\x96</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h3 id="numpy-char-encode"><a href="#numpy-char-encode" class="headerlink" title="numpy.char.encode()"></a><code>numpy.char.encode()</code></h3><p>此函数对数组中的每个元素调用<code>str.encode</code>函数。 默认编码是<code>utf_8</code>，可以使用标准 Python 库中的编解码器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.char.encode(&apos;hello&apos;, &apos;cp500&apos;) </span><br><span class="line">print a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x88\x85\x93\x93\x96</span><br></pre></td></tr></table></figure><h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><p>​    <a href="http://pandas.pydata.org/pandas-docs/stable/" target="_blank" rel="noopener">官方文档</a></p><p>数据分析三剑客 numpy pandas matplotlib </p><h2 id="Pandas介绍"><a href="#Pandas介绍" class="headerlink" title="Pandas介绍"></a>Pandas介绍</h2><p>Pandas是一个开放源码的Python库，它使用强大的数据结构提供高性能的数据操作和分析工具。它的名字：<em>Pandas</em>是从<em>Panel Data</em> - 多维数据的计量经济学(<em>an Econometrics from Multidimensional data</em>)。</p><p>2008年，为满足需要高性能，灵活的数据分析工具，开发商Wes McKinney开始开发<em>Pandas</em>。</p><p>在<em>Pandas</em>之前，Python主要用于数据迁移和准备。它对数据分析的贡献更小。 <em>Pandas</em>解决了这个问题。 使用<em>Pandas</em>可以完成数据处理和分析的五个典型步骤，而不管数据的来源 - 加载，准备，操作，模型和分析。</p><p>Python <em>Pandas</em>用于广泛的领域，包括金融，经济，统计，分析等学术和商业领域。</p><p><strong>Pandas的主要特点</strong> </p><ul><li>快速高效的DataFrame对象，具有默认和自定义的索引。</li><li>将数据从不同文件格式加载到内存中的数据对象的工具。</li><li>丢失数据的数据对齐和综合处理。</li><li>重组和摆动日期集。</li><li>基于标签的切片，索引和大数据集的子集。</li><li>可以删除或插入来自数据结构的列。</li><li>按数据分组进行聚合和转换。</li><li>高性能合并和数据加入。</li><li>时间序列功能。</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><em>Pandas</em>处理以下三个数据结构 -</p><ul><li>系列(<code>Series</code>)</li><li>数据帧(<code>DataFrame</code>)</li><li>面板(<code>Panel</code>)</li></ul><p>这些数据结构构建在<em>Numpy</em>数组之上，这意味着它们很快。</p><p><strong>维数和描述</strong> </p><p>考虑这些数据结构的最好方法是，较高维数据结构是其较低维数据结构的容器。 例如，<code>DataFrame</code>是<code>Series</code>的容器，<code>Panel</code>是<code>DataFrame</code>的容器。</p><table><thead><tr><th>数据结构</th><th>维数</th><th>描述</th></tr></thead><tbody><tr><td>系列</td><td>1</td><td><code>1</code>D标记均匀数组，大小不变。</td></tr><tr><td>数据帧</td><td>2</td><td>一般<code>2</code>D标记，大小可变的表结构与潜在的异质类型的列。</td></tr><tr><td>面板</td><td>3</td><td>一般<code>3</code>D标记，大小可变数组。</td></tr></tbody></table><p>构建和处理两个或更多个维数组是一项繁琐的任务，用户在编写函数时要考虑数据集的方向。 但是使用<em>Pandas</em>数据结构，减少了用户的思考。</p><p>例如，使用表格数据(<code>DataFrame</code>)，在语义上更有用于考虑索引(行)和列，而不是轴<code>0</code>和轴<code>1</code>。</p><p><strong>可变性</strong></p><p>所有<em>Pandas</em>数据结构是值可变的(可以更改)，除了系列都是大小可变的。系列是大小不变的。</p><blockquote><p>注 - <code>DataFrame</code>被广泛使用，是最重要的数据结构之一。面板使用少得多。</p></blockquote><h3 id="系列（Series）"><a href="#系列（Series）" class="headerlink" title="系列（Series）"></a>系列（Series）</h3><p>系列是具有均匀数据的一维数组结构。例如，以下系列是整数：<code>10</code>,<code>23</code>,<code>56</code>，<code>...</code>的集合。</p><p><img src="C:/Users/Administrator/Desktop/Markdown/images/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/series1.png" alt="img"></p><p><strong>关键点</strong> </p><ul><li>均匀数据</li><li>尺寸大小不变</li><li>数据的值可变</li></ul><h3 id="数据帧（DataFrame）"><a href="#数据帧（DataFrame）" class="headerlink" title="数据帧（DataFrame）"></a>数据帧（DataFrame）</h3><p>数据帧(<em>DataFrame</em>)是一个具有异构数据的二维数组。</p><p><strong>关键点</strong> </p><ul><li>异构数据</li><li>大小可变</li><li>数据可变</li></ul><h3 id="面板（Panel）"><a href="#面板（Panel）" class="headerlink" title="面板（Panel）"></a>面板（Panel）</h3><p>面板是具有异构数据的三维数据结构。在图形表示中很难表示面板。但是一个面板可以说明为<code>DataFrame</code>的容器。</p><p><strong>关键点</strong> </p><ul><li>异构数据</li><li>大小可变</li><li>数据可变</li></ul><h2 id="Series（系列）"><a href="#Series（系列）" class="headerlink" title="Series（系列）"></a>Series（系列）</h2><p>Series是一种类似于一维数组的对象，由下面两个部分组成：</p><ul><li>index：相关的数据索引标签</li><li>values：一组数据（ndarray类型）</li></ul><h3 id="1-Series的创建"><a href="#1-Series的创建" class="headerlink" title="1. Series的创建"></a>1. Series的创建</h3><p>两种创建方式：</p><p>(1) 由列表或numpy数组创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认索引为<span class="number">0</span>到N<span class="number">-1</span>的整数型索引</span><br><span class="line">Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],index=(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>)) <span class="comment"># 通过index可以指定索引 注意：索引的个数和值的个数要对应</span></span><br></pre></td></tr></table></figure><p>(2) 由字典创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Series(&#123;<span class="string">"A"</span>:<span class="number">10</span>,<span class="string">"B"</span>:<span class="number">20</span>,<span class="string">"C"</span>:<span class="number">30</span>&#125;)</span><br><span class="line">&gt;&gt;&gt;A    <span class="number">10</span></span><br><span class="line">B    <span class="number">20</span></span><br><span class="line">C    <span class="number">30</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><h3 id="2-Series的索引和切片"><a href="#2-Series的索引和切片" class="headerlink" title="2. Series的索引和切片"></a>2. Series的索引和切片</h3><p>可以使用中括号取单个索引（此时返回的是元素类型），或者中括号里一个列表取多个索引（此时返回的仍然是一个Series类型）。分为显示索引和隐式索引：</p><p>(1) 显式索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 使用index中的元素作为索引值</span><br><span class="line">- 使用.loc[]（推荐）</span><br></pre></td></tr></table></figure><p>注意，此时是闭区间</p><p>(2) 隐式索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 使用整数作为索引值</span><br><span class="line">- 使用.iloc[]（推荐）</span><br></pre></td></tr></table></figure><p>注意，此时是半开区间</p><p><strong>根据索引对Series进行切片</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1</span><br><span class="line">&gt;&gt;&gt;语文    150</span><br><span class="line">数学    150</span><br><span class="line">英语    150</span><br><span class="line">理综    300</span><br><span class="line">dtype: int64</span><br><span class="line">s1.loc[&apos;语文&apos;:&apos;英语&apos;]</span><br><span class="line">s1.iloc[0:4]</span><br></pre></td></tr></table></figure><h3 id="3-Series的常用属性和方法"><a href="#3-Series的常用属性和方法" class="headerlink" title="3. Series的常用属性和方法"></a>3. Series的常用属性和方法</h3><ul><li><p>可以把Series看成一个定长的有序字典</p></li><li><p>可以通过shape，size，index,values等得到series的属性</p></li><li><p>head(),tail()快速查看Series对象的样式</p><p>例：s.head(2)看头两个 s.tail(1)看后一个</p></li><li><p>当索引没有对应的值时，可能出现缺失数据显示NaN（not a number）的情况 </p></li><li><p>使用pd.isnull()，pd.notnull()，或自带isnull(),notnull()函数检测缺失数据 </p></li><li><p>Series对象本身及其实例都有一个name属性 </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],index=(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>),name=<span class="string">"张三"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">Name: 张三, dtype: int64</span><br></pre></td></tr></table></figure><h3 id="4-Series的运算"><a href="#4-Series的运算" class="headerlink" title="4. Series的运算"></a>4. Series的运算</h3><p>(1) 适用于numpy的数组运算也适用于Series </p><p>(2) Series之间的运算</p><ul><li>在运算中自动对齐不同索引的数据</li><li>如果索引不对应，则补NaN</li><li>注意：要想保留所有的index，则需要使用.add()函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">s1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>语文    <span class="number">150</span></span><br><span class="line">数学    <span class="number">150</span></span><br><span class="line">dtype: int64</span><br><span class="line">        </span><br><span class="line">s3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">Name: 张三, dtype: int64</span><br><span class="line">            </span><br><span class="line">s1 + s3 <span class="comment"># 两个Series进行加和时，如果索引不对应，返回值 nan</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a    NaN</span><br><span class="line">b    NaN</span><br><span class="line">语文   NaN</span><br><span class="line">数学   NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引不对应 就出NaN 如果不喜欢这样可以调用 series自身的add（）方法</span></span><br><span class="line">s1.add(s3)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a       <span class="number">1.0</span></span><br><span class="line">b       <span class="number">2.0</span></span><br><span class="line">语文    <span class="number">150.0</span></span><br><span class="line">数学    <span class="number">150.0</span></span><br><span class="line">    dtype: float64</span><br></pre></td></tr></table></figure><h2 id="DataFrame（数据帧）"><a href="#DataFrame（数据帧）" class="headerlink" title="DataFrame（数据帧）"></a>DataFrame（数据帧）</h2><p>DataFrame是一个【表格型】的数据结构，可以看做是【由Series组成的字典】（共用同一个索引）。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到多维。DataFrame既有行索引，也有列索引。</p><ul><li>行索引：index</li><li>列索引：columns</li><li>值：values（numpy的二维数组）</li></ul><p><em>pandas</em>中的<code>DataFrame</code>可以使用以下构造函数创建 -</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.DataFrame( data, index, columns, dtype, copy)</span><br></pre></td></tr></table></figure><p>构造函数的参数如下 -</p><table><thead><tr><th>编号</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>data</code></td><td>数据采取各种形式，如:<code>ndarray</code>，<code>series</code>，<code>map</code>，<code>lists</code>，<code>dict</code>，<code>constant</code>和另一个<code>DataFrame</code>。</td></tr><tr><td>2</td><td><code>index</code></td><td>对于<strong>行标签</strong>，要用于结果帧的索引是可选缺省值<code>np.arrange(n)</code>，如果没有传递索引值。</td></tr><tr><td>3</td><td><code>columns</code></td><td>对于<strong>列标签</strong>，可选的默认语法是 - <code>np.arange(n)</code>。 这只有在没有索引传递的情况下才是这样。</td></tr><tr><td>4</td><td><code>dtype</code></td><td>每列的数据类型。</td></tr><tr><td>5</td><td><code>copy</code></td><td>如果默认值为<code>False</code>，则此命令(或任何它)用于复制数据。</td></tr></tbody></table><h3 id="1-DataFrame的创建"><a href="#1-DataFrame的创建" class="headerlink" title="1. DataFrame的创建"></a>1. DataFrame的创建</h3><p>最常用的方法是传递一个字典来创建。DataFrame以字典的键作为每一【列】的名称，以字典的值（一个数组）作为每一列。</p><p>此外，DataFrame会自动加上每一行的索引（和Series一样）。</p><p>同Series一样，若传入的列与字典的键不匹配，则相应的值为NaN。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"></span><br><span class="line">data = np.random.randint(<span class="number">0</span>,<span class="number">150</span>,size=(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line">index = [<span class="string">'张三'</span>,<span class="string">'李四'</span>,<span class="string">'王五'</span>,<span class="string">'小六'</span>]</span><br><span class="line">df = DataFrame(data, index=index,columns=[<span class="string">'Math'</span>,<span class="string">'Chinese'</span>,<span class="string">'English'</span>,<span class="string">'Python'</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">MathChineseEnglishPython</span><br><span class="line">张三<span class="number">41</span><span class="number">47</span><span class="number">19</span><span class="number">114</span></span><br><span class="line">李四<span class="number">16</span><span class="number">43</span><span class="number">77</span><span class="number">115</span></span><br><span class="line">王五<span class="number">116</span><span class="number">148</span><span class="number">92</span><span class="number">74</span></span><br><span class="line">小六<span class="number">93</span><span class="number">72</span><span class="number">26</span><span class="number">59</span></span><br></pre></td></tr></table></figure><h3 id="2-DataFrame的索引"><a href="#2-DataFrame的索引" class="headerlink" title="2. DataFrame的索引"></a>2. DataFrame的索引</h3><p>(1) 对 <strong>列</strong> 进行索引</p><p>​    –  通过类似字典的方式</p><p>​    –  通过属性的方式</p><p>可以将DataFrame的列获取为一个Series。返回的Series拥有原DataFrame相同的索引，且name属性也已经设置好了，就是相应的列名。</p><p><em>每一行是一个样本   每一列是描述这个样本的维度</em>  </p><p>(2) 对 <strong>行</strong> 进行索引</p><p>​    –  使用.loc[]加index来进行行索引</p><p>​    –  使用.iloc[]加整数来进行行索引</p><p>同样返回一个Series，index为原来的columns。</p><p><strong>总结：</strong> </p><p>​    <u>columns 才能以索引的形式去找 df [“列名”] 、df.列名</u></p><p>​    <u>index 不能用索引的方式去找 只能用 loc[] 和 iloc[] 去定位内容</u> </p><p>(3) 对元素进行索引</p><p>​    –  使用列索引</p><p>​    –  使用行索引( iloc[3,1]相当于两个参数; iloc[[3,3]] 里面的[3,3]看做一个参数)</p><p>​    –  使用values属性（二维numpy数组）</p><p>【注意】 直接用中括号 [ ] 时：</p><ul><li>索引表示的是列索引</li><li>切片表示的是行切片</li></ul><h3 id="3-DataFrame的运算"><a href="#3-DataFrame的运算" class="headerlink" title="3. DataFrame的运算"></a>3. DataFrame的运算</h3><p>（1） DataFrame和数值的运算 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataFrame + 1   # 所有内容都加一</span><br><span class="line"># 还有列与行</span><br></pre></td></tr></table></figure><p>（2） DataFrame与DataFrame之间的运算</p><p>同Series一样：</p><ul><li>在运算中自动对齐不同索引的数据</li><li>如果索引不对应，则补NaN</li></ul><p>下面是Python 操作符与pandas操作函数的对应表：</p><table><thead><tr><th>Python Operator</th><th>Pandas Method(s)</th></tr></thead><tbody><tr><td><code>+</code></td><td><code>add()</code></td></tr><tr><td><code>-</code></td><td><code>sub()</code>, <code>subtract()</code></td></tr><tr><td><code>*</code></td><td><code>mul()</code>, <code>multiply()</code></td></tr><tr><td><code>/</code></td><td><code>truediv()</code>, <code>div()</code>, <code>divide()</code></td></tr><tr><td><code>//</code></td><td><code>floordiv()</code></td></tr><tr><td><code>%</code></td><td><code>mod()</code></td></tr><tr><td><code>**</code></td><td><code>pow()</code></td></tr></tbody></table><p>（3） DataFrame和Series之间的运算 </p><p>【重要】</p><ul><li><p>使用Python操作符：以行为单位操作（参数必须是行），对所有行都有效。（类似于numpy中二维数组与一维数组的运算，但可能出现NaN）</p></li><li><p>使用pandas操作函数：</p><p>​    –  axis=0：以列为单位操作（参数必须是列），对所有列都有效。</p><pre><code>--  axis=1：以行为单位操作（参数必须是行），对所有行都有效。</code></pre></li></ul><h2 id="空数据处理"><a href="#空数据处理" class="headerlink" title="空数据处理"></a>空数据处理</h2><h3 id="检查缺失值"><a href="#检查缺失值" class="headerlink" title="检查缺失值"></a>检查缺失值</h3><p>​    <code>isnull()</code>和<code>notnull()</code>函数 ,它们也是Series和DataFrame对象的方法 </p><p>配合any使用，可以查看每一 行 / 列 是否存在空值 可以控制axis来改变查看方向 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df1 = DataFrame(data=np.random.randint(<span class="number">0</span>,<span class="number">20</span>,size=(<span class="number">5</span>,<span class="number">5</span>)),columns=list(<span class="string">"abcde"</span>))</span><br><span class="line"><span class="comment"># 如果想看每一行的 中 有没有空值 可以改变axis</span></span><br><span class="line">df1.isnull().any()</span><br><span class="line">df1.isnull().any(axis=<span class="number">0</span>) <span class="comment"># axis 默认是 0 是竖直方向</span></span><br><span class="line">df1.isnull().any(axis=<span class="number">1</span>) <span class="comment"># 通过这种方式 可以找到有空值的样本</span></span><br></pre></td></tr></table></figure><h3 id="过滤丢失数据"><a href="#过滤丢失数据" class="headerlink" title="过滤丢失数据"></a>过滤丢失数据</h3><p>​    <code>dropna()</code>: 过滤丢失数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dropna(axis, how)    <span class="comment"># axis 删除有NaN的行还是列，how 要有NaN就删 还是全都是NaN才删</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df1.dropna() <span class="comment"># 如果有空值 就把整行都干掉</span></span><br><span class="line">df1.dropna(axis=<span class="number">0</span>) <span class="comment"># 默认是对行进行处理</span></span><br><span class="line">df1.dropna(axis=<span class="number">1</span>) <span class="comment"># 对有空值的列进行处理</span></span><br><span class="line"></span><br><span class="line">df1.dropna(how=<span class="string">"any"</span>) <span class="comment"># 只要有空值 就干掉</span></span><br><span class="line">df1.dropna(how=<span class="string">"all"</span>) <span class="comment"># 这一行所有的值都是空值 才干掉</span></span><br></pre></td></tr></table></figure><h3 id="填充缺少数据"><a href="#填充缺少数据" class="headerlink" title="填充缺少数据"></a>填充缺少数据</h3><p>​    <code>fillna()</code>函数可以用非空数据“填充”<code>NaN</code>值 </p><p>​    –  value ：指定填充的值<br>    –  method ：指定找前面还是找后面<br>    –  axis ：指定是横着找还是竖着找<br>    –  limit：限定往前/后找几个</p><p>注意：value参数是不能跟method参数共用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df1.fillna(value=0) # 遇到空值 可以设置成我们制定的值</span><br><span class="line">df1.fillna(value=10)  # 可以指定value值</span><br><span class="line"></span><br><span class="line"># pad / ffill 从前面找值来填充</span><br><span class="line"># backfill/ bfill 从后面找值来填充</span><br><span class="line">df1.fillna(method=&quot;ffill&quot;)</span><br><span class="line">df1.fillna(method=&quot;bfill&quot;)</span><br><span class="line"></span><br><span class="line">df1.fillna(method=&quot;ffill&quot;,axis=0) # axis 默认是0 竖直找</span><br><span class="line">df1.fillna(method=&quot;ffill&quot;,axis=1) # axis 1 水平找</span><br><span class="line"></span><br><span class="line">df1.fillna(method=&quot;ffill&quot;,limit=2) # 限制往前找几个</span><br></pre></td></tr></table></figure><h2 id="多层索引"><a href="#多层索引" class="headerlink" title="多层索引"></a>多层索引</h2><h3 id="多层行索引"><a href="#多层行索引" class="headerlink" title="多层行索引"></a>多层行索引</h3><p><strong>创建MultiIndex（分层索引）对象</strong> </p><p>该<code>MultiIndex</code>对象是标准<code>Index</code>对象的分层模拟 ，通常将轴标签存储在pandas对象中 </p><p>数组列表（使用 <code>MultiIndex.from_arrays</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index = pd.MultiIndex.from_arrays([[<span class="string">"期中"</span>,<span class="string">"期中"</span>,<span class="string">"期中"</span>,<span class="string">"期末"</span>,<span class="string">"期末"</span>,<span class="string">"期末"</span>],[<span class="string">"语文"</span>,<span class="string">"英语"</span>,<span class="string">"数学"</span>,<span class="string">"语文"</span>,<span class="string">"英语"</span>,<span class="string">"数学"</span>]])</span><br><span class="line"></span><br><span class="line">columns = [<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span>,<span class="string">"赵柳"</span>]</span><br><span class="line">data = np.random.randint(<span class="number">0</span>,<span class="number">150</span>,size=(<span class="number">6</span>,<span class="number">4</span>))</span><br><span class="line">DataFrame(data,index,columns)</span><br></pre></td></tr></table></figure><p>元组数组（使用<code>MultiIndex.from_tuples</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index = pd.MultiIndex.from_tuples([(<span class="string">"期中"</span>,<span class="string">"语文"</span>),(<span class="string">"期中"</span>,<span class="string">"数学"</span>),(<span class="string">"期中"</span>,<span class="string">"英语"</span>),(<span class="string">"期末"</span>,<span class="string">"语文"</span>),(<span class="string">"期末"</span>,<span class="string">"数学"</span>),(<span class="string">"期末"</span>,<span class="string">"英语"</span>)])</span><br><span class="line"></span><br><span class="line">columns = [<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span>,<span class="string">"赵柳"</span>]</span><br><span class="line">data = np.random.randint(<span class="number">0</span>,<span class="number">150</span>,size=(<span class="number">6</span>,<span class="number">4</span>))</span><br><span class="line">DataFrame(data,index,columns)</span><br></pre></td></tr></table></figure><p>交叉迭代集（使用 <code>MultiIndex.from_product</code>），<u>最简单，推荐使用</u> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index = pd.MultiIndex.from_product([[<span class="string">"期中"</span>,<span class="string">"期末"</span>],[<span class="string">"语文"</span>,<span class="string">"数学"</span>,<span class="string">"英语"</span>]])</span><br><span class="line"></span><br><span class="line">columns = [<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span>,<span class="string">"赵柳"</span>]</span><br><span class="line">data = np.random.randint(<span class="number">0</span>,<span class="number">150</span>,size=(<span class="number">6</span>,<span class="number">4</span>))</span><br><span class="line">DataFrame(data,index,columns)</span><br></pre></td></tr></table></figure><h3 id="多层列索引"><a href="#多层列索引" class="headerlink" title="多层列索引"></a>多层列索引</h3><p>除了行索引index，列索引columns也能用同样的方法创建多层索引 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randint(0,150,size=(2,4))</span><br><span class="line">index= pd.MultiIndex.from_product([[&quot;期中&quot;,&quot;期末&quot;],[&quot;语文&quot;,&quot;英语&quot;]]) # 多层索引</span><br><span class="line">columns = [&quot;张三&quot;,&quot;李四&quot;] #单层索引</span><br><span class="line">df1 = DataFrame(data=data,index=columns,columns=index)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">期中期末</span><br><span class="line">语文英语语文英语</span><br><span class="line">张三50 12   8999</span><br><span class="line">李四119  9   133102</span><br></pre></td></tr></table></figure><h3 id="索引与切片操作"><a href="#索引与切片操作" class="headerlink" title="索引与切片操作"></a>索引与切片操作</h3><p><strong>Series的操作</strong> </p><p>【重要】对于Series来说，直接中括号 [ ] 与使用 .loc() 完全一样，推荐使用 .loc 中括号索引和切片。</p><p><strong>DataFrame的操作</strong> </p><p>(1) 可以直接使用列名称来进行列索引 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1[&quot;期中&quot;][&quot;语文&quot;]</span><br></pre></td></tr></table></figure><p>(2) 使用行索引需要用 loc() 等函数 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1.loc[&quot;张三&quot;]</span><br><span class="line">df1.iloc[0]</span><br></pre></td></tr></table></figure><h2 id="形状变换"><a href="#形状变换" class="headerlink" title="形状变换"></a>形状变换</h2><p><strong>stack()</strong> </p><p>​    columns -&gt; index 列标题变行标题（数据也会跟着标题走）</p><p>​    level 的值默认为-1（最内层）；取值从外往里 从0递增 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.stack(level=<span class="number">0</span>) <span class="comment"># level 索引的级别 默认是-1 -1就是最里面的  level的值 从外到内 0 1 2 3</span></span><br></pre></td></tr></table></figure><p><strong>unstack()</strong> </p><p>​    index -&gt; columns 行标题变列标题（数据也会跟着标题走）</p><h2 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h2><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td><code>count()</code></td><td>Number of non-null observations</td></tr><tr><td><code>sum()</code></td><td>对 values 求和</td></tr><tr><td><code>mean()</code></td><td>values 的平均值</td></tr><tr><td><code>min()</code></td><td>求 values 最小值</td></tr><tr><td><code>max()</code></td><td>求 values 最大值</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 如果想对 行进行聚合操作 可以调整 axis</span><br><span class="line">df.sum(axis=0) # axis 默认值是0 是对列做加和</span><br><span class="line">df.sum(axis=1)</span><br></pre></td></tr></table></figure><h2 id="合并、连接"><a href="#合并、连接" class="headerlink" title="合并、连接"></a>合并、连接</h2><p>pandas的拼接分为两种：</p><ul><li>级联：pandas.concat， pandas.append (没有重复数据)</li><li>合并：pandas.merge， pandas.join (有重复数据)</li></ul><h3 id="pandas-concat-级联"><a href="#pandas-concat-级联" class="headerlink" title="pandas.concat()级联"></a>pandas.concat()级联</h3><p><strong>简单级联</strong> </p><p>pandas使用pandas.concat函数，与numpy.concatenate函数类似 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd.concat(objs, axis=<span class="number">0</span>, join=<span class="string">'outer'</span>, join_axes=<span class="keyword">None</span>, ignore_index=<span class="keyword">False</span>,</span><br><span class="line">          keys=<span class="keyword">None</span>, levels=<span class="keyword">None</span>, names=<span class="keyword">None</span>, verify_integrity=<span class="keyword">False</span>,</span><br><span class="line">          copy=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>参数：</p><ol><li><p>objs 传入列表或者元素 里面是要拼接的DataFrame</p></li><li><p>axis 拼接的时候是沿着什么方向 默认值是0 纵向 如果是1就是横向</p></li><li><p>join 指定了拼接的方式 默认是outer</p><p>–  outer 外联 所有的列都会拼进来</p><p>–  inner 内联 只有那些两个DataFrame都有的列才会拼进来</p></li><li><p>join_axes 直接指定那些列要放进来</p></li><li><p>ignore_index=False 忽略原有索引创建新的索引 （如果索引有重复可以通过忽略原索引来重置）</p></li><li><p>keys 可以把不同的DataFrame分成多组 也可以用来解决index重复的问题</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">df3 = pd.concat((df1,df2)) <span class="comment">#默认 axis是0 是纵向拼接</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">0</span><span class="number">1</span><span class="number">2</span></span><br><span class="line"><span class="number">0</span><span class="number">7</span><span class="number">4</span><span class="number">2</span></span><br><span class="line"><span class="number">1</span><span class="number">2</span><span class="number">7</span><span class="number">9</span></span><br><span class="line"><span class="number">2</span><span class="number">7</span><span class="number">6</span><span class="number">6</span></span><br><span class="line"><span class="number">0</span><span class="number">69</span><span class="number">93</span><span class="number">71</span></span><br><span class="line"><span class="number">1</span><span class="number">87</span><span class="number">25</span><span class="number">38</span></span><br><span class="line"><span class="number">2</span><span class="number">42</span><span class="number">15</span><span class="number">35</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过 重置索引的方式 去重新让索引不重复</span></span><br><span class="line"><span class="comment"># ignore_index=False 忽略原索引 建立新索引 默认是False</span></span><br><span class="line">df3 = pd.concat((df1,df2),ignore_index=<span class="keyword">True</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">0</span><span class="number">1</span><span class="number">2</span></span><br><span class="line"><span class="number">0</span><span class="number">7</span><span class="number">4</span><span class="number">2</span></span><br><span class="line"><span class="number">1</span><span class="number">2</span><span class="number">7</span><span class="number">9</span></span><br><span class="line"><span class="number">2</span><span class="number">7</span><span class="number">6</span><span class="number">6</span></span><br><span class="line"><span class="number">3</span><span class="number">69</span><span class="number">93</span><span class="number">71</span></span><br><span class="line"><span class="number">4</span><span class="number">87</span><span class="number">25</span><span class="number">38</span></span><br><span class="line"><span class="number">5</span><span class="number">42</span><span class="number">15</span><span class="number">35</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># axis=1 水平方向拼接</span></span><br><span class="line">df3 = pd.concat((df1,df2),ignore_index=<span class="keyword">True</span>,axis=<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span><span class="number">4</span><span class="number">5</span></span><br><span class="line"><span class="number">0</span><span class="number">7</span><span class="number">4</span><span class="number">2</span><span class="number">69</span><span class="number">93</span><span class="number">71</span></span><br><span class="line"><span class="number">1</span><span class="number">2</span><span class="number">7</span><span class="number">9</span><span class="number">87</span><span class="number">25</span><span class="number">38</span></span><br><span class="line"><span class="number">2</span><span class="number">7</span><span class="number">6</span><span class="number">6</span><span class="number">42</span><span class="number">15</span><span class="number">35</span></span><br></pre></td></tr></table></figure><p><strong>不匹配级联</strong> </p><p>不匹配指的是级联的维度的索引不一致。例如纵向级联时列索引不一致，横向级联时行索引不一致 </p><p>有3种连接方式：</p><ul><li>外连接：补NaN（默认模式）    join=’outer’</li><li>内连接：只连接匹配的项         join=’inner’</li><li>连接指定轴 join_axes</li></ul><h3 id="pandas-append-函数添加"><a href="#pandas-append-函数添加" class="headerlink" title="pandas.append()函数添加"></a>pandas.append()函数添加</h3><p>由于在后面级联的使用非常普遍，因此有一个函数pandas.append()专门用于在后面添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df6.append(df7) # 只能是把行 纵向地 从后 往前 拼接</span><br></pre></td></tr></table></figure><h3 id="pandas-merge-合并"><a href="#pandas-merge-合并" class="headerlink" title="pandas.merge()合并"></a>pandas.merge()合并</h3><p>merge与concat的区别在于，merge需要依据某一共同的行或列来进行合并</p><p>使用pd.merge()合并时，会自动根据两者相同column名称的那一列，作为key来进行合并。</p><p>注意每一列元素的顺序不要求一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(left, right, how=<span class="string">'inner'</span>, on=<span class="keyword">None</span>, left_on=<span class="keyword">None</span>, right_on=<span class="keyword">None</span>,</span><br><span class="line">left_index=<span class="keyword">False</span>, right_index=<span class="keyword">False</span>, sort=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>在这里，有以下几个参数可以使用 -</p><ul><li><p><em>left</em> - 一个DataFrame对象。</p></li><li><p><em>right</em> - 另一个DataFrame对象。</p></li><li><p><em>on</em> - 列(名称)连接，必须在左和右DataFrame对象中存在(找到)。</p></li><li><p><em>left_on</em> - 左侧DataFrame中的列用作键，可以是列名或长度等于DataFrame长度的数组。</p></li><li><p><em>right_on</em> - 来自右的DataFrame的列作为键，可以是列名或长度等于DataFrame长度的数组。</p></li><li><p><em>left_index</em> - 如果为<code>True</code>，则使用左侧DataFrame中的索引(行标签)作为其连接键。 在具有MultiIndex(分层)的DataFrame的情况下，级别的数量必须与来自右DataFrame的连接键的数量相匹配。</p></li><li><p><em>right_index</em> - 与右DataFrame的<em>left_index</em>具有相同的用法。</p></li><li><p><em>how</em> - 它是<em>left</em>, <em>right</em>, <em>outer</em>以及<em>inner</em>之中的一个，默认为内<em>inner</em>。 </p><p>–  inner  是取交集 两个都有的项目才出现</p><p>–  outer 是取并集 任何一个表格里出现的项目都会出现</p><p>–  left  左边的表格有多少项目 这里就有多少项目</p><p>–  right  右边的表格有多少项目 这里就有多少项目</p></li><li><p><em>sort</em> - 按照字典顺序通过连接键对结果DataFrame进行排序。默认为<code>True</code>，设置为<code>False</code>时，在很多情况下大大提高性能。</p></li></ul><p><strong>key的规范化</strong> </p><p>​    –  使用on=显式指定哪一列为key,当有多个key相同时使用</p><p>​    –  使用left_on和right_on指定左右两边的列作为key，当左右两边的key都不想等时使用</p><p><strong>内合并与外合并</strong> </p><p>​    –  内合并：只保留两者都有的key（默认模式）</p><p>​    –  外合并 how=’outer’：补NaN</p><p>​    –  左合并、右合并：how=’left’，how=’right’，</p><p><strong>列冲突的解决</strong> </p><p>​    –  当列冲突时，即有多个列名称相同时，需要使用on=来指定哪一个列作为key，配合suffixes指定冲突列名</p><p>​    –  可以使用suffixes=自己指定后缀</p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>Pandas I/O API是一套像<code>pd.read_csv()</code>一样返回<code>Pandas</code>对象的顶级读取器函数。</p><p>读取文本文件(或平面文件)的两个主要功能是<code>read_csv()</code>和<code>read_table()</code>。它们都使用相同的解析代码来智能地将表格数据转换为<code>DataFrame</code>对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pandas.read_csv(filepath_or_buffer, sep=&apos;,&apos;, delimiter=None, header=&apos;infer&apos;,</span><br><span class="line">names=None, index_col=None, usecols=None)</span><br></pre></td></tr></table></figure><p><strong>read.csv</strong> </p><p><code>read.csv</code>从csv文件中读取数据并创建一个<code>DataFrame</code>对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">df=pd.read_csv(&quot;temp.csv&quot;)</span><br><span class="line">print (df)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>执行上面示例代码，得到以下结果 -</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   S.No    Name  Age       City  Salary</span><br><span class="line">0     1     Tom   28    Toronto   20000</span><br><span class="line">1     2     Lee   32   HongKong    3000</span><br><span class="line">2     3  Steven   43   Bay Area    8300</span><br><span class="line">3     4     Ram   38  Hyderabad    3900</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shell</span><br></pre></td></tr></table></figure><p><strong>自定义索引</strong> </p><p>可以指定csv文件中的一列来使用<code>index_col</code>定制索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df=pd.read_csv(&quot;temp.csv&quot;,index_col=[&apos;S.No&apos;])</span><br><span class="line">print (df)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>执行上面示例代码，得到以下结果 -</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        Name  Age       City  Salary</span><br><span class="line">S.No                                </span><br><span class="line">1        Tom   28    Toronto   20000</span><br><span class="line">2        Lee   32   HongKong    3000</span><br><span class="line">3     Steven   43   Bay Area    8300</span><br><span class="line">4        Ram   38  Hyderabad    3900</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shell</span><br></pre></td></tr></table></figure><p><strong>转换器</strong><br><code>dtype</code>的列可以作为字典传递。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">df = pd.read_csv(&quot;temp.csv&quot;, dtype=&#123;&apos;Salary&apos;: np.float64&#125;)</span><br><span class="line">print (df.dtypes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>执行上面示例代码，得到以下结果 -</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">S.No        int64</span><br><span class="line">Name       object</span><br><span class="line">Age         int64</span><br><span class="line">City       object</span><br><span class="line">Salary    float64</span><br><span class="line">dtype: object</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shell</span><br></pre></td></tr></table></figure><p>默认情况下，Salary列的<code>dtype</code>是<code>int</code>，但结果显示为<code>float</code>，因为我们明确地转换了类型。</p><p>因此，数据看起来像浮点数 -</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  S.No   Name   Age      City    Salary</span><br><span class="line">0   1     Tom   28    Toronto   20000.0</span><br><span class="line">1   2     Lee   32   HongKong    3000.0</span><br><span class="line">2   3  Steven   43   Bay Area    8300.0</span><br><span class="line">3   4     Ram   38  Hyderabad    3900.0</span><br></pre></td></tr></table></figure><p><strong>header_names</strong><br>使用<code>names</code>参数指定标题的名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">df=pd.read_csv(&quot;temp.csv&quot;, names=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;,&apos;d&apos;,&apos;e&apos;])</span><br><span class="line">print (df)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>执行上面示例代码，得到以下结果 -</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      a       b    c          d       e</span><br><span class="line">0  S.No    Name  Age       City  Salary</span><br><span class="line">1     1     Tom   28    Toronto   20000</span><br><span class="line">2     2     Lee   32   HongKong    3000</span><br><span class="line">3     3  Steven   43   Bay Area    8300</span><br><span class="line">4     4     Ram   38  Hyderabad    3900</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shell</span><br></pre></td></tr></table></figure><p>观察可以看到，标题名称附加了自定义名称，但文件中的标题还没有被消除。 现在，使用<code>header</code>参数来删除它。</p><p>如果标题不是第一行，则将行号传递给标题。这将跳过前面的行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">df=pd.read_csv(&quot;temp.csv&quot;,names=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;],header=0)</span><br><span class="line">print (df)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>执行上面示例代码，得到以下结果 -</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   a       b   c          d      e</span><br><span class="line">0  1     Tom  28    Toronto  20000</span><br><span class="line">1  2     Lee  32   HongKong   3000</span><br><span class="line">2  3  Steven  43   Bay Area   8300</span><br><span class="line">3  4     Ram  38  Hyderabad   3900</span><br></pre></td></tr></table></figure><p><strong>skiprows</strong> </p><p><code>skiprows</code>跳过指定的行数。参考以下示例代码 -</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">df=pd.read_csv(&quot;temp.csv&quot;, skiprows=2)</span><br><span class="line">print (df)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>执行上面示例代码，得到以下结果 -</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   2     Lee  32   HongKong  3000</span><br><span class="line">0  3  Steven  43   Bay Area  8300</span><br><span class="line">1  4     Ram  38  Hyderabad  3900</span><br></pre></td></tr></table></figure><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>使用duplicated()函数检测重复的行，返回元素为布尔类型的Series对象，每个元素对应一行，如果该行不是第一次出现，则元素为True（是重复的）</p><ul><li>使用drop_duplicates()函数删除重复的行</li><li>使用duplicate()函数查看重复的行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pythonc++ java</span><br><span class="line">A<span class="number">100</span>   <span class="number">100</span>  <span class="number">100</span></span><br><span class="line">B<span class="number">90</span>   <span class="number">90</span>  <span class="number">88</span></span><br><span class="line">C<span class="number">100</span>   <span class="number">100</span>  <span class="number">100</span></span><br><span class="line">D<span class="number">90</span>   <span class="number">90</span>  <span class="number">87</span></span><br><span class="line">E<span class="number">100</span>   <span class="number">100</span>  <span class="number">100</span></span><br><span class="line"></span><br><span class="line">df.duplicated(keep=<span class="string">"first"</span>) <span class="comment"># 告诉我们 当前行是否重复, default 'first'</span></span><br><span class="line"><span class="comment"># 参数默认是 keep="first" 保留开始的 意思是如果发现很多重复的元素 第一个不算重复的 后面的才是</span></span><br><span class="line"><span class="comment"># 某一行重复 就返回True</span></span><br><span class="line">A    <span class="keyword">False</span></span><br><span class="line">B    <span class="keyword">False</span></span><br><span class="line">C     <span class="keyword">True</span></span><br><span class="line">D    <span class="keyword">False</span></span><br><span class="line">E     <span class="keyword">True</span></span><br><span class="line">dtype: bool</span><br><span class="line"></span><br><span class="line">df.duplicated(keep=<span class="string">"last"</span>) <span class="comment"># keep last 如果遇到重复的元素 最后一个不算重复的 前面的才算重复</span></span><br><span class="line"><span class="comment"># 这一行重复了 就是True</span></span><br><span class="line">A     <span class="keyword">True</span></span><br><span class="line">B    <span class="keyword">False</span></span><br><span class="line">C     <span class="keyword">True</span></span><br><span class="line">D    <span class="keyword">False</span></span><br><span class="line">E    <span class="keyword">False</span></span><br><span class="line">dtype: bool</span><br><span class="line">    </span><br><span class="line">df.duplicated(keep=<span class="keyword">False</span>) <span class="comment"># 只要有和别人完全一样的 不管在开头还是结尾 都算重复</span></span><br><span class="line"><span class="comment"># 这一行如果是重复的就返回 True</span></span><br><span class="line">A     <span class="keyword">True</span></span><br><span class="line">B    <span class="keyword">False</span></span><br><span class="line">C     <span class="keyword">True</span></span><br><span class="line">D    <span class="keyword">False</span></span><br><span class="line">E     <span class="keyword">True</span></span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射的含义：创建一个映射关系列表，把values元素和一个特定的标签或者字符串绑定</p><p>包含三种操作：</p><ul><li>replace()函数：替换元素</li><li>最重要：map()函数：新建一列</li><li>rename()函数：替换索引</li></ul><h3 id="replace-函数：替换元素"><a href="#replace-函数：替换元素" class="headerlink" title="replace()函数：替换元素"></a>replace()函数：替换元素</h3><p>使用replace()函数，对values进行替换操作 </p><p> <strong>Series替换操作</strong> </p><p>单值替换</p><ul><li>普通替换</li><li>字典替换(推荐）</li></ul><p>多值替换</p><ul><li>列表替换</li><li>字典替换（推荐）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单值替换 普通替换</span></span><br><span class="line">s1.replace(to_replace=<span class="string">"peppa"</span>,value=<span class="string">"佩琪"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单值替换 字典替换（ ）</span></span><br><span class="line">s1.replace(&#123;<span class="string">"chengdu"</span>:<span class="string">"成都"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多值替换 列表替换 s1.replace([要替换的值1,要替换的值2,.....],[替换成什么1,替换成什么2,....])</span></span><br><span class="line">s1.replace([<span class="number">100</span>,np.nan],[<span class="string">"满分"</span>,<span class="string">"空值"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多值替换 字典替换（ &#123; 要替换的值:替换成什么,要替换的值:替换成什么 &#125; ）</span></span><br><span class="line">s1.replace(&#123;<span class="number">100</span>:<span class="string">"满分"</span>,<span class="string">"peppa"</span>:<span class="string">"佩琪"</span>&#125;)</span><br></pre></td></tr></table></figure><p>Series参数说明：</p><ul><li>method：对指定的值使用相邻的值填充</li><li>limit：设定填充次数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果指定value不好 还可以找值来填充</span></span><br><span class="line">s2.replace(to_replace=<span class="number">100</span>,method=<span class="string">"bfill"</span>) <span class="comment"># 从后面找值来替换当前值</span></span><br><span class="line">s2.replace(to_replace=<span class="number">100</span>,method=<span class="string">"ffill"</span>) <span class="comment"># 从前面找</span></span><br><span class="line">s2.replace(to_replace=<span class="number">100</span>,method=<span class="string">"ffill"</span>,limit=<span class="number">1</span>) <span class="comment"># limit 指定是最多往前或者往后 找几个 如果找不到就不填充了 # limit 默认是None不限制</span></span><br></pre></td></tr></table></figure><p><strong>DataFrame替换操作</strong> </p><p>单值替换</p><ul><li>普通替换</li><li>按列指定单值替换{列标签：目标值}</li></ul><p>多值替换</p><ul><li>列表替换</li><li>单字典替换（推荐）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通的单值替换</span></span><br><span class="line">df.replace(to_replace=<span class="string">'Beijing'</span>,value=<span class="string">'北京'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按列指定单值换目标值 (&#123;列索引,待替换值&#125;,目标值)</span></span><br><span class="line">df.replace(&#123;<span class="number">4</span>:<span class="string">'Beijing'</span>&#125;,<span class="string">'首都'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多值替换 列表进替换</span></span><br><span class="line"><span class="comment"># replace([要替换的1，要替换的2...],[替换成1，替换成2])</span></span><br><span class="line">df.replace([<span class="number">66</span>,<span class="string">'甲'</span>,<span class="string">'shanghai'</span>],[<span class="number">100</span>,<span class="string">'first'</span>,<span class="string">'上海'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># replace(&#123;要替换的1：替换成的值1，要替换的2：替换成的值2，...&#125;) 可以将没有的值也放在这里 不会报错 将来可以整个项目使用一个过滤器</span></span><br><span class="line">df.replace(&#123;<span class="number">66</span>:<span class="number">100</span>,<span class="string">'乙'</span>:<span class="string">'second'</span>,<span class="string">'Beijing'</span>:<span class="string">'BEIJING'</span>,<span class="string">'没有的值'</span>:<span class="string">'也可以放'</span>&#125;)</span><br><span class="line"><span class="comment"># 我们可以在 字典里面写很多值 字典中的值即使找不到也不会报错</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：DataFrame中，无法使用method和limit参数 </p><h3 id="map-函数：新建一列"><a href="#map-函数：新建一列" class="headerlink" title="map()函数：新建一列"></a>map()函数：新建一列</h3><ul><li>map(字典) 字典的键要足以匹配所有的数据，否则出现NaN</li><li>map()可以映射新一列数据</li><li>map()中可以使用lambd表达式</li><li>map()中可以使用方法，可以是自定义的方法</li></ul><p><strong>注意</strong> map()中不能使用sum之类的函数，for循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">姓名语文数学pythonphp</span><br><span class="line">0小明 90  98  9098</span><br><span class="line">1小红 44  89  4489</span><br><span class="line">2小芳 98  90  9098</span><br><span class="line">3小李 89  44  4489</span><br><span class="line">4李元芳78 98     98    87</span><br><span class="line">5狄仁杰66 44     44    89</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 映射字典</span><br><span class="line">map_dic = &#123;&apos;小明&apos;:&apos;北京&apos;,&apos;小红&apos;:&apos;上海&apos;,&apos;小芳&apos;:&apos;北京&apos;,</span><br><span class="line">           &apos;小李&apos;:&apos;广州&apos;,&apos;李元芳&apos;:&apos;成都&apos;,&apos;狄仁杰&apos;:&apos;成都&apos;&#125;</span><br><span class="line">score[&quot;姓名&quot;]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">0     小明</span><br><span class="line">1     小红</span><br><span class="line">2     小芳</span><br><span class="line">3     小李</span><br><span class="line">4    李元芳</span><br><span class="line">5    狄仁杰</span><br><span class="line">Name: 姓名, dtype: object</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># map函数不是DataFrame的方法，而是Sereis对象的方法</span><br><span class="line"># 可以传入映射字典</span><br><span class="line">score[&quot;姓名&quot;].map(map_dic)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">0    北京</span><br><span class="line">1    上海</span><br><span class="line">2    北京</span><br><span class="line">3    广州</span><br><span class="line">4    成都</span><br><span class="line">5    成都</span><br><span class="line">Name: 姓名, dtype: object</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">score[&quot;所在城市&quot;] = score[&quot;姓名&quot;].map(map_dic) # 可以传入字典</span><br><span class="line">score</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">姓名语文数学pythonphp所在城市</span><br><span class="line">0小明90989098北京</span><br><span class="line">1小红44894489上海</span><br><span class="line">2小芳98909098北京</span><br><span class="line">3小李89444489广州</span><br><span class="line">4李元芳78989887成都</span><br><span class="line">5狄仁杰66444489成都</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 还可以传入 拉姆达表达式 如 lambda x:x+10</span><br><span class="line">score[&quot;python&quot;]= score[&quot;python&quot;].map(lambda x:x+10)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">姓名语文数学pythonphp所在城市</span><br><span class="line">0小明909810018北京</span><br><span class="line">1小红4489549上海</span><br><span class="line">2小芳989010018北京</span><br><span class="line">3小李8944549广州</span><br><span class="line">4李元芳78981087成都</span><br><span class="line">5狄仁杰6644549成都</span><br></pre></td></tr></table></figure><h3 id="rename-函数：替换索引"><a href="#rename-函数：替换索引" class="headerlink" title="rename()函数：替换索引"></a>rename()函数：替换索引</h3><p>对DataFrame的索引名进行更改 , 仍然是新建一个字典 </p><p>使用rename()函数替换行索引</p><ul><li>index 替换行索引</li><li>columns 替换列索引</li><li>level 指定多维索引的维度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">score.rename(map_dic) # 默认是替换 行的名称</span><br><span class="line"></span><br><span class="line">score.rename(columns=map_dic) # 指定columns可以对列名称进行替换</span><br><span class="line">score.rename(columns=map_dic,level=0) # 通过level参数 可以指定具体对哪一层级进行替换  </span><br><span class="line">score.rename(columns=map_dic,level=1) # 0 是最外层</span><br></pre></td></tr></table></figure><h2 id="异常检测和过滤"><a href="#异常检测和过滤" class="headerlink" title="异常检测和过滤"></a>异常检测和过滤</h2><p>使用 df.describe() 函数查看每一列的描述性统计量 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randn(<span class="number">1000</span>,<span class="number">5</span>)</span><br><span class="line">df = DataFrame(data)</span><br><span class="line">df.describe() </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span> <span class="number">2</span>     <span class="number">3</span><span class="number">4</span></span><br><span class="line">count<span class="number">1000.000000</span><span class="number">1000.000000</span><span class="number">1000.000000</span><span class="number">1000.000000</span><span class="number">1000.000000</span></span><br><span class="line">mean<span class="number">0.019615</span><span class="number">0.008978</span><span class="number">0.002853</span><span class="number">0.014141</span><span class="number">-0.008822</span></span><br><span class="line">std<span class="number">0.988672</span><span class="number">1.013836</span><span class="number">1.010433</span><span class="number">1.020105</span><span class="number">1.023155</span></span><br><span class="line">min<span class="number">-2.842544</span><span class="number">-3.892657</span><span class="number">-2.630116</span><span class="number">-3.175475</span><span class="number">-3.860242</span></span><br><span class="line"><span class="number">25</span>%<span class="number">-0.679723</span><span class="number">-0.656524</span><span class="number">-0.695306</span><span class="number">-0.675029</span><span class="number">-0.665006</span></span><br><span class="line"><span class="number">50</span>%<span class="number">0.025267</span><span class="number">-0.005455</span><span class="number">-0.053128</span><span class="number">-0.030491</span><span class="number">-0.016477</span></span><br><span class="line"><span class="number">75</span>%<span class="number">0.718051</span><span class="number">0.732615</span><span class="number">0.701169</span><span class="number">0.702746</span><span class="number">0.660637</span></span><br><span class="line">max<span class="number">2.832537</span><span class="number">3.205288</span><span class="number">3.456829</span><span class="number">3.537849</span><span class="number">3.125329</span></span><br></pre></td></tr></table></figure><p>使用std()函数可以求得DataFrame对象每一列的标准差 </p><p>根据每一列或行的标准差，对DataFrame元素进行过滤。</p><p>借助any()或all()函数, 测试是否有True，有一个或以上返回True，反之返回False</p><p>对每一列应用筛选条件,去除标准差太大的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 寻找异常数据 太大的 或者 太小的</span><br><span class="line">df.mean() # 各个列的平均值 是一个Series</span><br><span class="line">df - df.mean() # DataFrame - Series DataFrame中的每一行都和Series做减法 对应的列相减</span><br><span class="line">df - df.mean() &gt; 3*df.std()</span><br><span class="line">(df - df.mean() &gt; 3*df.std()).any()</span><br><span class="line">(df - df.mean() &gt; 3*df.std()).any(axis=1)</span><br><span class="line">df[(df - df.mean() &gt; 3*df.std()).any(axis=1)] #找到异常的行</span><br></pre></td></tr></table></figure><p>删除特定索引df.drop(labels,inplace = True) </p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><em>Pandas</em>有两种排序方式，它们分别是 -</p><ul><li>按标签</li><li>按实际值</li></ul><p><strong>按标签排序</strong> </p><p>使用<code>sort_index()</code>方法，通过传递<code>axis</code>参数和排序顺序，可以对<code>DataFrame</code>进行排序。 默认情况下，按照升序对行标签进行排序。</p><p><strong>按列排列</strong> </p><p>通过传递<code>axis</code>参数值为<code>0</code>或<code>1</code>，可以对列标签进行排序。 默认情况下，<code>axis = 0</code>，逐行排列。来看看下面的例子来理解这个概念。</p><p><strong>按值排序</strong> </p><p>像索引排序一样，<code>sort_values()</code>是按值排序的方法。它接受一个<code>by</code>参数，它将使用要与其排序值的<code>DataFrame</code>的列名称。</p><p>排序算法</p><p><code>sort_values()</code>提供了从<code>mergeesort</code>，<code>heapsort</code>和<code>quicksort</code>中选择算法的一个配置。<code>Mergesort</code>是唯一稳定的算法。</p><p><strong>使用.take()函数排序</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- take()函数接受一个索引列表，用数字表示</span><br><span class="line">- eg:df.take([1,3,4,2,5])</span><br></pre></td></tr></table></figure><p>可以借助np.random.permutation()函数随机排序使用.take()函数排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- take()函数接受一个索引列表，用数字表示</span><br><span class="line">- eg:df.take([1,3,4,2,5])</span><br></pre></td></tr></table></figure><p>可以借助np.random.permutation()函数随机排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randint(<span class="number">0</span>,<span class="number">100</span>,size=(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">index = list(<span class="string">'ABCDE'</span>)</span><br><span class="line">columns = list(<span class="string">'甲乙丙丁戊'</span>)</span><br><span class="line">df = DataFrame(data=data,index=index,columns=columns)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">甲  乙   丙  丁 戊</span><br><span class="line">A<span class="number">27</span><span class="number">11</span><span class="number">28</span><span class="number">69</span><span class="number">12</span></span><br><span class="line">B<span class="number">46</span><span class="number">15</span><span class="number">31</span><span class="number">19</span><span class="number">28</span></span><br><span class="line">C<span class="number">22</span><span class="number">76</span><span class="number">3</span><span class="number">17</span><span class="number">98</span></span><br><span class="line">D<span class="number">28</span><span class="number">91</span><span class="number">73</span><span class="number">72</span><span class="number">65</span></span><br><span class="line">E<span class="number">18</span><span class="number">46</span><span class="number">22</span><span class="number">40</span><span class="number">64</span></span><br><span class="line"></span><br><span class="line">df.take([<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]) <span class="comment"># 按照索引去取行 顺序随意 还可以重复 还可以不完全</span></span><br><span class="line">甲  乙   丙  丁 戊</span><br><span class="line">D<span class="number">28</span><span class="number">91</span><span class="number">73</span><span class="number">72</span><span class="number">65</span></span><br><span class="line">D<span class="number">28</span><span class="number">91</span><span class="number">73</span><span class="number">72</span><span class="number">65</span></span><br><span class="line">D<span class="number">28</span><span class="number">91</span><span class="number">73</span><span class="number">72</span><span class="number">65</span></span><br><span class="line">D<span class="number">28</span><span class="number">91</span><span class="number">73</span><span class="number">72</span><span class="number">65</span></span><br><span class="line"></span><br><span class="line">df.take(np.random.permutation(<span class="number">5</span>)) <span class="comment"># 随机排序 （行不会少 也不会重复 只是顺序随机变换）</span></span><br><span class="line"></span><br><span class="line">甲  乙   丙  丁 戊</span><br><span class="line">D<span class="number">28</span><span class="number">91</span><span class="number">73</span><span class="number">72</span><span class="number">65</span></span><br><span class="line">B<span class="number">46</span><span class="number">15</span><span class="number">31</span><span class="number">19</span><span class="number">28</span></span><br><span class="line">A<span class="number">27</span><span class="number">11</span><span class="number">28</span><span class="number">69</span><span class="number">12</span></span><br><span class="line">E<span class="number">18</span><span class="number">46</span><span class="number">22</span><span class="number">40</span><span class="number">64</span></span><br><span class="line">C<span class="number">22</span><span class="number">76</span><span class="number">3</span><span class="number">17</span><span class="number">98</span></span><br></pre></td></tr></table></figure><p><strong>随机抽样</strong> </p><p>当DataFrame规模足够大时，直接使用np.random.randint()函数，就配合take()函数实现随机抽样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">np.random.randint(<span class="number">0</span>,<span class="number">5</span>,size=<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">array([<span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">df.take(np.random.randint(<span class="number">0</span>,<span class="number">5</span>,size=<span class="number">2</span>)) <span class="comment"># 随机抽样</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">甲  乙   丙  丁 戊</span><br><span class="line">D<span class="number">28</span><span class="number">91</span><span class="number">73</span><span class="number">72</span><span class="number">65</span></span><br><span class="line">C<span class="number">22</span><span class="number">76</span><span class="number">3</span><span class="number">17</span><span class="number">98</span></span><br></pre></td></tr></table></figure><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>数据分类处理：</p><ul><li>分组：先把数据分为几组</li><li>用函数处理：为不同组的数据应用不同的函数以转换数据</li><li>合并：把不同组得到的结果合并起来</li></ul><p>数据分类处理的核心：</p><p>​    –  groupby()函数</p><p>​    –  groups属性查看分组情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df = DataFrame(&#123;&apos;item&apos;:[&apos;苹果&apos;,&apos;香蕉&apos;,&apos;橘子&apos;,&apos;香蕉&apos;,&apos;橘子&apos;,&apos;苹果&apos;,&apos;苹果&apos;],</span><br><span class="line">                &apos;price&apos;:[4,3,3,2.5,4,2,2.8],</span><br><span class="line">               &apos;color&apos;:[&apos;red&apos;,&apos;yellow&apos;,&apos;yellow&apos;,&apos;green&apos;,&apos;green&apos;,&apos;green&apos;,&apos;yello&apos;],</span><br><span class="line">               &apos;weight&apos;:[12,20,50,30,20,44,37]&#125;)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">itempricecolorweight</span><br><span class="line">0苹果   4.0   red    12</span><br><span class="line">1香蕉   3.0   yellow20</span><br><span class="line">2橘子   3.0   yellow50</span><br><span class="line">3香蕉   2.5   green30</span><br><span class="line">4橘子   4.0   green20</span><br><span class="line">5苹果   2.0   green44</span><br><span class="line">6苹果   2.8   yello37</span><br></pre></td></tr></table></figure><p>根据item分组,通过groups属性查看结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(&quot;item&quot;).groups</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&#123;&apos;橘子&apos;: Int64Index([2, 4], dtype=&apos;int64&apos;),</span><br><span class="line"> &apos;苹果&apos;: Int64Index([0, 5, 6], dtype=&apos;int64&apos;),</span><br><span class="line"> &apos;香蕉&apos;: Int64Index([1, 3], dtype=&apos;int64&apos;)&#125;</span><br></pre></td></tr></table></figure><p>获取weight的总和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(&quot;item&quot;)[&quot;weight&quot;].sum() #各类水果的总重量</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">item</span><br><span class="line">橘子    70</span><br><span class="line">苹果    93</span><br><span class="line">香蕉    50</span><br><span class="line">Name: weight, dtype: int64</span><br></pre></td></tr></table></figure><h1 id="Matplotlib-1"><a href="#Matplotlib-1" class="headerlink" title="Matplotlib"></a>Matplotlib</h1><p>matplotlib在Python中应用最多的2D图像的绘图工具包，使用matplotlib能够非常简单的可视化数据。在matplotlib中使用最多的模块就是pyplot。pyplot非常接近Matlab的绘图实现，而且大多数的命令及其类似Matlab.当然，与Matlab类似，需要很多的数学运算，因此numpy这个组件同样是必不可少的。所以很多人说python+matplotlib+numpy就是MATLAB。</p><h2 id="一、Matplotlib基础知识"><a href="#一、Matplotlib基础知识" class="headerlink" title="一、Matplotlib基础知识"></a>一、Matplotlib基础知识</h2><p>Matplotlib中的基本图表包括的元素</p><ul><li>x轴和y轴–axis  ， 水平和垂直的轴线</li><li>轴标签–axisLabel  ， 水平和垂直的轴标签</li><li>x轴和y轴刻度–tick  ， 刻度标示坐标轴的分隔，包括最小刻度和最大刻度</li><li>x轴和y轴刻度标签–tick label  ， 表示特定坐标轴的值</li><li>绘图区域（坐标系）–axes  ， 实际绘图的区域</li><li>画布–figure  ， 呈现所有的坐标系</li></ul><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/matplotlib%E5%9B%BE%E5%83%8F%E7%BB%84%E6%88%90.PNG" alt=""></p><h3 id="只含单一曲线的图"><a href="#只含单一曲线的图" class="headerlink" title="只含单一曲线的图"></a>只含单一曲线的图</h3><p>1、可以使用多个plot函数（推荐），在一个图中绘制多个曲线</p><p>2、也可以在一个plot函数中传入多对X,Y值，在一个图中绘制多个曲线</p><h3 id="设置子画布"><a href="#设置子画布" class="headerlink" title="设置子画布"></a>设置子画布</h3><p>axes = plt.subplot()</p><h3 id="网格线"><a href="#网格线" class="headerlink" title="网格线"></a>网格线</h3><p>绘制正弦余弦</p><p>使用plt.grid方法可以开启网格线，使用plt面向对象的方法，创建多个子图显示不同网格线 </p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/grid.png" alt=""></p><ul><li>lw代表linewidth，线的粗细</li><li>alpha表示线的明暗程度</li><li>color代表颜色</li><li>axis显示轴向</li></ul><h3 id="坐标轴界限"><a href="#坐标轴界限" class="headerlink" title="坐标轴界限"></a>坐标轴界限</h3><p>plt.axis([xmin,xmax,ymin,ymax])</p><p>plt.axis(‘xxx’) ‘tight’、’off’、’equal’……</p><p>设置坐标轴类型<br>关闭坐标轴</p><p><strong>xlim方法和ylim方法</strong> </p><p>除了plt.axis方法，还可以通过xlim，ylim方法设置坐标轴范围</p><h3 id="坐标轴标签"><a href="#坐标轴标签" class="headerlink" title="坐标轴标签"></a>坐标轴标签</h3><p>xlabel方法和ylabel方法<br>plt.ylabel(‘y = x^2 + 5’,rotation = 60)旋转</p><ul><li>color 标签颜色</li><li>fontsize 字体大小</li><li>rotation 旋转角度</li></ul><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>plt.title()方法</p><ul><li>loc {left,center,right}</li><li>color 标签颜色</li><li>fontsize 字体大小</li><li>rotation 旋转角度</li></ul><h3 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h3><p><strong>legend方法</strong> </p><p>两种传参方法：</p><ul><li>分别在plot函数中增加label参数,再调用legend()方法显示</li><li>直接在legend方法中传入字符串列表</li></ul><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/legend.png" alt=""></p><h3 id="loc参数"><a href="#loc参数" class="headerlink" title="loc参数"></a>loc参数</h3><ul><li>loc参数用于设置图例标签的位置，一般在legend函数内</li><li>matplotlib已经预定义好几种数字表示的位置</li></ul><table><thead><tr><th>字符串</th><th>数值</th><th>字符串</th><th>数值</th></tr></thead><tbody><tr><td>best</td><td>0</td><td>center left</td><td>6</td></tr><tr><td>upper right</td><td>1</td><td>center right</td><td>7</td></tr><tr><td>upper left</td><td>2</td><td>lower center</td><td>8</td></tr><tr><td>lower left</td><td>3</td><td>upper center</td><td>9</td></tr><tr><td>lower right</td><td>4</td><td>center</td><td>10</td></tr><tr><td>right</td><td>5</td><td></td></tr></tbody></table><p>loc参数可以是2元素的元组，表示图例左下角的坐标</p><ul><li>[0,0] 左下</li><li>[0,1] 左上</li><li>[1,0] 右下</li><li>[1,1] 右上</li></ul><p>图例也可以超过图的界限loc = (-0.1,0.9) </p><h3 id="ncol参数"><a href="#ncol参数" class="headerlink" title="ncol参数"></a>ncol参数</h3><p>ncol控制图例中有几列,在legend中设置ncol,需要设置loc</p><h3 id="linestyle、color、marker"><a href="#linestyle、color、marker" class="headerlink" title="linestyle、color、marker"></a>linestyle、color、marker</h3><p>修改线条样式</p><ul><li>linestyle(ls) 设置线的风格</li><li>linewidth(lw) 设置线宽</li><li>alpha 透明度</li><li>color 颜色</li><li>marker 点形</li><li>markersize 点大小</li><li>markeredagecolor 点的边界颜色</li><li>markeredagewidth 点的边界宽度</li><li>markerfacecolor 点的主体颜色</li></ul><h3 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h3><p>使用figure对象的savefig的函数</p><ul><li>filename<br>含有文件路径的字符串或Python的文件型对象。图像格式由文件扩展名推断得出，例如，.pdf推断出PDF，.png推断出PNG （“png”、“pdf”、“svg”、“ps”、“eps”……）</li><li>dpi<br>图像分辨率（每英寸点数），默认为100</li><li>facecolor<br>图像的背景色，默认为“w”（白色）</li></ul><h2 id="二、设置plot的风格和样式"><a href="#二、设置plot的风格和样式" class="headerlink" title="二、设置plot的风格和样式"></a>二、设置plot的风格和样式</h2><p>plot语句中支持除X,Y以外的参数，以字符串形式存在，来控制颜色、线型、点型等要素，语法形式为：<br>plt.plot(X, Y, ‘format’, …)</p><h3 id="点和线的样式"><a href="#点和线的样式" class="headerlink" title="点和线的样式"></a>点和线的样式</h3><p><strong>颜色</strong> </p><p>参数color或c</p><p><strong>颜色值的方式</strong> </p><p>别名 </p><ul><li>color=’r’</li></ul><p>合法的HTML颜色名 </p><ul><li>color = ‘red’</li></ul><table><thead><tr><th>颜色</th><th>别名</th><th>HTML颜色名</th><th>颜色</th><th>别名</th><th>HTML颜色名</th></tr></thead><tbody><tr><td>蓝色</td><td>b</td><td>blue</td><td>绿色</td><td>g</td><td>green</td></tr><tr><td>红色</td><td>r</td><td>red</td><td>黄色</td><td>y</td><td>yellow</td></tr><tr><td>青色</td><td>c</td><td>cyan</td><td>黑色</td><td>k</td><td>black</td></tr><tr><td>洋红色</td><td>m</td><td>magenta</td><td>白色</td><td>w</td><td>white</td></tr></tbody></table><p> HTML十六进制字符串</p><ul><li>color = ‘#eeefff’</li></ul><p>归一化到[0, 1]的RGB元组</p><ul><li>color = (0.3, 0.3, 0.4)</li></ul><p>jpg png 区别</p><p><strong>透明度</strong> </p><p>alpha参数</p><p><strong>背景色</strong> </p><p>设置背景色，通过plt.subplot()方法传入facecolor参数，来设置坐标系的背景色</p><p><strong>线型</strong> </p><p>参数linestyle或ls</p><table><thead><tr><th>线条风格</th><th>描述</th><th>线条风格</th><th>描述</th></tr></thead><tbody><tr><td>‘-‘</td><td>实线</td><td>‘:’</td><td>虚线</td></tr><tr><td>‘–’</td><td>破折线</td><td>‘steps’</td><td>阶梯线</td></tr><tr><td>‘-.’</td><td>点划线</td><td>‘None’ / ‘，’</td><td>什么都不画</td></tr></tbody></table><p><strong>不同宽度的破折线</strong> </p><p>dashes参数 eg.dashes = [20,50,5,2,10,5]</p><p>设置破折号序列各段的宽度</p><p><strong>点型</strong> </p><ul><li>marker 设置点形</li><li>markersize 设置点形大小</li></ul><table><thead><tr><th>标记</th><th>描述</th><th>标记</th><th>描述</th></tr></thead><tbody><tr><td>‘1’</td><td>一角朝下的三脚架</td><td>‘3’</td><td>一角朝左的三脚架</td></tr><tr><td>‘2’</td><td>一角朝上的三脚架</td><td>‘4’</td><td>一角朝右的三脚架</td></tr></tbody></table><table><thead><tr><th>标记</th><th>描述</th><th>标记</th><th>描述</th></tr></thead><tbody><tr><td>‘s’</td><td>正方形</td><td>‘p’</td><td>五边形</td></tr><tr><td>‘h’</td><td>六边形1</td><td>‘H’</td><td>六边形2</td></tr><tr><td>‘8’</td><td>八边形</td><td></td></tr></tbody></table><table><thead><tr><th>标记</th><th>描述</th><th>标记</th><th>描述</th></tr></thead><tbody><tr><td>‘.’</td><td>点</td><td>‘x’</td><td>X</td></tr><tr><td>‘*’</td><td>星号</td><td>‘+’</td><td>加号</td></tr><tr><td>‘,’</td><td>像素</td><td></td></tr></tbody></table><table><thead><tr><th>标记</th><th>描述</th><th>标记</th><th>描述</th></tr></thead><tbody><tr><td>‘o’</td><td>圆圈</td><td>‘D’</td><td>菱形</td></tr><tr><td>‘d’</td><td>小菱形</td><td>‘’,’None’,’ ‘,None</td><td>无</td></tr></tbody></table><table><thead><tr><th>标记</th><th>描述</th><th>标记</th><th>描述</th></tr></thead><tbody><tr><td>‘_’</td><td>水平线</td><td>‘\</td><td>‘</td><td>竖线</td></tr></tbody></table><table><thead><tr><th>标记</th><th>描述</th><th>标记</th><th>描述</th></tr></thead><tbody><tr><td>‘v’</td><td>一角朝下的三角形</td><td>‘&lt;’</td><td>一角朝左的三角形</td></tr><tr><td>‘^’</td><td>一角朝上的三角形</td><td>‘&gt;’</td><td>一角朝右的三角形</td></tr></tbody></table><p><strong>多参数连用</strong> </p><p>颜色、点型、线型，可以把几种参数写在一个字符串内进行设置 ‘r-.o’</p><p><strong>更多点和线的设置</strong> </p><table><thead><tr><th>参数</th><th>描述</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>color或c</td><td>线的颜色</td><td>linestyle或ls</td><td>线型</td></tr><tr><td>linewidth或lw</td><td>线宽</td><td>marker</td><td>点型</td></tr><tr><td>markeredgecolor</td><td>点边缘的颜色</td><td>markeredgewidth</td><td>点边缘的宽度</td></tr><tr><td>markerfacecolor</td><td>点内部的颜色</td><td>markersize</td><td>点的大小</td></tr></tbody></table><p><strong>多个曲线同一设置</strong> </p><p>属性名声明，不可以多参数连用</p><p>plt.plot(x1, y1, x2, y2, fmt, …)</p><p><strong>多个曲线不同设置</strong> </p><p>多个都进行设置时，多参数连用 plt.plot(x1, y1, fmt1, x2, y2, fmt2, …)</p><p> <strong>三种设置方式</strong> </p><p><strong>向方法传入关键字参数</strong> </p><ul><li>import matplotlib as mpl</li></ul><p><strong>对实例使用一系列的setter方法</strong> </p><ul><li>plt.plot()方法返回一个包含所有线的列表，设置每一个线需要获取该线对象<ul><li>eg: lines = plt.plot();   line = lines[0]</li><li>line.set_linewith()</li><li>line.set_linestyle()</li><li>line.set_color()</li></ul></li></ul><p><strong>对坐标系使用一系列的setter方法</strong> </p><ul><li>axes = plt.subplot()获取坐标系<ul><li>set_title()</li><li>set_facecolor()</li><li>set_xticks、set_yticks 设置刻度值</li><li>set_xticklabels、set_yticklabels  设置刻度名称</li></ul></li></ul><h3 id="X、Y轴坐标刻度"><a href="#X、Y轴坐标刻度" class="headerlink" title="X、Y轴坐标刻度"></a>X、Y轴坐标刻度</h3><p>plt.xticks()和plt.yticks()方法</p><ul><li>需指定刻度值和刻度名称 plt.xticks([刻度列表],[名称列表])</li><li>支持fontsize、rotation、color等参数设置</li></ul><h2 id="三、2D图形"><a href="#三、2D图形" class="headerlink" title="三、2D图形"></a>三、2D图形</h2><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p>【直方图的参数只有一个x！！！不像条形图需要传入x,y】</p><p><code>hist()</code> 的参数</p><ul><li>bins<br>可以是一个bin数量的整数值，也可以是表示bin的一个序列。默认值为10</li><li>normed<br>如果值为True，直方图的值将进行归一化处理，形成概率密度，默认值为False</li><li>color<br>指定直方图的颜色。可以是单一颜色值或颜色的序列。如果指定了多个数据集合，颜色序列将会设置为相同的顺序。如果未指定，将会使用一个默认的线条颜色</li><li>orientation<br>通过设置orientation为horizontal创建水平直方图。默认值为vertical</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randint(0,10,size=100)</span><br><span class="line">display(data)</span><br><span class="line"># horizontal vertical</span><br><span class="line">value = plt.hist(data,bins=10,rwidth=0.9,color=&apos;orange&apos;,orientation=&apos;vertical&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/hist.png" alt=""></p><h3 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h3><p>【条形图有两个参数x,y】</p><ul><li>width 纵向设置条形宽度</li><li>height 横向设置条形高度</li></ul><p><code>bar()</code>横向条形图  、  <code>barh()</code>纵向条形图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 横向条形图</span><br><span class="line"># x index</span><br><span class="line"># height values</span><br><span class="line"># width  条形宽度</span><br><span class="line"># plt.bar(data1.index,data1.values,width=0.9)</span><br><span class="line"></span><br><span class="line"># 纵向条形图</span><br><span class="line"># y index</span><br><span class="line"># width values</span><br><span class="line"># height 条形宽度</span><br><span class="line">plt.barh(data1.index,data1.values,height=0.9)</span><br></pre></td></tr></table></figure><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><p>【饼图也只有一个参数x！】</p><p>pie()<br>饼图适合展示各部分占总体的比例，条形图适合比较各部分的大小</p><p>普通各部分占满饼图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">from pandas import Series,DataFrame</span><br><span class="line"></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.pie([0.3,0.2,0.5])</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/pie1.png" alt=""></p><p>普通未占满饼图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.pie([0.3,0.1,0.5])</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/pie2.png" alt=""></p><p>饼图阴影、分裂等属性设置</p><ul><li>labels参数设置每一块的标签；</li><li>labeldistance参数设置标签距离圆心的距离（比例值,只能设置一个浮点小数）</li><li>autopct参数设置比例值的显示格式(%1.1f%%)；</li><li>pctdistance参数设置比例值文字距离圆心的距离</li><li>explode参数设置每一块顶点距圆形的长度（比例值,列表）；</li><li>colors参数设置每一块的颜色（列表）；</li><li>shadow参数为布尔值，设置是否绘制阴影</li><li>startangle参数设置饼图起始角度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;] # 步骤一（替换sans-serif字体）</span><br><span class="line">plt.rcParams[&apos;axes.unicode_minus&apos;] = False   # 步骤二（解决坐标轴负数的负号显示问题）</span><br><span class="line"></span><br><span class="line">data = [4,2,3,1,1]</span><br><span class="line">values = plt.pie(data,labels=[&apos;小学&apos;,&apos;初中&apos;,&apos;高中&apos;,&apos;大学&apos;,&apos;现在&apos;],labeldistance=0.7,</span><br><span class="line">                autopct=&apos;%.2f%%&apos;,pctdistance=0.5,explode=[0,0,0,0,0.2],</span><br><span class="line">                 colors=[&apos;yellow&apos;,&apos;cyan&apos;,&apos;purple&apos;,&apos;orange&apos;,&apos;blue&apos;],shadow=True,</span><br><span class="line">                startangle=90)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/pie3.png" alt=""></p><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><p>【散点图需要两个参数x,y，但此时x不是表示x轴的刻度，而是每个点的横坐标！】</p><p><code>scatter()</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(0,2*np.pi,20)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.scatter(x,y)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/scatter.png" alt=""></p><h2 id="四、图形内的文字、注释、箭头"><a href="#四、图形内的文字、注释、箭头" class="headerlink" title="四、图形内的文字、注释、箭头"></a>四、图形内的文字、注释、箭头</h2><p>控制文字属性的方法:</p><table><thead><tr><th>pyplot函数</th><th>API方法</th><th>描述</th></tr></thead><tbody><tr><td>text()</td><td>mpl.axes.Axes.text()</td><td>在Axes对象的任意位置添加文字</td></tr><tr><td>xlabel()</td><td>mpl.axes.Axes.set_xlabel()</td><td>为X轴添加标签</td></tr><tr><td>ylabel()</td><td>mpl.axes.Axes.set_ylabel()</td><td>为Y轴添加标签</td></tr><tr><td>title()</td><td>mpl.axes.Axes.set_title()</td><td>为Axes对象添加标题</td></tr><tr><td>legend()</td><td>mpl.axes.Axes.legend()</td><td>为Axes对象添加图例</td></tr><tr><td>figtext()</td><td>mpl.figure.Figure.text()</td><td>在Figure对象的任意位置添加文字</td></tr><tr><td>suptitle()</td><td>mpl.figure.Figure.suptitle()</td><td>为Figure对象添加中心化的标题</td></tr><tr><td>annnotate()</td><td>mpl.axes.Axes.annotate()</td><td>为Axes对象添加注释（箭头可选）</td></tr></tbody></table><p>所有的方法会返回一个matplotlib.text.Text对象</p><h3 id="图形内的文字"><a href="#图形内的文字" class="headerlink" title="图形内的文字"></a>图形内的文字</h3><p>text()</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>annotate()</p><ul><li>xy参数设置箭头指示的位置</li><li>xytext参数设置注释文字的位置</li><li>arrowprops参数以字典的形式设置箭头的样式</li><li>width参数设置箭头长方形部分的宽度</li><li>headlength参数设置箭头尖端的长度，</li><li>headwidth参数设置箭头尖端底部的宽度</li><li>shrink参数设置箭头顶点、尾部与指示点、注释文字的距离（比例值），可以理解为控制箭头的长度</li></ul><h2 id="五、3D图"><a href="#五、3D图" class="headerlink" title="五、3D图"></a>五、3D图</h2><h3 id="曲面图"><a href="#曲面图" class="headerlink" title="曲面图"></a>曲面图</h3><p>导包</p><ul><li>from mpl_toolkits.mplot3d.axes3d import Axes3D</li></ul><p>使用mershgrid函数切割x,y轴</p><ul><li>X,Y = np.meshgrid(x, y)</li></ul><p>创建3d坐标系</p><ul><li>axes = plt.subplot(projection=’3d’)</li></ul><p>绘制3d图形</p><ul><li>p = axes.plot_surface(X,Y,Z,color=’red’,cmap=’summer’,rstride=5,cstride=5)</li></ul><p>添加colorbar</p><ul><li>plt.colorbar(p,shrink=0.5)</li></ul><h3 id="玫瑰图-极坐标条形图"><a href="#玫瑰图-极坐标条形图" class="headerlink" title="玫瑰图/极坐标条形图"></a>玫瑰图/极坐标条形图</h3><p>创建极坐标，设置polar属性</p><ul><li>plt.axes(polar = True)</li></ul><p>绘制极坐标条形图</p><ul><li>index = np.arange(-np.pi,np.pi,2*np.pi/6)</li><li>plt.bar(x=index ,height = [1,2,3,4,5,6] ,width = 2*np.pi/6)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先设置子画布为极坐标画布</span></span><br><span class="line">plt.axes(polar=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 极坐标的索引需要使用弧度表示</span></span><br><span class="line"><span class="comment"># 由于在圆中，起始点和终点是一个点，所以在切分索引时，不要保留最后一个点</span></span><br><span class="line">index = np.linspace(<span class="number">0</span>,<span class="number">2</span>*np.pi,<span class="number">8</span>,endpoint=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">values = np.array([<span class="number">10</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br><span class="line"><span class="comment"># 生成8个不同的颜色 [r,g,b]</span></span><br><span class="line">colors = np.random.random(size=(<span class="number">8</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 扇形区域的半径，表示数值的大小，宽度使用width设置，默认值0.8</span></span><br><span class="line">plt.bar(x=index,height=values,width=<span class="number">0.8</span>,color=colors,align=<span class="string">'edge'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E6%9E%81%E5%9D%90%E6%A0%87%E5%9B%BE.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy,pandas,Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django</title>
      <link href="/2017/12/15/Django/"/>
      <url>/2017/12/15/Django/</url>
      <content type="html"><![CDATA[<h2 id="一、Django简介："><a href="#一、Django简介：" class="headerlink" title="一、Django简介："></a>一、Django简介：</h2><p><a href="https://www.djangoproject.com/" target="_blank" rel="noopener">Django官网地址</a></p><p>Django发布于2005年7月，是当前Python世界里最有名且成熟的网络框架。 最初是被开发用于管理劳伦斯出版集团旗下的以新闻内容为主的网站的，即CMS(内容管理系统)软件。</p><p>Django是一个用Python编写的开放源代码的Web应用框架，代码是开源的。此系统采用了MVC的框架模式, 也可以称为MTV模式</p><a id="more"></a><p><strong>什么是MVC模式</strong> </p><p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 <strong>通俗的来讲就是，强制性的使应用程序的输入，处理和输出分开。</strong></p><p><strong>核心思想</strong>：解耦</p><p><strong>优点</strong>：减低各个模块之间的耦合性，方便变更，更容易重构代码，最大程度的实现了代码的重用</p><p>MVC(Model, View, Controller) Model: 即数据存取层。用于封装于应用程序的业务逻辑相关的数据，以及对数据的处理。说白了就是模型对象负责在数据库中存取数据</p><p>View: 即表现层。负责数据的显示和呈现。渲染的html页面给用户，或者返回数据给用户。</p><p>Controller: 即业务逻辑层。负责从用户端收集用户的输入，进行业务逻辑处理，包括向模型中发送数据，进行CRUD操作。</p><p>图解：<br><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/djaong/mvc.jpg" alt="图"></p><p>浏览器中MVC的表现形式图解:<br><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/djaong/mvc_request_response.png" alt="图"></p><hr><p><strong>Django的模式简介</strong> </p><p><strong>MVT模式</strong> </p><p>严格来说，Django的模式应该是MVT模式，本质上和MVC没什么区别，也是各组件之间为了保持松耦合关系，只是定义上有些许不同。</p><p>Model： 负责业务与数据库(ORM)的对象</p><p>View： 负责业务逻辑并适当调用Model和Template</p><p>Template: 负责把页面渲染展示给用户</p><p>注意： Django中还有一个url分发器，也叫作路由。主要用于将url请求发送给不同的View处理，View在进行相关的业务逻辑处理。</p><h2 id="二、创建Django项目"><a href="#二、创建Django项目" class="headerlink" title="二、创建Django项目"></a>二、创建Django项目</h2><h3 id="window下安装Django"><a href="#window下安装Django" class="headerlink" title="window下安装Django"></a>window下安装Django</h3><p>​    <u>用django-admin创建项目的时候，在macOS上可以不指定路径就在项目目录下就可以了，但是Windows和Linux在命令后面加一个点，指定当前路径  django-admin startproject hello_django . 注意最后面有一个点，这样就不会创建多级路径了</u> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>查看python版本</span><br><span class="line">python --version</span><br><span class="line"><span class="number">2.</span>建虚拟环境,目录名hello_django_venv</span><br><span class="line">python -m venv hello_django_venv</span><br><span class="line"><span class="number">3.</span>激活虚拟环境</span><br><span class="line">cd hello_django_venv</span><br><span class="line">cd Scripts</span><br><span class="line">activate <span class="comment">#激活虚拟环境</span></span><br><span class="line">pip install django[==版本号] </span><br><span class="line"><span class="number">5.</span>查看Django版本(可跳过此步骤)</span><br><span class="line">django-admin --version</span><br><span class="line"><span class="number">6.</span>建项目（在用户目录下）</span><br><span class="line">django-admin startproject hello_djang .</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="number">7.</span>进入项目目录下</span><br><span class="line">cd hello_django</span><br><span class="line"><span class="number">8.</span>启服务器</span><br><span class="line">python manage.py runserver</span><br><span class="line"><span class="number">9.</span>改页面语言</span><br><span class="line">找到项目目录，打开settings.py，</span><br><span class="line">找到LANGUAGE_CODE，更改为LANGUAGE_CODE = <span class="string">'zh-hans'</span></span><br><span class="line"><span class="number">10.</span>建应用hrs</span><br><span class="line">python manage.py startapp hrs</span><br><span class="line"><span class="number">11.</span>打开settings.py，将创建的应用添加到 INSTALLED_APPS 列表中</span><br><span class="line"><span class="number">12.</span>在建的应用文件下(hrs)打开views.py，开始创作</span><br></pre></td></tr></table></figure><h3 id="Linux-Mac-下安装Django"><a href="#Linux-Mac-下安装Django" class="headerlink" title="Linux  /Mac 下安装Django"></a>Linux  /Mac 下安装Django</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.创建项目目录</span><br><span class="line">mkdir hello_django</span><br><span class="line">2.切换到项目目录</span><br><span class="line">cd hello_django/</span><br><span class="line">3.使用venv模块创建虚拟环境，目录名hd_venv</span><br><span class="line">python3 -m venv hd_venv</span><br><span class="line">4.激活虚拟环境</span><br><span class="line">source hd_venv/bin/activate</span><br><span class="line">5.更新pip到最新版本</span><br><span class="line">python -m pip install --upgrade pip</span><br><span class="line">6.使用pip安装django</span><br><span class="line">pip install django</span><br><span class="line">7.通过安装django时安装的脚本工具django-admin检查django版本</span><br><span class="line">django-admin --version</span><br><span class="line">8. 开启一个项目</span><br><span class="line">django-admin startproject hello_django .</span><br></pre></td></tr></table></figure><h3 id="利用virtualenv-创建纯净虚拟环境"><a href="#利用virtualenv-创建纯净虚拟环境" class="headerlink" title="利用virtualenv 创建纯净虚拟环境"></a>利用virtualenv 创建纯净虚拟环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure><p>pip freeze 查看已装过哪些包</p><p>pip install -r xxx.text  安装指定文件中的包</p><h3 id="使用pycharm创建Django项目"><a href="#使用pycharm创建Django项目" class="headerlink" title="使用pycharm创建Django项目"></a>使用pycharm创建Django项目</h3><p>1.点击Create New Project 创建一个新项目 </p><p>2.点击 Django → 选择项目存储路径<br>如果想在创建项目是新建一个应用, 点击More Setting, 输入应用的名称点击 右下角Greate, 创建项目</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/djaong/django1.jpg" alt="django1"></p><h3 id="ubuntu中安装使用"><a href="#ubuntu中安装使用" class="headerlink" title="ubuntu中安装使用"></a>ubuntu中安装使用</h3><ol><li>安装virtualenv</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python-virtualenv</span><br></pre></td></tr></table></figure><ol><li>创建包含python3版本的虚拟环境</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv -p /usr/bin/python3 env</span><br></pre></td></tr></table></figure><p>env代表创建的虚拟环境的名称</p><ol><li>进入/退出env</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入　source env/bin/activate</span><br><span class="line"></span><br><span class="line">退出　deactivate</span><br></pre></td></tr></table></figure><ol><li><p>pip使用</p><p>查看虚拟环境下安装的所有的包　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure><p>查看虚拟环境重通过pip安装的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze</span><br></pre></td></tr></table></figure></li></ol><h3 id="创建一个Django项目"><a href="#创建一个Django项目" class="headerlink" title="创建一个Django项目"></a>创建一个Django项目</h3><p><strong>1. 创建项目</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject halloWorld</span><br></pre></td></tr></table></figure><p>该命令是创建一个名为halloWorld的工程</p><p><strong>项目目录介绍</strong> </p><p>下面展示创建以后的文件，具体有哪些文件： <img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/djaong/django_project.png" alt="图"></p><p>manage.py： 是Django用于管理本项目的管理集工具，之后站点运行，数据库自动生成，数据表的修改等都是通过该文件完成。</p><p><strong>init</strong>.py： 指明该目录结构是一个python包，暂无内容，在后期会初始化一些工具会使用到。</p><p>seetings.py： Django项目的配置文件，其中定义了本项目的引用组件，项目名，数据库，静态资源，调试模式，域名限制等</p><p>urls.py：项目的URL路由映射，实现客户端请求url由哪个模块进行响应。</p><p>wsgi.py：定义WSGI接口信息，通常本文件生成后无需改动</p><p><strong>运行Django项目</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver 端口</span><br></pre></td></tr></table></figure><p>该命令是运行项目，端口可以不用写，启动的时候会默认随机创建一个可以使用的端口</p><p><strong>2. 创建app</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp hallo_app</span><br></pre></td></tr></table></figure><p>该命令是在blog工程下创建一个名为hallo_app的app</p><p><strong>3. settings.py配置文件详细解读</strong> </p><p>a) 设置语言：</p><p>LANGUAGE_CODE = ‘zh-hans’ 表示中文 LANGUAGE_CODE = ‘en-us’ 表示英文</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/djaong/django_zh.png" alt="图"></p><p>设置时区：    TIME_ZONE = ‘Asia/Shanghai’</p><p>b) 时区解释： (需要详细回顾思考时区问题)</p><p>UTC：世界标准时间，也就是平常说的零时区。 北京时间表示东八区时间，即UTC+8</p><h2 id="三、配置Django项目"><a href="#三、配置Django项目" class="headerlink" title="三、配置Django项目"></a>三、配置Django项目</h2><h3 id="1-创建的应用"><a href="#1-创建的应用" class="headerlink" title="1.创建的应用"></a>1.创建的应用</h3><p>python manager.py startapp cars</p><p>   执行上面的命令会在当前路径下创建hrs目录，其目录结构如下所示：</p><ul><li><code>__init__.py</code>：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。</li><li><code>admin.py</code>：可以用来注册模型，让Django自动创建管理界面。</li><li><code>apps.py</code>：当前应用的配置。</li><li><code>migrations</code>：存放与模型有关的数据库迁移信息。</li><li><code>models.py</code>：存放应用的数据模型，即实体类及其之间的关系（MVC/MVT中的M）。</li><li><code>tests.py</code>：包含测试应用各项功能的测试类和测试函数。</li><li><code>views.py</code>：处理请求并返回响应的函数（MVC中的C，MVT中的V）。</li></ul><p>setting.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 添加应用配置</span><br><span class="line"># 每新建一个应用就要添加一个</span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &apos;cars.apps.CarsConfig&apos;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="2-创建数据库"><a href="#2-创建数据库" class="headerlink" title="2.创建数据库"></a>2.创建数据库</h3><p>创建名为cars的数据库, 并指定utf8字符集</p><h3 id="3-配置数据库"><a href="#3-配置数据库" class="headerlink" title="3.配置数据库"></a>3.配置数据库</h3><p>项目文件下settings.py里</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'cars'</span>, <span class="comment"># 与数据库名称对应</span></span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'localhost'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目文件夹下  __init__.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="comment">#把pymysql方式当成是mysqldb一样使用</span></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure><h3 id="4-创建模型"><a href="#4-创建模型" class="headerlink" title="4.创建模型"></a>4.创建模型</h3><p>models.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    no = models.AutoField(primary_key=<span class="keyword">True</span>,verbose_name=<span class="string">'编号'</span>)</span><br><span class="line">    car_no = models.CharField(max_length=<span class="number">7</span>, verbose_name=<span class="string">'车牌号'</span>)</span><br><span class="line">    cause = models.CharField(max_length=<span class="number">100</span>, verbose_name=<span class="string">'违章原因'</span>)</span><br><span class="line">    date = models.DateTimeField(auto_now_add=<span class="keyword">True</span>, verbose_name=<span class="string">'违章日期'</span>,db_column=<span class="string">'happen_date'</span>)</span><br><span class="line">    way = models.CharField(max_length=<span class="number">100</span>, verbose_name=<span class="string">'处罚方式'</span>)</span><br><span class="line">    dispose = models.BooleanField(default=<span class="keyword">False</span>, verbose_name=<span class="string">'是否受理'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">    db_table = <span class="string">'tb_car_record'</span></span><br><span class="line">    verbose_name_plural = <span class="string">'违章记录'</span></span><br><span class="line">    ordering = (<span class="string">'no'</span>, )</span><br></pre></td></tr></table></figure><h3 id="5-迁移数据库"><a href="#5-迁移数据库" class="headerlink" title="5.迁移数据库"></a>5.迁移数据库</h3><ul><li>python manage.py makemigrations 应用名<br>记录我们对models.py的所有改动，并且将这个改动迁移到migrations这个文件下生成一个文件 </li><li>python manage.py migrate<br>把改动作用到数据库 </li></ul><p><em>清空数据库</em><br><em>python manage.py flush</em><br>    <em>[此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表]</em> </p><h3 id="6-创建管理员"><a href="#6-创建管理员" class="headerlink" title="6.创建管理员"></a>6.创建管理员</h3><p>python manage.py createsuperuser<br>配置 Username / Email address / Password</p><h3 id="7-配置管理员界面"><a href="#7-配置管理员界面" class="headerlink" title="7. 配置管理员界面"></a>7. 配置管理员界面</h3><p>admin.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> cars.models <span class="keyword">import</span> Record</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecordAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    <span class="comment"># 添加管理员页面需要显示的列</span></span><br><span class="line">    list_display = (<span class="string">'no'</span>, <span class="string">'car_no'</span>, <span class="string">'cause'</span>, <span class="string">'date'</span>, <span class="string">'way'</span>, <span class="string">'dispose'</span>)</span><br><span class="line">    <span class="comment"># 指定搜索列</span></span><br><span class="line">    search_fields = (<span class="string">'car_no'</span>,)</span><br><span class="line">    <span class="comment"># 指定排序方式</span></span><br><span class="line">    ordering = (<span class="string">'no'</span>,)</span><br><span class="line">admin.site.register(Record, RecordAdmin)</span><br></pre></td></tr></table></figure><h3 id="8-创建视图文件夹-templates-静态文件夹-static-与应用-项目目录同级"><a href="#8-创建视图文件夹-templates-静态文件夹-static-与应用-项目目录同级" class="headerlink" title="8.创建视图文件夹 templates / 静态文件夹 static (与应用/项目目录同级)"></a>8.创建视图文件夹 templates / 静态文件夹 static (与应用/项目目录同级)</h3><p>|— cars</p><p>|— static (存放静态文件 css / js / jQuery)</p><p>|— templates (存放html页面, 使用pycharm创建项目会自动添加)</p><p>setting.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加static文件夹路径,os.path.join路径拼接</span></span><br><span class="line">STATICFILES_DIRS = [os.path.join(BASE_DIR, <span class="string">'static'</span>)]</span><br></pre></td></tr></table></figure><p>如果使用命令行创建Django项目</p><p>还需要在setting.py中添加如下配置:</p><p> ‘DIRS’: [os.path.join(BASE_DIR, ‘templates’)]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="comment"># 添加templates文件夹路径</span></span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="string">'templates'</span>)]</span><br><span class="line">        ,</span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="keyword">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,</span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="9-修改视图文件views-py"><a href="#9-修改视图文件views-py" class="headerlink" title="9.修改视图文件views.py"></a>9.修改视图文件views.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'&lt;h1&gt;Hello, Django!&lt;/h1&gt;'</span>)</span><br></pre></td></tr></table></figure><h3 id="10-映射URL"><a href="#10-映射URL" class="headerlink" title="10.映射URL"></a>10.映射URL</h3><p>应用目录创建一个urls.py文件并映射URL<br>切换到项目目录，修改该目录下的urls.py文件，对应用中设定的URL进行合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> hrs <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, views.index, name=<span class="string">'index'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'hrs/'</span>, include(<span class="string">'hrs.urls'</span>)),</span><br></pre></td></tr></table></figure><p><strong>python manage.py shell 增删改查操作</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">python manage.py shell</span><br><span class="line"><span class="keyword">from</span> hrs.models <span class="keyword">import</span> Dept, Emp</span><br><span class="line"><span class="comment">#添加数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dept = Dept(dno=<span class="string">'16'</span>,name=<span class="string">'研发部'</span>,location=<span class="string">'小溪坝'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dept.save()</span><br><span class="line"><span class="comment">#删数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dept.objects.filter(dno=<span class="string">'16'</span>).delete()</span><br><span class="line"><span class="comment">#更改数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dept.objects.filter(dno=<span class="string">'16'</span>).update(name=<span class="string">'销售部'</span>)</span><br><span class="line"><span class="comment">#查询数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dept.objects.all()   <span class="comment">#查所有</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dept.objects.all().values(<span class="string">'location'</span>)<span class="comment">#查询指定列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dept.objects.get(dno=<span class="number">16</span>) </span><br><span class="line"><span class="comment">#过滤数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dept.objects.filter(name=<span class="string">'研发3部'</span>) <span class="comment"># 查询部门名称为“研发3部”的部门</span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发<span class="number">3</span>部&gt;]&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dept.objects.filter(name__contains=<span class="string">'研发'</span>) <span class="comment"># 查询部门名称包含“研发”的部门(模糊查询)</span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发<span class="number">1</span>部&gt;, &lt;Dept: 研发<span class="number">3</span>部&gt;]&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dept.objects.filter(no__gt=<span class="number">10</span>).filter(no__lt=<span class="number">40</span>) <span class="comment"># 查询部门编号大于10小于40的部门</span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 销售<span class="number">1</span>部&gt;, &lt;Dept: 运维<span class="number">1</span>部&gt;]&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dept.objects.filter(no__range=(<span class="number">10</span>, <span class="number">30</span>)) <span class="comment"># 查询部门编号在10到30之间的部门</span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发<span class="number">1</span>部&gt;, &lt;Dept: 销售<span class="number">1</span>部&gt;, &lt;Dept: 运维<span class="number">1</span>部&gt;]&gt;</span><br><span class="line">all() / filter()  --&gt; QuerySet</span><br><span class="line">QuerySet使用了惰性查询 - 如果不是非得取到数据那么不会发出SQL语句</span><br><span class="line">这样就是为了节省服务器内存的开销 - 延迟加载 - 节省空间势必浪费时间</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Web框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flask</title>
      <link href="/2017/12/15/Flask%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/12/15/Flask%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="1、flask介绍"><a href="#1、flask介绍" class="headerlink" title="1、flask介绍"></a>1、flask介绍</h2><p>Flask是一个基于Python实现的web开发的’微’框架</p><p> <a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="noopener">中文文档地址</a> </p><p>flask流行的主要原因：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a）有非常齐全的官方文档，上手非常方便</span><br><span class="line">b) 有非常好的拓展机制和第三方的拓展环境，工作中常见的软件都有对应的拓展，自己动手实现拓展也很容易</span><br><span class="line">c) 微型框架的形式给了开发者更大的选择空间</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="安装flask"><a href="#安装flask" class="headerlink" title="安装flask"></a>安装flask</h3><h4 id="虚拟环境搭建"><a href="#虚拟环境搭建" class="headerlink" title="虚拟环境搭建"></a>虚拟环境搭建</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pip instatll virtualenv</span><br><span class="line">virtualenv --no-site-packages falskenv</span><br><span class="line"></span><br><span class="line">激活windows下虚拟环境</span><br><span class="line">cd Scripts</span><br><span class="line">activate</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask</span><br></pre></td></tr></table></figure><h3 id="基于flask的最小的应用"><a href="#基于flask的最小的应用" class="headerlink" title="基于flask的最小的应用"></a>基于flask的最小的应用</h3><p>创建hello.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gello_world</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'Hello World'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><p>运行：python hello.py</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br></pre></td></tr></table></figure><p>Flask类构造函数唯一需要的参数就是应用程序的主模块或包。对于大多数应用程序，Python的<strong>name</strong>变量就是那个正确的、你需要传递的值。Flask使用这个参数来确定应用程序的根目录，这样以后可以相对这个路径来找到资源文件。</p><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br></pre></td></tr></table></figure><p>客户端例如web浏览器发送 请求 给web服务，进而将它们发送给Flask应用程序实例。应用程序实例需要知道对于各个URL请求需要运行哪些代码，所以它给Python函数建立了一个URLs映射。这些在URL和函数之间建立联系的操作被称之为 路由 。</p><p>在Flask应程序中定义路由的最便捷的方式是通过显示定义在应用程序实例之上的app.route装饰器，注册被装饰的函数来作为一个 <strong>路由</strong>。</p><h4 id="视图函数"><a href="#视图函数" class="headerlink" title="视图函数"></a>视图函数</h4><p>在上一个示例给应用程序的根URL注册gello_world()函数作为事件的处理程序。如果这个应用程序被部署在服务器上并绑定了 <a href="http://www.example.com/" target="_blank" rel="noopener">www.example.com</a> 域名，然后在你的浏览器地址栏中输入 <a href="http://www.example.com/" target="_blank" rel="noopener">http://www.example.com</a> 将触发gello_world()来运行服务。客户端接收到的这个函数的返回值被称为 响应 。如果客户端是web浏览器，响应则是显示给用户的文档。</p><p>类似于gello_world()的函数被称作 <strong>视图函数</strong> 。</p><h4 id="动态名称组件路由"><a href="#动态名称组件路由" class="headerlink" title="动态名称组件路由"></a>动态名称组件路由</h4><p>你的Facebook个人信息页的URL是 <a href="http://www.facebook.com/" target="_blank" rel="noopener">http://www.facebook.com/</a> ，所以你的用户名是它的一部分。Flask在路由装饰器中使用特殊的语法支持这些类型的URLs。下面的示例定义了一个拥有动态名称组件的路由：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/hello/&lt;name&gt;')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gello_world</span><span class="params">(name)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">'Hello World %s'</span> % name</span><br></pre></td></tr></table></figure><p>用尖括号括起来的部分是动态的部分，所以任何URLs匹配到静态部分都将映射到这个路由。当视图函数被调用，Flask发送动态组件作为一个参数。在前面的示例的视图函数中，这个参数是用于生成一个个性的问候作为响应。</p><p>在路由中动态组件默认为字符串，但是可以定义为其他类型。例如，路由/user/int:id只匹配有一个整数在id动态段的URLs。Flask路由支持int、float</p><p>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/hello/&lt;int:id&gt;')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gello_stu_id</span><span class="params">(id)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello World id: %s'</span> % id</span><br></pre></td></tr></table></figure><h4 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><p>注意： <strong>name</strong> == ‘<strong>main</strong>‘在此处使用是用于确保web服务已经启动当脚本被立即执行。当脚本被另一个脚本导入，它被看做父脚本将启动不同的服务，所以app.run()调用会被跳过。</p><p>一旦服务启动，它将进入循环等待请求并为之服务。这个循环持续到应用程序停止，例如通过按下Ctrl-C。</p><p>有几个选项参数可以给app.run()配置web服务的操作模式。在开发期间，可以很方便的开启debug模式，将激活 debugger 和 reloader 。这样做是通过传递debug为True来实现的。</p><p>run()中参数有如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">debug 是否开启调试模式，开启后修改python的代码会自动重启</span><br><span class="line"></span><br><span class="line">port 启动指定服务器的端口号</span><br><span class="line"></span><br><span class="line">host主机，默认是127.0.0.1</span><br></pre></td></tr></table></figure><h3 id="修改启动方式"><a href="#修改启动方式" class="headerlink" title="修改启动方式"></a>修改启动方式</h3><p>修改启动方式，使用命令行参数启动服务</p><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-script</span><br></pre></td></tr></table></figure><p>调整代码 manager = Manager(app=‘自定义的flask对象’)</p><p>启动的地方 manager.run()</p><h4 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python hellow.py runserver -h 地址 -p 端口 -d -r</span><br></pre></td></tr></table></figure><p>其中：-h表示地址。-p表示端口。-d表示debug模式。-r表示自动重启</p><h3 id="route规则"><a href="#route规则" class="headerlink" title="route规则"></a>route规则</h3><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>写法：converter:variable_name</p><p>converter类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string 字符串</span><br><span class="line">int 整形</span><br><span class="line">float 浮点型</span><br><span class="line">path 接受路径，接收的时候是str，/也当做字符串的一个字符</span><br><span class="line">uuid 只接受uuid字符串</span><br><span class="line">any 可以同时指定多种路径，进行限定</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/helloint/&lt;int:id&gt;/&apos;)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/getfloat/&lt;float:price&gt;/&apos;)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/getstr/&lt;string:name&gt;/&apos;，methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/getpath/&lt;path:url_path&gt;/&apos;)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/getbyuuid/&lt;uuid:uu&gt;/&apos;，methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br></pre></td></tr></table></figure><p>实现对应的视图函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@blue.route('/hello/&lt;name&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_man</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(type(name))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello name:%s type:%s'</span> % (name, type(name))</span><br><span class="line"></span><br><span class="line"><span class="meta">@blue.route('/helloint/&lt;int:id&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_int</span><span class="params">(id)</span>:</span></span><br><span class="line">    print(id)</span><br><span class="line">    print(type(id))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello int: %s'</span> % (id)</span><br><span class="line"></span><br><span class="line"><span class="meta">@blue.route('/index/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'hello.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@blue.route('/getfloat/&lt;float:price&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_float</span><span class="params">(price)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'float: %s'</span> % price</span><br><span class="line"></span><br><span class="line"><span class="meta">@blue.route('/getstr/&lt;string:name&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_name</span><span class="params">(name)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello name: %s'</span> % name</span><br><span class="line"></span><br><span class="line"><span class="meta">@blue.route('/getpath/&lt;path:url_path&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_path</span><span class="params">(url_path)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'path: %s'</span> % url_path</span><br><span class="line"></span><br><span class="line"><span class="meta">@blue.route('/getuuid/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gello_get_uuid</span><span class="params">()</span>:</span></span><br><span class="line">    a = uuid.uuid4()</span><br><span class="line">    <span class="keyword">return</span> str(a)</span><br><span class="line"></span><br><span class="line"><span class="meta">@blue.route('/getbyuuid/&lt;uuid:uu&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_uuid</span><span class="params">(uu)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'uu:%s'</span> % uu</span><br></pre></td></tr></table></figure><h4 id="methods请求方法"><a href="#methods请求方法" class="headerlink" title="methods请求方法"></a>methods请求方法</h4><p>常用的请求类型有如下几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET : 获取</span><br><span class="line">POST : 创建</span><br><span class="line">PUT : 修改(全部属性都修改)</span><br><span class="line">DELETE : 删除</span><br><span class="line">PATCH : 修改(修改部分属性)</span><br></pre></td></tr></table></figure><p>定义url的请求类型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@blue.route(&apos;/getrequest/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br></pre></td></tr></table></figure><h2 id="2、蓝图"><a href="#2、蓝图" class="headerlink" title="2、蓝图"></a>2、蓝图</h2><h3 id="什么是蓝图"><a href="#什么是蓝图" class="headerlink" title="什么是蓝图"></a>什么是蓝图</h3><p>在Flask项目中可以用Blueprint(蓝图)实现模块化的应用，使用蓝图可以让应用层次更清晰，开发者更容易去维护和开发项目。蓝图将作用于相同的URL前缀的请求地址，将具有相同前缀的请求都放在一个模块中，这样查找问题，一看路由就很快的可以找到对应的视图，并解决问题了。</p><h3 id="使用蓝图"><a href="#使用蓝图" class="headerlink" title="使用蓝图"></a>使用蓝图</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask_blueprint</span><br></pre></td></tr></table></figure><h4 id="实例化蓝图应用"><a href="#实例化蓝图应用" class="headerlink" title="实例化蓝图应用"></a>实例化蓝图应用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blue = Blueprint(&apos;first&apos;，__name__)</span><br></pre></td></tr></table></figure><p>注意：<u>Blueprint中传入了两个参数，第一个是蓝图的名称，第二个是蓝图所在的包或模块，<strong>name</strong>代表当前模块名或者包名</u></p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">app.register_blueprint(blue, url_prefix=&apos;/user&apos;)</span><br></pre></td></tr></table></figure><p>注意：<strong><u>第一个参数即我们定义初始化定义的蓝图对象，第二个参数url_prefix表示该蓝图下，所有的url请求必须以/user开始</u></strong>。这样对一个模块的url可以很好的进行统一管理</p><h4 id="使用蓝图-1"><a href="#使用蓝图-1" class="headerlink" title="使用蓝图"></a>使用蓝图</h4><p>修改视图上的装饰器，修改为@blue.router(‘/’)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@blue.route('/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 视图函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><p>注意：该方法对应的url为127.0.0.1:5000/user/</p><h4 id="url-for反向解析"><a href="#url-for反向解析" class="headerlink" title="url_for反向解析"></a>url_for反向解析</h4><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_for(&apos;蓝图中定义的第一个参数.函数名&apos;, 参数名=value)</span><br></pre></td></tr></table></figure><p>定义跳转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from flask import url_for, redirect</span><br><span class="line"></span><br><span class="line">@blue.route(&apos;/redirect/&apos;)</span><br><span class="line">def make_redirect():</span><br><span class="line">    # 第一种方法</span><br><span class="line">    return redirect(&apos;/hello/index/&apos;)</span><br><span class="line">    # 第二种方法</span><br><span class="line">    return redirect(url_for(&apos;first.index&apos;))</span><br></pre></td></tr></table></figure><h2 id="3、访问请求数据"><a href="#3、访问请求数据" class="headerlink" title="3、访问请求数据"></a>3、访问请求数据</h2><h3 id="请求request"><a href="#请求request" class="headerlink" title="请求request"></a>请求request</h3><p>服务端在接收到客户端的请求后，会自动创建Request对象</p><p>由Flask框架创建，Requesy对象不可修改</p><p>属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">url：完整的请求地址</span><br><span class="line">base_url：去掉GET参数的url</span><br><span class="line">host_url：只有主机和端口号的url</span><br><span class="line">path：路由中的路径</span><br><span class="line">method：请求方法</span><br><span class="line">remote_addr：请求的客户端的地址</span><br><span class="line">args：GET请求参数</span><br><span class="line">form：POST请求参数</span><br><span class="line">files：文件上传</span><br><span class="line">headers：请求头</span><br><span class="line">cookies：请求中的cookie</span><br></pre></td></tr></table></figure><h4 id="args–-gt-GET请求参数包装"><a href="#args–-gt-GET请求参数包装" class="headerlink" title="args–&gt;GET请求参数包装"></a>args–&gt;GET请求参数包装</h4><p>a）args是get请求参数的包装，args是一个ImmutableMultiDict对象，类字典结构对象</p><p>b）数据存储也是key-value</p><h4 id="form–-gt-POST请求参数包装"><a href="#form–-gt-POST请求参数包装" class="headerlink" title="form–&gt;POST请求参数包装"></a>form–&gt;POST请求参数包装</h4><p>a）form是post请求参数的包装，args是一个ImmutableMultiDict对象，类字典结构对象</p><p>b）数据存储也是key-value</p><p>重点：ImmutableMultiDict是类似字典的数据结构，但是与字典的区别是，可以存在相同的键。在ImmutableMultiDict中获取数据的方式，dict[‘key’]或者dict.get(‘key’)或者dict.getlist(‘key’)</p><h3 id="响应Response"><a href="#响应Response" class="headerlink" title="响应Response"></a>响应Response</h3><p>Response是由开发者自己创建的</p><p>创建方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from flask import make_response</span><br><span class="line"></span><br><span class="line">make_response创建一个响应，是一个真正的Response对象</span><br></pre></td></tr></table></figure><p>状态码：</p><p>格式：make_reponse(data，code)，其中data是返回的数据内容，code是状态码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a）直接将内容当做make_response的第一个参数，第二个参数直接写返回的状态码</span><br><span class="line"></span><br><span class="line">b）直接在render后加返回的状态码</span><br></pre></td></tr></table></figure><p>例子1：</p><p>定义一个获取GET请求的request的方法，并将返回成功的请求的状态码修改为200</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@blue.route('/getrequest/', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_request</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'获取request'</span>, <span class="number">200</span></span><br></pre></td></tr></table></figure><p>例子2：</p><p>返回response响应，并添加返回结果的状态码200</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@blue.route('/getresponse/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">()</span>:</span></span><br><span class="line">    response = make_response(<span class="string">'&lt;h2&gt;我是响应&lt;/h2&gt;'</span>, <span class="number">500</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h3 id="重定向-反向解析"><a href="#重定向-反向解析" class="headerlink" title="重定向/反向解析"></a>重定向/反向解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_for(<span class="string">'蓝图定义的名称.方法名'</span>)</span><br></pre></td></tr></table></figure><p>例子1:</p><p>定义跳转方法，跳转到get_response的方法上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@blue.route('/getredirect/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_redirect</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">'getresponse'</span>)</span><br></pre></td></tr></table></figure><p>例子2：</p><p>使用url_for反向解析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> redirect, url_for</span><br><span class="line"></span><br><span class="line"><span class="meta">@blue.route('/getredirect/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_redirect</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">'first.get_response'</span>))</span><br></pre></td></tr></table></figure><h3 id="终止-异常捕获"><a href="#终止-异常捕获" class="headerlink" title="终止/异常捕获"></a>终止/异常捕获</h3><p>自动抛出异常：abort(状态码)</p><p>捕获异常处理：errorhandler(状态码)，定义的函数中要包含一个参数，用于接收异常信息</p><h4 id="定义终止程序"><a href="#定义终止程序" class="headerlink" title="定义终止程序"></a>定义终止程序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@blue.route('/make_abort/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_abort</span><span class="params">()</span>:</span></span><br><span class="line">    abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'终止'</span></span><br></pre></td></tr></table></figure><h4 id="捕获定义的异常"><a href="#捕获定义的异常" class="headerlink" title="捕获定义的异常"></a>捕获定义的异常</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@blue.errorhandler(400)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(exception)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'捕获到异常信息:%s'</span> % exception</span><br></pre></td></tr></table></figure><h2 id="4、session与cookie"><a href="#4、session与cookie" class="headerlink" title="4、session与cookie"></a>4、session与cookie</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>访问者的标识问题服务器需要识别来自同一访问者的请求。这主要是通过浏览器的cookie实现的。 访问者在第一次访问服务器时，服务器在其cookie中设置一个唯一的ID号——会话ID(session)。 这样，访问者后续对服务器的访问头中将自动包含该信息，服务器通过这个ID号，即可区 隔不同的访问者。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a）客户端会话技术，浏览器的会话技术</span><br><span class="line"></span><br><span class="line">b）数据全部存储在客户端中</span><br><span class="line"></span><br><span class="line">c）存储使用的键值对结构进行存储</span><br><span class="line"></span><br><span class="line">特性：</span><br><span class="line">支持过期时间</span><br><span class="line">默认会自动携带本网站的cookie</span><br><span class="line">不能跨域名</span><br><span class="line">不能跨浏览器</span><br></pre></td></tr></table></figure><p>创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cookie是通过服务器创建的Response来创建的</span><br><span class="line"></span><br><span class="line">设置：set_cookie(&apos;key&apos;, value, max_ages=&apos;&apos;, expires=&apos;&apos;)</span><br><span class="line"></span><br><span class="line">删除, 有三种删除方式</span><br><span class="line"></span><br><span class="line">1. 直接清空浏览器的cookie</span><br><span class="line">2. del_cookie(&apos;key&apos;) 直接使用del_cookie函数</span><br><span class="line">3. set_cookie(&apos;key&apos;,&apos;&apos;,expires=0) 重新设置key的值为空，过期时间为0</span><br></pre></td></tr></table></figure><p>获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在每次请求中，url都会向服务器传递Request，在request中可以获取到cookie的信息</span><br><span class="line"></span><br><span class="line">request.cookies.get(&apos;name&apos;)</span><br></pre></td></tr></table></figure><p>例子1，设置cookie：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">@blue.route(&apos;/setcookie/&apos;)</span><br><span class="line">def set_cookie():</span><br><span class="line">    temp = render_template(&apos;index.html&apos;)</span><br><span class="line">    response = make_response(temp)</span><br><span class="line">outdate=datetime.datetime.today() + datetime.timedelta(days=30)</span><br><span class="line"># 设置cookie中的name的存在时长，设置为30天才过期  </span><br><span class="line">    response.set_cookie(&apos;name&apos;,&apos;cocoococo&apos;,expires=outdate)</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure><p>例子2，删除cookie中的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@blue.route(&apos;/setcookie/&apos;)</span><br><span class="line">def set_cookie():</span><br><span class="line">    temp = render_template(&apos;index.html&apos;)</span><br><span class="line">    response = make_response(temp)</span><br><span class="line"># 第一种方式，通过set_cookie去删除</span><br><span class="line">    response.set_cookie(&apos;name&apos;,&apos;&apos;,expires=0)</span><br><span class="line"># 第二种方式，del_cookie删除</span><br><span class="line">response.del_cookie(&apos;name&apos;)</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure><p>例子3，获取cookie中的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@blue.route(&apos;/getcookie/&apos;)  </span><br><span class="line">def get_cookie():</span><br><span class="line">    name=request.cookies.get(&apos;name&apos;)  </span><br><span class="line">    return name</span><br></pre></td></tr></table></figure><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>flask-session是flask框架的session组件</p><p>该组件则将支持session保存到多个地方</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis：保存数据的一种工具，五大类型。非关系型数据库</span><br><span class="line"></span><br><span class="line">memcached</span><br><span class="line"></span><br><span class="line">mongodb</span><br><span class="line"></span><br><span class="line">sqlalchmey：那数据存到数据库表里面</span><br></pre></td></tr></table></figure><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-session</span><br></pre></td></tr></table></figure><p>如果指定存session的类型为redis的话，需要安装redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>设置session：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session[&apos;key&apos;] = value</span><br></pre></td></tr></table></figure><p>读取session：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = session[&apos;key&apos;] ：如果内容不存在，将会报异常</span><br><span class="line"></span><br><span class="line">result = session.get(&apos;key&apos;) ：如果内容不存在，将返回None</span><br></pre></td></tr></table></figure><p>删除session：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.pop(&apos;key&apos;)</span><br></pre></td></tr></table></figure><p>清空session中所有数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.clear</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>我们在初始化文件中创建一个方法，通过调用该方法来获取到Flask的app对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def create_app():</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    # SECRET_KEY 秘钥</span><br><span class="line">    app.config[&apos;SECRET_KEY&apos;] = &apos;secret_key&apos;</span><br><span class="line"># session类型为redis</span><br><span class="line">    app.config[&apos;SESSION_TYPE&apos;] = &apos;redis&apos;</span><br><span class="line"># 添加前缀</span><br><span class="line">app.config[&apos;SESSION_KEY_PREFIX&apos;] = &apos;flask&apos;</span><br><span class="line">    </span><br><span class="line">    # 加载app的第一种方式</span><br><span class="line">    se = Session()</span><br><span class="line">    se.init_app(app=app)</span><br><span class="line">    #加载app的第二种方式</span><br><span class="line">    Session(app=app)</span><br><span class="line">    app.register_blueprint(blueprint=blue)</span><br><span class="line"></span><br><span class="line">    return app</span><br></pre></td></tr></table></figure><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>定义一个登陆的方法，post请求获取到username，直接写入到redis中，并且在页面中展示出redis中的username</p><p>a）需要先启动redis，开启redis-server，使用redis-cli进入客户端</p><p>b）定义方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@blue.route(&apos;/login/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br><span class="line">def login():</span><br><span class="line">    if request.method == &apos;GET&apos;:</span><br><span class="line">        username = session.get(&apos;username&apos;)</span><br><span class="line">        return render_template(&apos;login.html&apos;, username=username)</span><br><span class="line">    else:</span><br><span class="line">        username = request.form.get(&apos;username&apos;)</span><br><span class="line">        session[&apos;username&apos;] = username</span><br><span class="line"></span><br><span class="line">        return redirect(url_for(&apos;first.login&apos;))</span><br></pre></td></tr></table></figure><p>c）定义模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;欢迎:&#123;&#123; username &#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;请输入你的名字&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>d）redis中数据</p><p><img src="https://github.com/shuaixiaohao/shuaixiaohao.github.io/blob/master/images/blog-image/flask_session_keys.png?raw=true" alt=""></p><p>注意：我们在定义app.config的时候指定了SESSION_KEY_PREFIX为flask，表示存在session中的key都会加一个前缀名flask </p><p>e)  cookie和session的联系</p><p><img src="https://github.com/shuaixiaohao/shuaixiaohao.github.io/blob/master/images/blog-image/flask_cookie_session.png?raw=true" alt=""></p><p>访问者在第一次访问服务器时，服务器在其cookie中设置一个唯一的ID号——会话ID(session)。 这样，访问者后续对服务器的访问头中将自动包含该信息，服务器通过这个ID号，即可区 隔不同的访问者。然后根据不同的访问者来获取其中保存的value值信息。 </p><h2 id="4、模板"><a href="#4、模板" class="headerlink" title="4、模板"></a>4、模板</h2><h3 id="jinja2"><a href="#jinja2" class="headerlink" title="jinja2"></a>jinja2</h3><p>Flask中使用jinja2模板引擎</p><p>jinja2是由Flask作者开发，模仿Django的模板引擎</p><p>优点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">速度快，被广泛使用</span><br><span class="line"></span><br><span class="line">HTML设计和后端python分离</span><br><span class="line"></span><br><span class="line">非常灵活，快速和安全</span><br><span class="line"></span><br><span class="line">提供了控制，继承等高级功能</span><br></pre></td></tr></table></figure><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><p>模板语法主要分为两种：<strong>变量</strong>和<strong>标签</strong></p><p>模板中的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模板中的变量：&#123;&#123; var &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">视图传递给模板的数据</span><br><span class="line"></span><br><span class="line">前面定义出来的数据</span><br><span class="line"></span><br><span class="line">变量不存在，默认忽略</span><br></pre></td></tr></table></figure><p>模板中的标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模板中的标签：&#123;% tag %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">控制逻辑</span><br><span class="line"></span><br><span class="line">使用外部表达式</span><br><span class="line"></span><br><span class="line">创建变量</span><br><span class="line"></span><br><span class="line">宏定义</span><br></pre></td></tr></table></figure><h4 id="结构标签："><a href="#结构标签：" class="headerlink" title="结构标签："></a>结构标签：</h4><p>block</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block xxx %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">块操作</span><br><span class="line">父模板挖坑，子模板填坑</span><br></pre></td></tr></table></figure><p>extends</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends ‘xxx.html’ %&#125;</span><br><span class="line"></span><br><span class="line">继承以后保留块中的内容</span><br><span class="line">&#123;&#123; super() &#125;&#125;</span><br></pre></td></tr></table></figure><p>挖坑继承体现的化整为零的操作</p><p>macro</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% macro hello(name) %&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; name &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line"></span><br><span class="line">宏定义，可以在模板中定义函数，在其他地方调用</span><br></pre></td></tr></table></figure><p>宏定义可导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">from</span> <span class="string">'xxx'</span> <span class="keyword">import</span> xxx %&#125;</span><br></pre></td></tr></table></figure><p>例子1：</p><p>在<code>index.html</code>中定义macro标签，定义一个方法，然后去调用方法，结果是展示商品的id和商品名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% macro show_goods(id, name) %&#125;</span><br><span class="line">    商品id：&#123;&#123; id &#125;&#125;</span><br><span class="line">    商品名称：&#123;&#123; name &#125;&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; show_goods(<span class="string">'1'</span>, <span class="string">'娃哈哈'</span>) &#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&#123;&#123; show_goods(<span class="string">'2'</span>, <span class="string">'雪碧'</span>) &#125;&#125;</span><br></pre></td></tr></table></figure><p>例子2：</p><p>在<code>index.html</code>页面中定义一个say()方法，然后解析该方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% macro say() %&#125;</span><br><span class="line"></span><br><span class="line">    &lt;h3&gt;今天天气气温回升&lt;/h3&gt;</span><br><span class="line">    &lt;h3&gt;适合去游泳&lt;/h3&gt;</span><br><span class="line">    &lt;h3&gt;适合去郊游&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; say() &#125;&#125;</span><br></pre></td></tr></table></figure><p>例子3：</p><p>定义一个<code>function.html</code>中定义一个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% macro create_user(name) %&#125;</span><br><span class="line">    创建了一个用户:&#123;&#123; name &#125;&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure><p>在<code>index.html</code>中引入<code>function.html</code>中定义的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">from</span> <span class="string">'functions.html'</span> <span class="keyword">import</span> create_user %&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; create_user(<span class="string">'小花'</span>) &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> item <span class="keyword">in</span> cols %&#125;</span><br><span class="line"></span><br><span class="line">aa</span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line"></span><br><span class="line">bb</span><br><span class="line"></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>也可以获取循环信息loop</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loop.first</span><br><span class="line"></span><br><span class="line">loop.last</span><br><span class="line"></span><br><span class="line">loop.index</span><br><span class="line"></span><br><span class="line">loop.revindex</span><br></pre></td></tr></table></figure><p>例子:</p><p>在视图中定义一个视图函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@stu.route('/scores/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scores</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    scores_list = [<span class="number">21</span>,<span class="number">34</span>,<span class="number">32</span>,<span class="number">67</span>,<span class="number">89</span>,<span class="number">43</span>,<span class="number">22</span>,<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">    content_h2 = <span class="string">'&lt;h2&gt;今天你们真帅&lt;/h2&gt;'</span></span><br><span class="line">    content_h3 = <span class="string">'   &lt;h3&gt;今天你们真帅&lt;/h3&gt;   '</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'scores.html'</span>,</span><br><span class="line">                           scores=scores_list,</span><br><span class="line">                           content_h2=content_h2,</span><br><span class="line">                           content_h3=content_h3)</span><br></pre></td></tr></table></figure><p>(该视图函数，在下面讲解的过滤器中任然使用其返回的content_h2等参数)</p><p>首先: 在页面中进行解析scores的列表。题目要求：第一个成绩展示为红色，最后一个成绩展示为绿色，其他的不变</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">   &#123;% <span class="keyword">for</span> score <span class="keyword">in</span> scores %&#125;</span><br><span class="line">        &#123;% <span class="keyword">if</span> loop.first %&#125;</span><br><span class="line">            &lt;li style="color:red;"&gt;&#123;&#123; loop.revindex &#125;&#125;:&#123;&#123; loop.index &#125;&#125;:&#123;&#123; score &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &#123;% <span class="keyword">elif</span> loop.last %&#125;</span><br><span class="line">            &lt;li style="color:green;"&gt;&#123;&#123; loop.revindex &#125;&#125;:&#123;&#123; loop.index &#125;&#125;:&#123;&#123; score &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">            &lt;li&gt; &#123;&#123; loop.revindex &#125;&#125;:&#123;&#123; loop.index &#125;&#125;:&#123;&#123; score &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 变量|过滤器|过滤器... &#125;&#125;</span><br></pre></td></tr></table></figure><p>capitalize 单词首字母大写</p><p>lower 单词变为小写</p><p>upper 单词变为大写</p><p>title</p><p>trim 去掉字符串的前后的空格</p><p>reverse 单词反转</p><p>format</p><p>striptags 渲染之前，将值中标签去掉</p><p>safe 讲样式渲染到页面中</p><p>default</p><p>last 最后一个字母</p><p>first</p><p>length</p><p>sum</p><p>sort</p><p>例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&#123;&#123; content_h2 &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&#123;&#123; content_h2|safe &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&#123;&#123; content_h2|striptags &#125;&#125;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li&gt;&#123;&#123; content_h3 &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&#123;&#123; content_h3|length &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&#123;&#123; content_h3|trim|safe &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&#123;&#123; content_h3|trim|length &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><h3 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h3><p><strong>定义基础模板<code>base.html</code></strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;</span><br><span class="line">        &#123;% block title %&#125;</span><br><span class="line">        &#123;% endblock %&#125;</span><br><span class="line">    &lt;/title&gt;</span><br><span class="line">    &lt;script src="https://code.jquery.com/jquery-3.2.1.min.js"&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &#123;% block extCSS %&#125;</span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&#123;% block header %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content%&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block footer%&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block extJS %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>定义基础模板<code>base_main.html</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &apos;base.html&apos; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block extCSS %&#125;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; url_for(&apos;static&apos;, filename=&apos;css/main.css&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><h3 id="静态文件信息配置"><a href="#静态文件信息配置" class="headerlink" title="静态文件信息配置"></a>静态文件信息配置</h3><p><strong>django</strong>：</p><p>第一种方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load static %&#125;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"&#123;% static 'css/index.css' %&#125;"</span>&gt;</span><br></pre></td></tr></table></figure><p>第二种方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"/static/css/index.css"</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>flask</strong>：</p><p>第一种方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"/static/css/index.css"</span>&gt;</span><br></pre></td></tr></table></figure><p>第二种方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"&#123;&#123; url_for('static', filename='css/index.css') &#125;&#125;"</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="5、模型"><a href="#5、模型" class="headerlink" title="5、模型"></a>5、模型</h2><h3 id="Flask模型"><a href="#Flask模型" class="headerlink" title="Flask模型"></a>Flask模型</h3><p>Flask默认并没有提供任何数据库操作的API</p><p>我们可以选择任何适合自己项目的数据库来使用</p><p>Flask中可以自己的选择数据，用原生语句实现功能，也可以选择ORM（SQLAlchemy，MongoEngine）</p><p>SQLAlchemy是一个很强大的关系型数据库框架，支持多种数据库后台。SQLAlchemy提供了高层ORM，也提供了使用数据库原生SQL的低层功能。</p><p>ORM：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">将对对象的操作转换为原生SQL</span><br><span class="line">优点</span><br><span class="line">易用性，可以有效减少重复SQL</span><br><span class="line">性能损耗少</span><br><span class="line">设计灵活，可以轻松实现复杂查询</span><br><span class="line">移植性好</span><br></pre></td></tr></table></figure><p>针对于Flask的支持，<a href="http://flask-sqlalchemy.pocoo.org/2.3/" target="_blank" rel="noopener">官网地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-sqlalchemy</span><br></pre></td></tr></table></figure><p>安装驱动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pymysql</span><br></pre></td></tr></table></figure><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p>使用SQLALchemy的对象去创建字段</p><p>其中<strong>tablename</strong>指定创建的数据库的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">创建models.py文件，其中定义模型</span><br><span class="line"></span><br><span class="line">from flask_sqlalchemy import SQLAlchemy</span><br><span class="line"></span><br><span class="line">db = SQLAlchemy()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Student(db.Model):</span><br><span class="line"></span><br><span class="line">    s_id = db.Column(db.Integer, primary_key=True, autoincrement=True)</span><br><span class="line">    s_name = db.Column(db.String(16), unique=True)</span><br><span class="line">    s_age = db.Column(db.Integer, default=1)</span><br><span class="line"></span><br><span class="line">    __tablename__ = &quot;student&quot;</span><br></pre></td></tr></table></figure><p>其中：</p><p>Integer表示创建的s_id字段的类型为整形，</p><p>primary_key表示是否为主键</p><p>String表示该字段为字符串</p><p>unique表示该字段唯一</p><p>default表示默认值</p><p>autoincrement表示是否自增</p><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><p>在视图函数中我们引入models.py中定义的db</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from App.models import db</span><br><span class="line"></span><br><span class="line">@blue.route(&quot;/createdb/&quot;)</span><br><span class="line">def create_db():</span><br><span class="line">    db.create_all()</span><br><span class="line">    return &quot;创建成功&quot;</span><br><span class="line"></span><br><span class="line">@blue.route(&apos;/dropdb/&apos;)</span><br><span class="line">def drop_db():</span><br><span class="line">    db.drop_all()</span><br><span class="line">    return &apos;删除成功&apos;</span><br></pre></td></tr></table></figure><p>其中： db.create_all()表示创建定义模型中对应到数据库中的表</p><p>db.drop_all()表示删除数据库中的所有的表</p><h3 id="初始化SQLALchemy"><a href="#初始化SQLALchemy" class="headerlink" title="初始化SQLALchemy"></a>初始化SQLALchemy</h3><p>在定义的<strong>init</strong>.py文件中使用SQLALchemy去整合一个或多个Flask的应用</p><p>有两种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line"></span><br><span class="line">from flask_sqlalchemy import SQLALchemy</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line">第二种：</span><br><span class="line"></span><br><span class="line">from App.models import db</span><br><span class="line"></span><br><span class="line">def create_app():</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    db.init_app(app)</span><br><span class="line">    return app</span><br></pre></td></tr></table></figure><h3 id="配置数据库的访问地址"><a href="#配置数据库的访问地址" class="headerlink" title="配置数据库的访问地址"></a>配置数据库的访问地址</h3><p><a href="http://www.pythondoc.com/flask-sqlalchemy/config.html" target="_blank" rel="noopener">官网配置参数</a></p><p>数据库连接的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dialect+driver://username:password@host:port/database</span><br><span class="line"></span><br><span class="line">dialect数据库实现</span><br><span class="line"></span><br><span class="line">driver数据库的驱动</span><br></pre></td></tr></table></figure><p>例子： 访问mysql数据库，驱动为pymysql，用户为root，密码为123456，数据库的地址为本地，端口为3306，数据库名称HelloFlask</p><p>设置如下： “mysql+pymysql://root:123456@localhost:3306/HelloFlask”</p><p>在初始化<strong>init</strong>.py文件中如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.config[&apos;SQLALCHEMY_TRACK_MODIFICATIONS&apos;] = False</span><br><span class="line"></span><br><span class="line">app.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] = &quot;mysql+pymysql://root:123456@localhost:3306/HelloFlask&quot;</span><br></pre></td></tr></table></figure><h3 id="对学生数据进行CRUD操作"><a href="#对学生数据进行CRUD操作" class="headerlink" title="对学生数据进行CRUD操作"></a>对学生数据进行CRUD操作</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.query.xxx</span><br></pre></td></tr></table></figure><p>获取查询集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">all()</span><br><span class="line"></span><br><span class="line">filter(类名.属性名==xxx)</span><br><span class="line"></span><br><span class="line">filter_by(属性名=xxx)</span><br></pre></td></tr></table></figure><p>数据操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在事务中处理，数据插入</span><br><span class="line"></span><br><span class="line">db.session.add(object)</span><br><span class="line"></span><br><span class="line">db.session.add_all(list[object])</span><br><span class="line"></span><br><span class="line">db.session.delete(object)</span><br><span class="line"></span><br><span class="line">db.session.commit()</span><br><span class="line"></span><br><span class="line">修改和删除基于查询</span><br></pre></td></tr></table></figure><p><strong>想学生表中添加数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@blue.route(&apos;/createstu/&apos;)</span><br><span class="line">def create_stu():</span><br><span class="line"></span><br><span class="line">    s = Student()</span><br><span class="line">    s.s_name = &apos;小花%d&apos; % random.randrange(100)</span><br><span class="line">    s.s_age = &apos;%d&apos; % random.randrange(30)</span><br><span class="line"></span><br><span class="line">    db.session.add(s)</span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    return &apos;添加成功&apos;</span><br></pre></td></tr></table></figure><p>提交事务，使用commit提交我们的添加数据的操作</p><p><strong>获取所有学生信息</strong></p><p>将学生的全部信息获取到，并且返回给页面，在页面中使用for循环去解析即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@blue.route(&quot;/getstudents/&quot;)</span><br><span class="line">def get_students():</span><br><span class="line">    students = Student.query.all()</span><br><span class="line">    return render_template(&quot;StudentList.html&quot;, students=students)</span><br></pre></td></tr></table></figure><p><strong>获取s_id=1的学生的信息</strong></p><p>写法1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">students = Student.query.filter(Student.s_id==1)</span><br></pre></td></tr></table></figure><p>写法2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">students = Student.query.filter_by(s_id=2)</span><br></pre></td></tr></table></figure><p>注意：filter中可以接多个过滤条件</p><p>写法3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql = &apos;select * from student where s_id=1&apos;</span><br><span class="line">students = db.session.execute(sql)</span><br></pre></td></tr></table></figure><p><strong>修改学生的信息</strong></p><p>写法1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students = Student.query.filter_by(s_id=3).first()</span><br><span class="line">students.s_name = &apos;哈哈&apos;</span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><p>写法2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student.query.filter_by(s_id=3).update(&#123;&apos;s_name&apos;:&apos;娃哈哈&apos;&#125;)</span><br><span class="line"></span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><p><strong>删除一个学生的信息</strong></p><p>写法1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students = Student.query.filter_by(s_id=2).first()</span><br><span class="line">db.session.delete(students)</span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><p>写法2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students = Student.query.filter_by(s_id=1).all()</span><br><span class="line">db.session.delete(students[0])</span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><p>注意：filter_by后的结果是一个list的结果集</p><p><strong>重点注意：在增删改中如果不commit的话，数据库中的数据并不会更新，只会修改本地缓存中的数据，所以一定需要db.session.commit()</strong></p><h2 id="6、模型-一对多"><a href="#6、模型-一对多" class="headerlink" title="6、模型-一对多"></a>6、模型-一对多</h2><h3 id="深入数据库增删改查"><a href="#深入数据库增删改查" class="headerlink" title="深入数据库增删改查"></a>深入数据库增删改查</h3><p>定义模型，并定义初始化的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student(db.Model):</span><br><span class="line"></span><br><span class="line">    s_id = db.Column(db.Integer, primary_key=True, autoincrement=True)</span><br><span class="line">    s_name = db.Column(db.String(16), unique=True)</span><br><span class="line">    s_age = db.Column(db.Integer, default=1)</span><br><span class="line"></span><br><span class="line">    __tablename__ = &quot;student&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.s_name = name</span><br><span class="line">        self.s_age = age</span><br></pre></td></tr></table></figure><h4 id="增–批量增加"><a href="#增–批量增加" class="headerlink" title="增–批量增加"></a>增–批量增加</h4><p>第一种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@blue.route(&apos;/createstus/&apos;)</span><br><span class="line">def create_users():</span><br><span class="line">    stus = []</span><br><span class="line">    for i in range(5):</span><br><span class="line"># 实例化Student的对象</span><br><span class="line">        s = Student()</span><br><span class="line"># 对象的属性赋值</span><br><span class="line">        s.s_name = &apos;张三%s&apos; % random.randrange(10000)</span><br><span class="line">        s.s_age = &apos;%d&apos; % random.randrange(100)</span><br><span class="line">        stus.append(s)</span><br><span class="line"># 添加需要创建的数据</span><br><span class="line">    db.session.add_all(stus)</span><br><span class="line"># 提交事务到数据库</span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    return &apos;创建成功&apos;</span><br></pre></td></tr></table></figure><p>注：在创建单条数据的时候使用db.session.add()，在创建多条数据的时候使用db.session.add_all()</p><p>第二种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@blue.route(&apos;/createstus/&apos;)</span><br><span class="line">def create_users():</span><br><span class="line">    stus = []</span><br><span class="line">    for i in range(5):</span><br><span class="line"># 使用类的初始化去创建Student对象</span><br><span class="line">        s = Student(&apos;张三%s&apos; % random.randrange(10000),</span><br><span class="line">                    &apos;%d&apos; % random.randrange(100))</span><br><span class="line">        stus.append(s)</span><br><span class="line"></span><br><span class="line">    db.session.add_all(stus)</span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    return &apos;创建成功&apos;</span><br></pre></td></tr></table></figure><h4 id="查–使用运算符"><a href="#查–使用运算符" class="headerlink" title="查–使用运算符"></a>查–使用运算符</h4><p>获取查询集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filter(类名.属性名.运算符(‘xxx’))</span><br><span class="line"></span><br><span class="line">filter(类名.属性 数学运算符  值)</span><br></pre></td></tr></table></figure><p>运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contains： 包含</span><br><span class="line">startswith：以什么开始</span><br><span class="line">endswith：以什么结束</span><br><span class="line">in_：在范围内</span><br><span class="line">like：模糊</span><br><span class="line">__gt__: 大于</span><br><span class="line">__ge__：大于等于</span><br><span class="line">__lt__：小于</span><br><span class="line">__le__：小于等于</span><br></pre></td></tr></table></figure><p>筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">offset()</span><br><span class="line"></span><br><span class="line">limit()</span><br><span class="line"></span><br><span class="line">order_by()</span><br><span class="line"></span><br><span class="line">get()</span><br><span class="line"></span><br><span class="line">first()</span><br><span class="line"></span><br><span class="line">paginate()</span><br></pre></td></tr></table></figure><p>逻辑运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">与</span><br><span class="line">and_</span><br><span class="line">filter(and_(条件),条件…)</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">or_</span><br><span class="line">filter(or_(条件),条件…)</span><br><span class="line"></span><br><span class="line">非</span><br><span class="line">not_</span><br><span class="line">filter(not_(条件),条件…)</span><br></pre></td></tr></table></figure><p>例子1：</p><ol><li><p>查询学生的id为3，4，5，6，16的的学生信息，使用<strong>in_逻辑运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@blue.route('/getstubyids/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stu_by_ids</span><span class="params">()</span>:</span></span><br><span class="line">   </span><br><span class="line">students = Student.query.filter(Student.s_id.in_([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">16</span>]))</span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">'StudentList.html'</span>, students=students)</span><br></pre></td></tr></table></figure></li><li><p>查询学生的年龄小于18岁的学生的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.query.filter(Student.s_age &lt; 18)</span><br></pre></td></tr></table></figure></li><li><p>查询学生的年龄小于18岁的学生的信息，<strong><strong>lt</strong>小于</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">students = Student.query.filter(Student.s_age.__lt__(15))</span><br></pre></td></tr></table></figure></li><li><p>查询学生的年龄小于等于18岁的学生的信息，<strong><strong>le</strong>小于等于</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">students = Student.query.filter(Student.s_age.__le__(15))</span><br></pre></td></tr></table></figure></li><li><p>查询学生的姓名以什么开始或者以什么结尾的学生的信息<strong>startswith和endswith</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">students = Student.query.filter(Student.s_name.startswith(&apos;张&apos;))</span><br><span class="line">students = Student.query.filter(Student.s_name.endswith(&apos;2&apos;))</span><br></pre></td></tr></table></figure></li><li><p>查询id=4的学生的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student.query.get(4)</span><br><span class="line">获取的结果是学生的对象</span><br></pre></td></tr></table></figure></li><li><p>模糊搜索like</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%：代表一个或者多个</span><br><span class="line">_：代表一个</span><br><span class="line"></span><br><span class="line">Student.query.filter(Student.s_name.like(&apos;%张%&apos;))</span><br></pre></td></tr></table></figure></li><li><p>分页，查询第二页的数据4条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一个参数是那一页，第二个参数是一页的条数，第三个参数是是否输出错误信息</span><br><span class="line">students = Student.query.paginate(2, 4, False).items</span><br></pre></td></tr></table></figure></li></ol><p>例子2：</p><p>跳过offset几个信息，截取limit结果的几个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 按照id降序排列</span><br><span class="line">stus = Student.query.order_by(&apos;-s_id&apos;)</span><br><span class="line"></span><br><span class="line"># 按照id降序获取三个</span><br><span class="line">stus = Student.query.order_by(&apos;-s_id&apos;).limit(3)</span><br><span class="line"></span><br><span class="line"># 获取年龄最大的一个</span><br><span class="line">stus = Student.query.order_by(&apos;-s_age&apos;).first()</span><br><span class="line"></span><br><span class="line"># 跳过3个数据，查询5个信息</span><br><span class="line">stus = Student.query.order_by(&apos;-s_age&apos;).offset(3).limit(5)</span><br><span class="line"></span><br><span class="line"># 跳过3个数据</span><br><span class="line">stus = Student.query.order_by(&apos;-s_age&apos;).offset(3)</span><br><span class="line"></span><br><span class="line"># 获取id等于24的学生</span><br><span class="line">stus = Student.query.filter(Student.s_id==24)</span><br><span class="line">stus = Student.query.get(24)</span><br></pre></td></tr></table></figure><p>例子3：</p><ol><li><p>查询</p><p>from sqlalchemy import and_, or_, not_</p><p><strong>查询多个条件</strong></p><p>stus = Student.query.filter(Student.s_age==18, Student.s_name==’雅典娜’)</p><p><strong>and_ 并且条件</strong></p><p>stus = Student.query.filter(and_(Student.s_age==18, Student.s_name==’雅典娜’))</p><p><strong>or_ 或者条件</strong></p><p>stus = Student.query.filter(or_(Student.s_age==18, Student.s_name==’火神’))</p><p><strong>not_ 非</strong></p><p>stus = Student.query.filter(not_(Student.s_age==18), Student.s_name==’火神’)</p></li></ol><p>例子4：</p><p><strong>分页：</strong></p><p><img src="https://github.com/shuaixiaohao/shuaixiaohao.github.io/blob/master/images/blog-image/flask_sqlalchemy_paginate.png?raw=true" alt=""></p><p>后端数据处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询第几页的数据</span><br><span class="line">page = int(request.args.get(&apos;page&apos;, 1))</span><br><span class="line"></span><br><span class="line"># 每一页的条数多少，默认为10条</span><br><span class="line">per_page = int(request.args.get(&apos;per_page&apos;, 10))</span><br><span class="line"></span><br><span class="line"># 查询当前第几个的多少条数据</span><br><span class="line">paginate = Student.query.order_by(&apos;-s_id&apos;).paginate(page, per_page, error_out=False)</span><br><span class="line"></span><br><span class="line">stus = paginate.items</span><br></pre></td></tr></table></figure><p>前端数据展示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;学生信息&lt;/h2&gt;</span><br><span class="line">&#123;% for stu in stus %&#125;</span><br><span class="line">    id：&#123;&#123; stu.s_id &#125;&#125;</span><br><span class="line">    姓名：&#123;&#123; stu.s_name &#125;&#125;</span><br><span class="line">    年龄：&#123;&#123; stu.s_age &#125;&#125;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">总页数: &#123;&#123; paginate.pages &#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">一共&#123;&#123; paginate.total &#125;&#125;条数据</span><br><span class="line">&lt;br&gt;</span><br><span class="line">当前页数：&#123;&#123; paginate.page &#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&#123;% if paginate.has_prev %&#125;</span><br><span class="line">    &lt;a href=&quot;/stupage/?page=&#123;&#123; paginate.prev_num &#125;&#125;&quot;&gt;上一页&lt;/a&gt;：&#123;&#123; paginate.prev_num &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if paginate.has_next %&#125;</span><br><span class="line">    &lt;a href=&quot;/stupage/?page=&#123;&#123; paginate.next_num &#125;&#125;&quot;&gt;下一页&lt;/a&gt;：&#123;&#123; paginate.next_num &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line">页码：&#123;% for i in  paginate.iter_pages() %&#125;</span><br><span class="line">        &lt;a href=&quot;/stupage/?page=&#123;&#123; i &#125;&#125;&quot;&gt;&#123;&#123; i &#125;&#125;&lt;/a&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><h4 id="一对多建立模型"><a href="#一对多建立模型" class="headerlink" title="一对多建立模型"></a>一对多建立模型</h4><p>学生模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student(db.Model):</span><br><span class="line"></span><br><span class="line">    s_id = db.Column(db.Integer, primary_key=True, autoincrement=True)</span><br><span class="line">    s_name = db.Column(db.String(20), unique=True)</span><br><span class="line">    s_age = db.Column(db.Integer, default=18)</span><br><span class="line">    s_g = db.Column(db.Integer, db.ForeignKey(&apos;grade.g_id&apos;), nullable=True)</span><br><span class="line"></span><br><span class="line">    __tablename__ = &apos;student&apos;</span><br></pre></td></tr></table></figure><p>班级模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Grade(db.Model):</span><br><span class="line"></span><br><span class="line">    g_id = db.Column(db.Integer, primary_key=True, autoincrement=True)</span><br><span class="line">    g_name = db.Column(db.String(10), unique=True)</span><br><span class="line">    g_desc = db.Column(db.String(100), nullable=True)</span><br><span class="line">    g_time = db.Column(db.Date, default=datetime.now)</span><br><span class="line">    students = db.relationship(&apos;Student&apos;, backref=&apos;stu&apos;, lazy=True)</span><br><span class="line"></span><br><span class="line">    __tablename__ = &apos;grade&apos;</span><br></pre></td></tr></table></figure><p>官网解释有如下几个lazy的参数：</p><p>lazy 决定了 SQLAlchemy 什么时候从数据库中加载数据:，有如下四个值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select/<span class="keyword">True</span>: (which <span class="keyword">is</span> the default) means that SQLAlchemy will load the data <span class="keyword">as</span> necessary <span class="keyword">in</span> one go using a standard select statement.</span><br><span class="line"></span><br><span class="line">joined/<span class="keyword">False</span>: tells SQLAlchemy to load the relationship <span class="keyword">in</span> the same query <span class="keyword">as</span> the parent using a JOIN statement.</span><br><span class="line"></span><br><span class="line">subquery: works like ‘joined’ but instead SQLAlchemy will use a subquery.</span><br><span class="line"></span><br><span class="line">dynamic: <span class="keyword">is</span> special <span class="keyword">and</span> useful <span class="keyword">if</span> you have many items. Instead of loading the items SQLAlchemy will <span class="keyword">return</span> another query object which you can further refine before loading the items. This <span class="keyword">is</span> usually what you want <span class="keyword">if</span> you expect more than a handful of items <span class="keyword">for</span> this relationship</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select就是访问到属性的时候，就会全部加载该属性的数据。</span><br><span class="line"></span><br><span class="line">joined则是在对关联的两个表进行join操作，从而获取到所有相关的对象。</span><br><span class="line"></span><br><span class="line">dynamic则不一样，在访问属性的时候，并没有在内存中加载数据，而是返回一个query对象, 需要执行相应方法才可以获取对象，</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><ol><li><p>通过班级查询学生信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@grade.route(&apos;/selectstubygrade/&lt;int:id&gt;/&apos;)</span><br><span class="line"></span><br><span class="line">def select_stu_by_grade(id):</span><br><span class="line">    grade = Grade.query.get(id)</span><br><span class="line"># 通过班级对象.定义的relationship变量去获取学生的信息</span><br><span class="line">    stus = grade.students</span><br><span class="line"></span><br><span class="line">    return render_template(&apos;grade_student.html&apos;,</span><br><span class="line">                           stus=stus,</span><br><span class="line">                           grade=grade</span><br><span class="line">                           )</span><br></pre></td></tr></table></figure></li><li><p>通过学生信息查询班级信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@stu.route(&apos;/selectgradebystu/&lt;int:id&gt;/&apos;)</span><br><span class="line">   </span><br><span class="line">def select_grade_by_stu(id):</span><br><span class="line">   </span><br><span class="line">    stu = Student.query.get(id)</span><br><span class="line"># 通过学生对象.定义的backref参数去获取班级的信息</span><br><span class="line">    grade = stu.stu</span><br><span class="line"></span><br><span class="line">    return render_template(&apos;student_grade.html&apos;,</span><br><span class="line">                           grade=grade,</span><br><span class="line">                           stu=stu)</span><br></pre></td></tr></table></figure></li></ol><p>注意：表的外键由db.ForeignKey指定，传入的参数是表的字段。db.relations它声明的属性不作为表字段，第一个参数是关联类的名字，backref是一个反向身份的代理,相当于在Student类中添加了stu的属性。例如，有Grade实例dept和Student实例stu。dept.students.count()将会返回学院学生人数;stu.stu.first()将会返回学生的学院信息的Grade类实例。一般来讲db.relationship()会放在一这一边。</p><h3 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h3><p>在django中继承了makemigrations，可以通过migrate操作去更新数据库，修改我们定义的models，然后在将模型映射到数据库中。</p><p>在flask中也有migrate操作，它能跟踪模型的变化，并将变化映射到数据库中</p><h4 id="安装migrate"><a href="#安装migrate" class="headerlink" title="安装migrate"></a>安装migrate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-migrate</span><br></pre></td></tr></table></figure><h4 id="配置使用migrate"><a href="#配置使用migrate" class="headerlink" title="配置使用migrate"></a>配置使用migrate</h4><p>初始化，使用app和db进行migrate对象的初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from flask_migrate import Migrate</span><br><span class="line"></span><br><span class="line">#绑定app和数据库</span><br><span class="line">Migrate(app=app, db=db)</span><br></pre></td></tr></table></figure><p>安装了flask-script的话，可以在Manager()对象上添加迁移指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from flask_migrate import Migrate, MigrateCommand</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">manage = Manager(app=app)</span><br><span class="line"></span><br><span class="line">manage.add_command(&apos;db&apos;, MigrateCommand)</span><br></pre></td></tr></table></figure><p>操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python manage.py db init  初始化出migrations的文件，只调用一次</span><br><span class="line"></span><br><span class="line">python manage.py db migrate  生成迁移文件</span><br><span class="line"></span><br><span class="line">python manage.py db upgrade 执行迁移文件中的升级</span><br><span class="line"></span><br><span class="line">python manage.py db downgrade 执行迁移文件中的降级</span><br><span class="line"></span><br><span class="line">python manage.py db --help 帮助文档</span><br></pre></td></tr></table></figure><h2 id="7、模型-多对多"><a href="#7、模型-多对多" class="headerlink" title="7、模型-多对多"></a>7、模型-多对多</h2><h3 id="关联关系—多对多"><a href="#关联关系—多对多" class="headerlink" title="关联关系—多对多"></a>关联关系—多对多</h3><p>定义模型：</p><p>引入SLALchemy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from flask_sqlalchemy import SQLAlchemy</span><br><span class="line"></span><br><span class="line">db = SQLAlchemy()</span><br></pre></td></tr></table></figure><p>创建中间表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sc = db.Table(&apos;sc&apos;,</span><br><span class="line">    db.Column(&apos;s_id&apos;, db.Integer, db.ForeignKey(&apos;student.s_id&apos;), primary_key=True),</span><br><span class="line">    db.Column(&apos;c_id&apos;, db.Integer, db.ForeignKey(&apos;courses.c_id&apos;), primary_key=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>创建学生类Student</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Student(db.Model):</span><br><span class="line"></span><br><span class="line">    s_id = db.Column(db.Integer, primary_key=True, autoincrement=True)</span><br><span class="line">    s_name = db.Column(db.String(20), unique=True)</span><br><span class="line">    s_age = db.Column(db.Integer, default=18)</span><br><span class="line">    s_g = db.Column(db.Integer, db.ForeignKey(&apos;grade.g_id&apos;), nullable=True)</span><br><span class="line"></span><br><span class="line">    __tablename__ = &apos;student&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line"></span><br><span class="line">        self.s_name = name</span><br><span class="line">        self.s_age = age</span><br><span class="line">        self.s_g = None</span><br></pre></td></tr></table></figure><p>创建课程表的模型，Course类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Course(db.Model):</span><br><span class="line"></span><br><span class="line">    c_id = db.Column(db.Integer, primary_key=True, autoincrement=True)</span><br><span class="line">    c_name = db.Column(db.String(20), unique=True)</span><br><span class="line">    students = db.relationship(&apos;Student&apos;,</span><br><span class="line">                               secondary=sc,</span><br><span class="line">                               backref=&apos;cou&apos;)</span><br><span class="line"></span><br><span class="line">    __tablename__ = &apos;courses&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line"></span><br><span class="line">        self.c_name = name</span><br></pre></td></tr></table></figure><p>sc表由<strong>db.Table声明</strong>，我们不需要关心这张表，因为这张表将会由SQLAlchemy接管，它唯一的作用是作为students表和courses表关联表，所以必须在db.relationship()中指出<strong>sencondary关联表参数</strong>。lazy是指查询时的惰性求值的方式，这里有详细的参数说明，而db.backref是声明反向身份代理，其中的lazy参数是指明反向查询的惰性求值方式.</p><p>添加学生和课程之间的关系</p><p>通过页面中传递学生的id和课程的id，分别获取学生的对象和课程的对象，在使用关联关系append去添加学生对象，并且add以后再commit后，就可以在中间表sc中查看到新增的关联关系了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">userid = request.form.get(&apos;userid&apos;)</span><br><span class="line">   courseid = request.form.get(&apos;courseid&apos;)</span><br><span class="line"></span><br><span class="line">   stu = Student.query.get(userid)</span><br><span class="line">   cou = Course.query.get(courseid)</span><br><span class="line"></span><br><span class="line">   cou.students.append(stu)</span><br><span class="line">   db.session.add(cou)</span><br><span class="line">   db.session.commit()</span><br></pre></td></tr></table></figure><p>删除学生和课程之间的关系</p><p>通过页面获取传递的学生的id和课程的id，分别获取学生对象和课程对象，在使用关联关系remove去删除学生对象，并commit将事务提交到数据库中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stu = Student.query.get(s_id)</span><br><span class="line">cou = Course.query.get(c_id)</span><br><span class="line"></span><br><span class="line">cou.students.remove(stu)</span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><p>通过课程查询学生的信息</p><p>以下定义在课程course的模型中，所以通过课程查询学生的信息，语法为课程的对象.studengs。如果知道学生的信息反过来找课程的信息，则使用backref的反向关联去查询，语语法为学生的对象.cou(反向)</p><p>students = db.relationship(‘Student’,secondary=sc,backref=’cou’)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cou = Course.query.get(2)</span><br><span class="line">stus = cou.students</span><br></pre></td></tr></table></figure><p>通过学生去查询课程的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu = Student.query.get(id)</span><br><span class="line">cous = stu.cou</span><br></pre></td></tr></table></figure><h2 id="8、插件"><a href="#8、插件" class="headerlink" title="8、插件"></a>8、插件</h2><p>开发，页面调试工具debugtoolbar</p><p>1.1 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-debugtoolbar</span><br></pre></td></tr></table></figure><p>1.2 配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">from flask_debugtoolbar import DebugToolbarExtension</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">app.debug = True</span><br><span class="line"></span><br><span class="line">app.config[&apos;SECRET_KEY&apos;] = &apos;&lt;replace with a secret key&gt;&apos;</span><br><span class="line"></span><br><span class="line">toolbar = DebugToolbarExtension(app)</span><br></pre></td></tr></table></figure><h3 id="2-restful"><a href="#2-restful" class="headerlink" title="2. restful"></a>2. restful</h3><p>Flask-RESTful 提供的最主要的基础就是资源(resources)。资源(Resources)是构建在 Flask 可拔插视图 之上，只要在你的资源(resource)上定义方法就能够容易地访问多个 HTTP 方法</p><p><a href="http://www.pythondoc.com/Flask-RESTful/quickstart.html" target="_blank" rel="noopener">官网</a>上描述了一个最简单的restful风格的api，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from flask.ext import restful</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">api = restful.Api(app)</span><br><span class="line"></span><br><span class="line">class HelloWorld(restful.Resource):</span><br><span class="line">    def get(self):</span><br><span class="line">        return &#123;&apos;hello&apos;: &apos;world&apos;&#125;</span><br><span class="line"></span><br><span class="line">api.add_resource(HelloWorld, &apos;/&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(debug=True)</span><br></pre></td></tr></table></figure><p>2.1 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask_restful</span><br></pre></td></tr></table></figure><p>2.2 配置</p><p>在create_app()获取Flask(<strong>name</strong>)对象中，设置如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from flask_restful import Api</span><br><span class="line"></span><br><span class="line">api = Api()</span><br><span class="line"></span><br><span class="line">api.init_app(app=app)</span><br></pre></td></tr></table></figure><p>在views中需要引入配置的api还有Resource</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 导入包和restful中的Api对象</span><br><span class="line">from flask_restful import Resource</span><br><span class="line">from utils.functions import api</span><br><span class="line"></span><br><span class="line"># 定义类，启动包含了对数据处理的GET,POST,PATCH,PUT,DELETE请求</span><br><span class="line">class CreateCourse(Resource):</span><br><span class="line"></span><br><span class="line">def get(self, id):</span><br><span class="line">    course = Course.query.get(id)</span><br><span class="line">    return course.to_dict()</span><br><span class="line"></span><br><span class="line">def post(self):</span><br><span class="line"></span><br><span class="line">    courses = [&apos;大学英语&apos;, &apos;大学物理&apos;, &apos;线性代数&apos;, &apos;高数&apos;,</span><br><span class="line">               &apos;VHDL&apos;, &apos;ARM&apos;, &apos;马克思主义&apos;, &apos;农场劳动&apos;]</span><br><span class="line">    course_list = []</span><br><span class="line">    for course in courses:</span><br><span class="line">        c = Course()</span><br><span class="line">        c.c_name = course</span><br><span class="line">        course_list.append(c)</span><br><span class="line">    db.session.add_all(course_list)</span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    courses = Course.query.all()</span><br><span class="line">    return [course.to_dict() for course in courses]</span><br><span class="line"></span><br><span class="line">def patch(self, id):</span><br><span class="line">    c_name = request.form.get(&apos;c_name&apos;)</span><br><span class="line">    course = Course.query.get(id)</span><br><span class="line">    course.c_name = c_name</span><br><span class="line">    db.session.commit()</span><br><span class="line">    return &#123;&apos;code&apos;: 200, &apos;data&apos;: course.to_dict(), &apos;msg&apos;: &apos;请求成功&apos;&#125;</span><br><span class="line"></span><br><span class="line">def delete(self, id):</span><br><span class="line">    course = Course.query.get(id)</span><br><span class="line">    db.session.delete(course)</span><br><span class="line">    db.session.commit()</span><br><span class="line">    return &#123;&apos;code&apos;: 200, &apos;msg&apos;: &apos;删除成功&apos;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 绑定处理url</span><br><span class="line">api.add_resource(CreateCourse, &apos;/api/course/&lt;int:id&gt;/&apos;, &apos;/api/course/&apos;)</span><br></pre></td></tr></table></figure><p>2.3 端点(Endpoints)</p><p>在一个 API 中，你的资源可以通过多个 URLs 访问。你可以把多个 URLs 传给 Api 对象的 Api.add_resource() 方法。每一个 URL 都能访问到你的 Resource</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.add_resource(CreateCourse, &apos;/api/course/&lt;int:id&gt;/&apos;, &apos;/api/course/&apos;)</span><br></pre></td></tr></table></figure><p>2.4 返回响应</p><p>Flask-RESTful 支持视图方法多种类型的返回值。同 Flask 一样，你可以返回任一迭代器，它将会被转换成一个包含原始 Flask 响应对象的响应。Flask-RESTful 也支持使用多个返回值来设置响应代码和响应头</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def get(self, id):</span><br><span class="line">    course = Course.query.get(id)</span><br><span class="line">    return course.to_dict(), 200</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Web框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>爬虫</title>
      <link href="/2017/12/07/%E7%88%AC%E8%99%AB/"/>
      <url>/2017/12/07/%E7%88%AC%E8%99%AB/</url>
      <content type="html"><![CDATA[<h2 id="1、网络爬虫和相关工具"><a href="#1、网络爬虫和相关工具" class="headerlink" title="1、网络爬虫和相关工具"></a>1、网络爬虫和相关工具</h2><h3 id="1-1-网络爬虫"><a href="#1-1-网络爬虫" class="headerlink" title="1.1 网络爬虫"></a>1.1 网络爬虫</h3><p>网络爬虫（web crawler），以前经常称之为网络蜘蛛（spider），是按照一定的规则自动浏览万维网并获取信息的机器人程序（或脚本），曾经被广泛的应用于互联网搜索引擎。使用过互联网和浏览器的人都知道，网页中除了供用户阅读的文字信息之外，还包含一些超链接。网络爬虫系统正是通过网页中的超链接信息不断获得网络上的其它页面。正因如此，网络数据采集的过程就像一个爬虫或者蜘蛛在网络上漫游，所以才被形象的称为网络爬虫或者网络蜘蛛。</p><a id="more"></a> <h4 id="爬虫的应用领域"><a href="#爬虫的应用领域" class="headerlink" title="爬虫的应用领域"></a>爬虫的应用领域</h4><p>在理想的状态下，所有ICP（Internet Content Provider）都应该为自己的网站提供API接口来共享它们允许其他程序获取的数据，在这种情况下爬虫就不是必需品，国内比较有名的电商平台（如淘宝、京东等）、社交平台（如腾讯微博等）等网站都提供了自己的Open API，但是这类Open API通常会对可以抓取的数据以及抓取数据的频率进行限制。对于大多数的公司而言，及时的获取行业相关数据是企业生存的重要环节之一，然而大部分企业在行业数据方面的匮乏是其与生俱来的短板，合理的利用爬虫来获取数据并从中提取出有商业价值的信息是至关重要的。当然爬虫还有很多重要的应用领域，下面列举了其中的一部分：</p><ol><li>搜索引擎</li><li>新闻聚合</li><li>社交应用</li><li>舆情监控</li><li>行业数据</li></ol><h3 id="1-2合法性和背景调研"><a href="#1-2合法性和背景调研" class="headerlink" title="1.2合法性和背景调研"></a>1.2合法性和背景调研</h3><h4 id="爬虫合法性探讨"><a href="#爬虫合法性探讨" class="headerlink" title="爬虫合法性探讨"></a>爬虫合法性探讨</h4><ol><li>网络爬虫领域目前还属于拓荒阶段，虽然互联网世界已经通过自己的游戏规则建立起一定的道德规范(Robots协议，全称是“网络爬虫排除标准”)，但法律部分还在建立和完善中，也就是说，现在这个领域暂时还是灰色地带。</li><li>“法不禁止即为许可”，如果爬虫就像浏览器一样获取的是前端显示的数据（网页上的公开信息）而不是网站后台的私密敏感信息，就不太担心法律法规的约束，因为目前大数据产业链的发展速度远远超过了法律的完善程度。</li><li>在爬取网站的时候，需要限制自己的爬虫遵守Robots协议，同时控制网络爬虫程序的抓取数据的速度；在使用数据的时候，必须要尊重网站的知识产权（从Web 2.0时代开始，虽然Web上的数据很多都是由用户提供的，但是网站平台是投入了运营成本的，当用户在注册和发布内容时，平台通常就已经获得了对数据的所有权、使用权和分发权）。如果违反了这些规定，在打官司的时候败诉几率相当高。</li></ol><h4 id="Robots-txt文件"><a href="#Robots-txt文件" class="headerlink" title="Robots.txt文件"></a>Robots.txt文件</h4><p>大多数网站都会定义robots.txt文件，下面以淘宝的<a href="http://www.taobao.com/robots.txt" target="_blank" rel="noopener">robots.txt</a>文件为例，看看该网站对爬虫有哪些限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">User-agent:  Baiduspider</span><br><span class="line">Allow:  /article</span><br><span class="line">Allow:  /oshtml</span><br><span class="line">Disallow:  /product/</span><br><span class="line">Disallow:  /</span><br><span class="line"></span><br><span class="line">User-Agent:  Googlebot</span><br><span class="line">Allow:  /article</span><br><span class="line">Allow:  /oshtml</span><br><span class="line">Allow:  /product</span><br><span class="line">Allow:  /spu</span><br><span class="line">Allow:  /dianpu</span><br><span class="line">Allow:  /oversea</span><br><span class="line">Allow:  /list</span><br><span class="line">Disallow:  /</span><br><span class="line"></span><br><span class="line">User-agent:  Bingbot</span><br><span class="line">Allow:  /article</span><br><span class="line">Allow:  /oshtml</span><br><span class="line">Allow:  /product</span><br><span class="line">Allow:  /spu</span><br><span class="line">Allow:  /dianpu</span><br><span class="line">Allow:  /oversea</span><br><span class="line">Allow:  /list</span><br><span class="line">Disallow:  /</span><br><span class="line"></span><br><span class="line">User-Agent:  360Spider</span><br><span class="line">Allow:  /article</span><br><span class="line">Allow:  /oshtml</span><br><span class="line">Disallow:  /</span><br><span class="line"></span><br><span class="line">User-Agent:  Yisouspider</span><br><span class="line">Allow:  /article</span><br><span class="line">Allow:  /oshtml</span><br><span class="line">Disallow:  /</span><br><span class="line"></span><br><span class="line">User-Agent:  Sogouspider</span><br><span class="line">Allow:  /article</span><br><span class="line">Allow:  /oshtml</span><br><span class="line">Allow:  /product</span><br><span class="line">Disallow:  /</span><br><span class="line"></span><br><span class="line">User-Agent:  Yahoo!  Slurp</span><br><span class="line">Allow:  /product</span><br><span class="line">Allow:  /spu</span><br><span class="line">Allow:  /dianpu</span><br><span class="line">Allow:  /oversea</span><br><span class="line">Allow:  /list</span><br><span class="line">Disallow:  /</span><br><span class="line"></span><br><span class="line">User-Agent:  *</span><br><span class="line">Disallow:  /</span><br></pre></td></tr></table></figure><p>注意上面robots.txt第一段的最后一行，通过设置“Disallow: /”禁止百度爬虫访问除了“Allow”规定页面外的其他所有页面。因此当你在百度搜索“淘宝”的时候，搜索结果下方会出现：“由于该网站的robots.txt文件存在限制指令（限制搜索引擎抓取），系统无法提供该页面的内容描述”。百度作为一个搜索引擎，至少在表面上遵守了淘宝网的robots.txt协议，所以用户不能从百度上搜索到淘宝内部的产品信息。</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/baidu-search-taobao.png" alt="img"></p><h3 id="1-3-相关工具介绍"><a href="#1-3-相关工具介绍" class="headerlink" title="1.3 相关工具介绍"></a>1.3 相关工具介绍</h3><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>在开始讲解爬虫之前，我们稍微对HTTP（超文本传输协议）做一些回顾，因为我们在网页上看到的内容通常是浏览器执行HTML语言得到的结果，而HTTP就是传输HTML数据的协议。HTTP和其他很多应用级协议一样是构建在TCP（传输控制协议）之上的，它利用了TCP提供的可靠的传输服务实现了Web应用中的数据交换。按照维基百科上的介绍，设计HTTP最初的目的是为了提供一种发布和接收<a href="https://zh.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>页面的方法，也就是说这个协议是浏览器和Web服务器之间传输的数据的载体。关于这个协议的详细信息以及目前的发展状况，大家可以阅读阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">《HTTP 协议入门》</a>、<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">《互联网协议入门》</a>系列以及<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">《图解HTTPS协议》</a>进行了解，下图是我在四川省网络通信技术重点实验室工作期间用开源协议分析工具Ethereal（抓包工具WireShark的前身）截取的访问百度首页时的HTTP请求和响应的报文（协议数据），由于Ethereal截取的是经过网络适配器的数据，因此可以清晰的看到从物理链路层到应用层的协议数据。</p><p>HTTP请求（请求行+请求头+空行+[消息体]）：</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/http-request.png" alt="img"></p><p>HTTP响应（响应行+响应头+空行+消息体）：</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/http-response.png" alt="img"></p><blockquote><p>说明：但愿这两张如同泛黄的照片般的截图帮助你大概的了解到HTTP是一个怎样的协议。</p></blockquote><h4 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h4><ol><li><p>Chrome Developer Tools：谷歌浏览器内置的开发者工具。</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/chrome-developer-tools.png" alt="img"></p></li><li><p>POSTMAN：功能强大的网页调试与RESTful请求工具。</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/postman.png" alt="img"></p></li><li><p>HTTPie：命令行HTTP客户端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ http --header http://www.scu.edu.cn</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Cache-Control: private, max-age=600</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Language: zh-CN</span><br><span class="line">Content-Length: 14403</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Sun, 27 May 2018 15:38:25 GMT</span><br><span class="line">ETag: &quot;e6ec-56d3032d70a32-gzip&quot;</span><br><span class="line">Expires: Sun, 27 May 2018 15:48:25 GMT</span><br><span class="line">Keep-Alive: timeout=5, max=100</span><br><span class="line">Last-Modified: Sun, 27 May 2018 13:44:22 GMT</span><br><span class="line">Server: VWebServer</span><br><span class="line">Vary: User-Agent,Accept-Encoding</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br></pre></td></tr></table></figure></li><li><p>BuiltWith：识别网站所用技术的工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; import builtwith</span><br><span class="line">&gt;&gt;&gt; builtwith.parse(&apos;http://www.bootcss.com/&apos;)</span><br><span class="line">&#123;&apos;web-servers&apos;: [&apos;Nginx&apos;], &apos;font-scripts&apos;: [&apos;Font Awesome&apos;], &apos;javascript-frameworks&apos;: [&apos;Lo-dash&apos;, &apos;Underscore.js&apos;, &apos;Vue.js&apos;, &apos;Zepto&apos;, &apos;jQuery&apos;], &apos;web-frameworks&apos;: [&apos;Twitter Bootstrap&apos;]&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; import ssl</span><br><span class="line">&gt;&gt;&gt; ssl._create_default_https_context = ssl._create_unverified_context</span><br><span class="line">&gt;&gt;&gt; builtwith.parse(&apos;https://www.jianshu.com/&apos;)</span><br><span class="line">&#123;&apos;web-servers&apos;: [&apos;Tengine&apos;], &apos;web-frameworks&apos;: [&apos;Twitter Bootstrap&apos;, &apos;Ruby on Rails&apos;], &apos;programming-languages&apos;: [&apos;Ruby&apos;]&#125;</span><br></pre></td></tr></table></figure></li><li><p>python-whois：查询网站所有者的工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; import whois</span><br><span class="line">&gt;&gt;&gt; whois.whois(&apos;baidu.com&apos;)</span><br><span class="line">&#123;&apos;domain_name&apos;: [&apos;BAIDU.COM&apos;, &apos;baidu.com&apos;], &apos;registrar&apos;: &apos;MarkMonitor, Inc.&apos;, &apos;whois_server&apos;: &apos;whois.markmonitor.com&apos;, &apos;referral_url&apos;: None, &apos;updated_date&apos;: [datetime.datetime(2017, 7, 28, 2, 36, 28), datetime.datetime(2017, 7, 27, 19, 36, 28)], &apos;creation_date&apos;: [datetime.datetime(1999, 10, 11, 11, 5, 17), datetime.datetime(1999, 10, 11, 4, 5, 17)], &apos;expiration_date&apos;: [datetime.datetime(2026, 10, 11, 11, 5, 17), datetime.datetime(2026, 10, 11, 0, 0)], &apos;name_servers&apos;: [&apos;DNS.BAIDU.COM&apos;, &apos;NS2.BAIDU.COM&apos;, &apos;NS3.BAIDU.COM&apos;, &apos;NS4.BAIDU.COM&apos;, &apos;NS7.BAIDU.COM&apos;, &apos;dns.baidu.com&apos;, &apos;ns4.baidu.com&apos;, &apos;ns3.baidu.com&apos;, &apos;ns7.baidu.com&apos;, &apos;ns2.baidu.com&apos;], &apos;status&apos;: [&apos;clientDeleteProhibited https://icann.org/epp#clientDeleteProhibited&apos;, &apos;clientTransferProhibited https://icann.org/epp#clientTransferProhibited&apos;, &apos;clientUpdateProhibited https://icann.org/epp#clientUpdateProhibited&apos;, &apos;serverDeleteProhibited https://icann.org/epp#serverDeleteProhibited&apos;, &apos;serverTransferProhibited https://icann.org/epp#serverTransferProhibited&apos;, &apos;serverUpdateProhibited https://icann.org/epp#serverUpdateProhibited&apos;, &apos;clientUpdateProhibited (https://www.icann.org/epp#clientUpdateProhibited)&apos;, &apos;clientTransferProhibited (https://www.icann.org/epp#clientTransferProhibited)&apos;, &apos;clientDeleteProhibited (https://www.icann.org/epp#clientDeleteProhibited)&apos;, &apos;serverUpdateProhibited (https://www.icann.org/epp#serverUpdateProhibited)&apos;, &apos;serverTransferProhibited (https://www.icann.org/epp#serverTransferProhibited)&apos;, &apos;serverDeleteProhibited (https://www.icann.org/epp#serverDeleteProhibited)&apos;], &apos;emails&apos;: [&apos;abusecomplaints@markmonitor.com&apos;, &apos;whoisrelay@markmonitor.com&apos;], &apos;dnssec&apos;: &apos;unsigned&apos;, &apos;name&apos;: None, &apos;org&apos;: &apos;Beijing Baidu Netcom Science Technology Co., Ltd.&apos;, &apos;address&apos;: None, &apos;city&apos;: None, &apos;state&apos;: &apos;Beijing&apos;, &apos;zipcode&apos;: None, &apos;country&apos;: &apos;CN&apos;&#125;</span><br></pre></td></tr></table></figure></li><li><p>robotparser：解析robots.txt的工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from urllib import robotparser</span><br><span class="line">&gt;&gt;&gt; parser = robotparser.RobotFileParser()</span><br><span class="line">&gt;&gt;&gt; parser.set_url(&apos;https://www.taobao.com/robots.txt&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.read()</span><br><span class="line">&gt;&gt;&gt; parser.can_fetch(&apos;Hellokitty&apos;, &apos;http://www.taobao.com/article&apos;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; parser.can_fetch(&apos;Baiduspider&apos;, &apos;http://www.taobao.com/article&apos;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; parser.can_fetch(&apos;Baiduspider&apos;, &apos;http://www.taobao.com/product&apos;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li></ol><h3 id="一个简单的爬虫"><a href="#一个简单的爬虫" class="headerlink" title="一个简单的爬虫"></a>一个简单的爬虫</h3><p>一个基本的爬虫通常分为数据采集（网页下载）、数据处理（网页解析）和数据存储（将有用的信息持久化）三个部分的内容，当然更为高级的爬虫在数据采集和处理时会使用并发编程或分布式技术，这就需要有调度器（安排线程或进程执行对应的任务）、后台管理程序（监控爬虫的工作状态以及检查数据抓取的结果）等的参与。</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/crawler-workflow.png" alt="img"></p><p>一般来说，爬虫的工作流程包括以下几个步骤：</p><ol><li>设定抓取目标（种子页面/起始页面）并获取网页。</li><li>当服务器无法访问时，按照指定的重试次数尝试重新下载页面。</li><li>在需要的时候设置用户代理或隐藏真实IP，否则可能无法访问页面。</li><li>对获取的页面进行必要的解码操作然后抓取出需要的信息。</li><li>在获取的页面中通过某种方式（如正则表达式）抽取出页面中的链接信息。</li><li>对链接进行进一步的处理（获取页面并重复上面的动作）。</li><li>将有用的信息进行持久化以备后续的处理。</li></ol><p>下面的例子给出了一个从“搜狐体育”上获取NBA新闻标题和链接的爬虫。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">from urllib.error import URLError</span><br><span class="line">from urllib.request import urlopen</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line">import pymysql</span><br><span class="line">import ssl</span><br><span class="line"></span><br><span class="line">from pymysql import Error</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 通过指定的字符集对页面进行解码(不是每个网站都将字符集设置为utf-8)</span><br><span class="line">def decode_page(page_bytes, charsets=(&apos;utf-8&apos;,)):</span><br><span class="line">    page_html = None</span><br><span class="line">    for charset in charsets:</span><br><span class="line">        try:</span><br><span class="line">            page_html = page_bytes.decode(charset)</span><br><span class="line">            break</span><br><span class="line">        except UnicodeDecodeError:</span><br><span class="line">            pass</span><br><span class="line">            # logging.error(&apos;Decode:&apos;, error)</span><br><span class="line">    return page_html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取页面的HTML代码(通过递归实现指定次数的重试操作)</span><br><span class="line">def get_page_html(seed_url, *, retry_times=3, charsets=(&apos;utf-8&apos;,)):</span><br><span class="line">    page_html = None</span><br><span class="line">    try:</span><br><span class="line">        page_html = decode_page(urlopen(seed_url).read(), charsets)</span><br><span class="line">    except URLError:</span><br><span class="line">        # logging.error(&apos;URL:&apos;, error)</span><br><span class="line">        if retry_times &gt; 0:</span><br><span class="line">            return get_page_html(seed_url, retry_times=retry_times - 1,</span><br><span class="line">                                 charsets=charsets)</span><br><span class="line">    return page_html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 从页面中提取需要的部分(通常是链接也可以通过正则表达式进行指定)</span><br><span class="line">def get_matched_parts(page_html, pattern_str, pattern_ignore_case=re.I):</span><br><span class="line">    pattern_regex = re.compile(pattern_str, pattern_ignore_case)</span><br><span class="line">    return pattern_regex.findall(page_html) if page_html else []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 开始执行爬虫程序并对指定的数据进行持久化操作</span><br><span class="line">def start_crawl(seed_url, match_pattern, *, max_depth=-1):</span><br><span class="line">    conn = pymysql.connect(host=&apos;localhost&apos;, port=3306,</span><br><span class="line">                           database=&apos;crawler&apos;, user=&apos;root&apos;,</span><br><span class="line">                           password=&apos;123456&apos;, charset=&apos;utf8&apos;)</span><br><span class="line">    try:</span><br><span class="line">        with conn.cursor() as cursor:</span><br><span class="line">            url_list = [seed_url]</span><br><span class="line">            # 通过下面的字典避免重复抓取并控制抓取深度</span><br><span class="line">            visited_url_list = &#123;seed_url: 0&#125;</span><br><span class="line">            while url_list:</span><br><span class="line">                current_url = url_list.pop(0)</span><br><span class="line">                depth = visited_url_list[current_url]</span><br><span class="line">                if depth != max_depth:</span><br><span class="line">                    # 尝试用utf-8/gbk/gb2312三种字符集进行页面解码</span><br><span class="line">                    page_html = get_page_html(current_url, charsets=(&apos;utf-8&apos;, &apos;gbk&apos;, &apos;gb2312&apos;))</span><br><span class="line">                    links_list = get_matched_parts(page_html, match_pattern)</span><br><span class="line">                    param_list = []</span><br><span class="line">                    for link in links_list:</span><br><span class="line">                        if link not in visited_url_list:</span><br><span class="line">                            visited_url_list[link] = depth + 1</span><br><span class="line">                            page_html = get_page_html(link, charsets=(&apos;utf-8&apos;, &apos;gbk&apos;, &apos;gb2312&apos;))</span><br><span class="line">                            headings = get_matched_parts(page_html, r&apos;&lt;h1&gt;(.*)&lt;span&apos;)</span><br><span class="line">                            if headings:</span><br><span class="line">                                param_list.append((headings[0], link))</span><br><span class="line">                    cursor.executemany(&apos;insert into tb_result values (default, %s, %s)&apos;,</span><br><span class="line">                                       param_list)</span><br><span class="line">                    conn.commit()</span><br><span class="line">    except Error:</span><br><span class="line">        pass</span><br><span class="line">        # logging.error(&apos;SQL:&apos;, error)</span><br><span class="line">    finally:</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ssl._create_default_https_context = ssl._create_unverified_context</span><br><span class="line">    start_crawl(&apos;http://sports.sohu.com/nba_a.shtml&apos;,</span><br><span class="line">                r&apos;&lt;a[^&gt;]+test=a\s[^&gt;]*href=[&quot;\&apos;](.*?)[&quot;\&apos;]&apos;,</span><br><span class="line">                max_depth=2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>由于使用了MySQL实现持久化操作，所以要先启动MySQL服务器再运行该程序。</p><h3 id="爬虫注意事项"><a href="#爬虫注意事项" class="headerlink" title="爬虫注意事项"></a>爬虫注意事项</h3><p>通过上面的例子，我们对爬虫已经有了一个感性的认识，在编写爬虫时有以下一些注意事项：</p><ol><li><p>处理相对链接。有的时候我们从页面中获取的链接不是一个完整的绝对链接而是一个相对链接，这种情况下需要将其与URL前缀进行拼接（<code>urllib.parse</code>中的<code>urljoin()</code>函数可以完成此项操作）。</p></li><li><p>设置代理服务。有些网站会限制访问的区域（例如美国的Netflix屏蔽了很多国家的访问），有些爬虫需要隐藏自己的身份，在这种情况下可以设置使用代理服务器，代理服务器有免费（如<a href="http://www.xicidaili.com/" target="_blank" rel="noopener">西刺代理</a>、<a href="https://www.kuaidaili.com/free/" target="_blank" rel="noopener">快代理</a>）和付费两种（如<a href="http://www.xdaili.cn/" target="_blank" rel="noopener">讯代理</a>、<a href="https://www.abuyun.com/" target="_blank" rel="noopener">阿布云代理</a>)，付费的一般稳定性和可用性都更好，可以通过<code>urllib.request</code>中的<code>ProxyHandler</code>来为请求设置代理。</p></li><li><p>限制下载速度。如果我们的爬虫获取网页的速度过快，可能就会面临被封禁或者产生“损害动产”的风险（这个可能会导致吃官司且败诉），可以在两次下载之间添加延时从而对爬虫进行限速。</p></li><li><p>避免爬虫陷阱。有些网站会动态生成页面内容，这会导致产生无限多的页面（例如在线万年历通常会有无穷无尽的链接）。可以通过记录到达当前页面经过了多少个链接（链接深度）来解决该问题，当达到事先设定的最大深度时爬虫就不再像队列中添加该网页中的链接了。</p></li><li><p>SSL相关问题。在使用<code>urlopen</code>打开一个HTTPS链接时会验证一次SSL证书，如果不做出处理会产生错误提示“SSL: CERTIFICATE_VERIFY_FAILED”，可以通过以下两种方式加以解决：</p><ul><li><p>使用未经验证的上下文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import ssl</span><br><span class="line"></span><br><span class="line">request = urllib.request.Request(url=&apos;...&apos;, headers=&#123;...&#125;) </span><br><span class="line">context = ssl._create_unverified_context()</span><br><span class="line">web_page = urllib.request.urlopen(request, context=context)</span><br></pre></td></tr></table></figure></li><li><p>设置全局的取消证书验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import ssl</span><br><span class="line"></span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="2、前言"><a href="#2、前言" class="headerlink" title="2、前言"></a>2、前言</h2><h3 id="2-1-数据分析"><a href="#2-1-数据分析" class="headerlink" title="2.1 数据分析"></a>2.1 数据分析</h3><p>爬取网页信息可以使用很多的技术：</p><ol><li><p>获取网页信息：urllib、urllib3、requests</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requests为第三方的库，需要安装才能使用</span><br><span class="line">   </span><br><span class="line">pip install requests</span><br></pre></td></tr></table></figure></li><li><p>解析网页信息：beautifulsoup4(bs4)、re、xpath、lxml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bs4为第三方的库，需要安装才能使用</span><br><span class="line">   </span><br><span class="line">pip install beautifulsoup4</span><br><span class="line">   </span><br><span class="line">使用的时候 from bs4 import BeautifulSoup 这样导入</span><br></pre></td></tr></table></figure><p>Python 标准库中自带了 xml 模块，但是性能不够好，而且缺乏一些人性化的 API，相比之下，第三方库 lxml 是用 Cython 实现的，而且增加了很多实用的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安装lxml，在新版本中无法使用from lxml import etree</span><br><span class="line"></span><br><span class="line">pip install lxml 并不推荐这样去安装lxml</span><br><span class="line">   </span><br><span class="line">推荐安装的方法：访问网站(https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml)下载lxml的安装whl文件，然后进行安装。</span><br></pre></td></tr></table></figure><p><strong>注意：下载文件必须与python版本号、位数一致</strong></p></li></ol><p>我这儿下载的是lxml-4.2.1-cp36-cp36m-win_amd64.whl，安装命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install lxml-4.2.1-cp36-cp36m-win_amd64.whl</span><br></pre></td></tr></table></figure><p>截图：</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/lxml_whl.png" alt="图"></p><ol><li><p>动态数据解析</p><p>通用：selenium(自动化测试框架)</p></li></ol><h3 id="2-2-请求头分析"><a href="#2-2-请求头分析" class="headerlink" title="2.2 请求头分析"></a>2.2 请求头分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 浏览器告诉服务器可以接收的文本类型, */*表示任何类型都可以接收</span><br><span class="line">Accept: text/html, */*;q=0.8</span><br><span class="line"></span><br><span class="line"># 浏览器告诉服务器，数据可以压缩，页面可以解压数据然后进行渲染。做爬虫的时候，最好不要写该参数</span><br><span class="line">Accept-Encoding: gzip, deflate </span><br><span class="line"></span><br><span class="line"># 语言类型</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9 </span><br><span class="line"></span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line"></span><br><span class="line"># 保持连接</span><br><span class="line">Connection: keep-alive </span><br><span class="line"></span><br><span class="line"># 会话 </span><br><span class="line">Cookie: Hm_lvt_3bfcc098e0da26d58c321ba579b04b2f=1527581188,1528137133</span><br><span class="line"></span><br><span class="line"># 域名</span><br><span class="line">Host: www.cdtopspeed.com </span><br><span class="line"></span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line"># 用户代理, 使得服务器能够识别请求是通过浏览器请求过来的，其中包含浏览器的名称/版本等信息</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36</span><br></pre></td></tr></table></figure><p>其中在爬虫中最重要的就是User-Agent：在下面urllib的使用中就会详细的解释User-Agent的使用</p><h3 id="2-3-urllib的使用"><a href="#2-3-urllib的使用" class="headerlink" title="2.3 urllib的使用"></a>2.3 urllib的使用</h3><p>使用urllib来获取百度首页的源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">r = urllib.request.urlopen(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">print(r.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>按照我们的想法来说，输出的结果应该是百度首页的源码才对，但是输出却不对(多请求几次，就会出现如下的结果)，如下结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">location.replace(location.href.replace(<span class="string">"https://"</span>,<span class="string">"http://"</span>));</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;noscript&gt;&lt;meta http-equiv="refresh" content="0;url=http://www.baidu.com/"&gt;&lt;/noscript&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>以上的结果并不是我们想要的，我们可以来查看一下为什么会出现这种问题的原因。我们可以想到刚才说的，请求头中的最重要的参数User-Agent参数，该参数是用来告诉服务器，请求的url是来源于哪儿的，是来源于浏览器还是来源于其他地方的。如果是来源于非浏览器的会就不会返回源码信息给你的，直接拦截掉你的请求</p><p>分析以上代码中，默认提交的请求头中的User-Agent到底传递了什么值：</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/spider_01_useragent.png" alt="图"></p><p>接下来，就是优化以上的代码，实现目的就是告诉服务器我们这个请求是来源于浏览器的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">header = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/65.0.3325.181 Safari/537.36'</span>&#125;</span><br><span class="line"></span><br><span class="line">res = urllib.request.Request(<span class="string">'https://www.baidu.com'</span>, headers=header)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取url的页面源码</span></span><br><span class="line">r = urllib.request.urlopen(res)</span><br><span class="line"><span class="comment"># decode解码，encode编码</span></span><br><span class="line">print(r.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>按照这样去解析，就可以获取到百度的首页源代码了，展示部门代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;</span><br><span class="line">&lt;meta content=&quot;always&quot; name=&quot;referrer&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;theme-color&quot; content=&quot;#2932e1&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;</span><br><span class="line">&lt;link rel=&quot;search&quot; type=&quot;application/opensearchdescription+xml&quot; href=&quot;/content-search.xml&quot; title=&quot;百度搜索&quot; /&gt;</span><br><span class="line">&lt;link rel=&quot;icon&quot; sizes=&quot;any&quot; mask href=&quot;//www.baidu.com/img/baidu_85beaf5496f291521eb75ba38eacbd87.svg&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//s1.bdstatic.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t1.baidu.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t2.baidu.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t3.baidu.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t10.baidu.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t11.baidu.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t12.baidu.com&quot;/&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//b1.bdstatic.com&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;title&gt;百度一下，你就知道&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;style id=&quot;css_index&quot; index=&quot;index&quot; type=&quot;text/css&quot;&gt;html,body&#123;height:100%&#125;</span><br><span class="line">html&#123;overflow-y:auto&#125;</span><br><span class="line">body&#123;font:12px arial;text-align:;background:#fff&#125;</span><br><span class="line">body,p,form,ul,li&#123;margin:0;padding:0;list-style:none&#125;</span><br><span class="line">body,form,#fm&#123;position:relative&#125;</span><br><span class="line">td&#123;text-align:left&#125;</span><br><span class="line">img&#123;border:0&#125;</span><br><span class="line">a&#123;color:#00c&#125;</span><br><span class="line">a:active&#123;color:#f60&#125;</span><br><span class="line">input&#123;border:0;padding:0&#125;</span><br><span class="line">#wrapper&#123;position:relative;_position:;min-height:100%&#125;</span><br><span class="line">#head&#123;padding-bottom:100px;text-align:center;*z-index:1&#125;</span><br><span class="line"></span><br><span class="line">...忽略....</span><br><span class="line">...忽略....</span><br><span class="line">...忽略....</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="2-4-requests"><a href="#2-4-requests" class="headerlink" title="2.4 requests"></a>2.4 requests</h3><p><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">官网地址</a></p><p><strong>安装</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure><p><strong>发送请求</strong>，GET、POST、PUT、PATCH、DELETE </p><p>使用请求发送网络请求非常简单。</p><p>一开始要导入请求模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br></pre></td></tr></table></figure><p>然后，尝试获取某个网页。本例子中，我们来获取Github的公共时间线：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">'https://api.github.com/events'</span>)</span><br></pre></td></tr></table></figure><p>请求简便的API意味着所有HTTP请求类型都是显而易见的。例如，你可以这样发送一个HTTP POST请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, data = &#123;<span class="string">'key'</span>:<span class="string">'value'</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>传递URL参数</strong> </p><p>你也许经常想为URL的查询字符串（query string）传递某种数据。如果你是手工构造URL，那么数据会以键/值对的形式置于URL中，跟在一个问号的后面。例如， httpbin.org/get?key=val。</p><p>请求允许你使用params关键字参数，以一个字符串字典来提供这些参数。</p><p>举例来说，如果你想传递key1 = value1和key2 = value2到httpbin.org/get，那么你可以使用如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(&quot;http://httpbin.org/get&quot;, params=payload)</span><br></pre></td></tr></table></figure><p>通过打印输出该URL，你能看到URL已被正确确认编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(r.url)</span><br><span class="line"></span><br><span class="line">http://httpbin.org/get?key2=value2&amp;key1=value1</span><br></pre></td></tr></table></figure><p>注意字典里值为无的键都不会被添加到URL的查询字符串里。</p><p>你还可以将一个列表作为值传入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: [&apos;value2&apos;, &apos;value3&apos;]&#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(&apos;http://httpbin.org/get&apos;, params=payload)</span><br><span class="line"></span><br><span class="line">print(r.url)</span><br><span class="line"></span><br><span class="line">http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3</span><br></pre></td></tr></table></figure><p><strong>响应内容</strong> </p><p>我们能读取服务器响应的内容。再次以GitHub时间线为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">r = requests.get(&apos;https://api.github.com/events&apos;)</span><br><span class="line">r.text</span><br><span class="line"></span><br><span class="line">u&apos;[&#123;&quot;repository&quot;:&#123;&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https://github.com/...</span><br></pre></td></tr></table></figure><p>请求会自动解码来自服务器的内容。大多数unicode字符集都能被无缝地解码。</p><p>请求发出后，请求会基于HTTP头部对响应的编码作出有根据的推测。当你访问r.text之时，请求会使用其推测的文本编码。你可以找出请求使用了什么编码，并且能够使用r.encoding属性来改变它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.encoding</span><br><span class="line">&apos;utf-8&apos;</span><br><span class="line"></span><br><span class="line">r.encoding = &apos;ISO-8859-1&apos;</span><br></pre></td></tr></table></figure><p>如果你改变了编码，每当你访问r.text，请求都将会使用r.encoding的新值。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如HTTP和XML自身可以指定编码。这样的话，你应该使用r.content来找到编码，然后设置r.encoding为相应的编码。这样就能使用正确的编码解析r.text了。</p><p>在你需要的情况下，请求也可以使用定制的编码。如果你创建了自己的编码，并使用编解码器模块进行注册，你就可以轻松地使用这个解码器名称作为r.encoding的值，然后由Requests来为你处理编码</p><h3 id="2-5-ssl认证"><a href="#2-5-ssl认证" class="headerlink" title="2.5 ssl认证"></a>2.5 ssl认证</h3><p>什么是 SSL 证书？</p><p>SSL 证书就是遵守 SSL 安全套接层协议的服务器数字证书。</p><p>而 SSL 安全协议最初是由美国网景 Netscape Communication 公司设计开发的，全称为：安全套接层协议 (Secure Sockets Layer) ， 它指定了在应用程序协议 ( 如 HTTP 、 Telnet 、 FTP) 和 TCP/IP 之间提供数据安全性分层的机制，它是在传输通信协议 (TCP/IP) 上实现的一种安全协议，采用公开密钥技术，它为 TCP/IP 连接提供数据加密、服务器认证、消息完整性以及可选的客户机认证。由于此协议很好地解决了互联网明文传输的不安全问题，很快得到了业界的支持，并已经成为国际标准。</p><p>SSL 证书由浏览器中“受信任的根证书颁发机构”在验证服务器身份后颁发，具有网站身份验证和加密传输双重功能。</p><p>如果能使用 https:// 来访问某个网站，就表示此网站是部署了SSL证书。一般来讲，如果此网站部署了SSL证书，则在需要加密的页面会自动从 http:// 变为 https:// ，如果没有变，你认为此页面应该加密，您也可以尝试直接手动在浏览器地址栏的http后面加上一个英文字母“ s ”后回车，如果能正常访问并出现安全锁，则表明此网站实际上是部署了SSL证书，只是此页面没有做 https:// 链接；如果不能访问，则表明此网站没有部署 SSL证书。</p><p>案例:</p><p>访问加密的12306的网站</p><p>如果不忽略ssl的安全认证的话，网页的源码会提示ssl认证问题，需要提供ssl认证。我们在做爬虫的时候，自动设置忽略掉ssl认证即可。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import ssl</span><br><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    url = &apos;https://www.12306.cn/mormhweb/&apos;</span><br><span class="line">    # 忽略未经审核的ssl认证</span><br><span class="line">    context = ssl._create_unverified_context()</span><br><span class="line">    res = urllib.request.urlopen(url, context=context)</span><br><span class="line">    print(res.read().decode(&apos;utf-8&apos;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="3、数据采集和解析"><a href="#3、数据采集和解析" class="headerlink" title="3、数据采集和解析"></a>3、数据采集和解析</h2><p>通过<a href="./01.网络爬虫和相关工具.md">《网络爬虫和相关工具》</a>一文，我们已经了解到了开发一个爬虫需要做的工作以及一些常见的问题，至此我们可以对爬虫开发需要做的工作以及相关的技术做一个简单的汇总，这其中可能会有一些我们之前没有使用过的第三方库。</p><ol><li>下载数据 - urllib / requests / aiohttp。</li><li>解析数据 - re / lxml / beautifulsoup4（bs4）/ pyquery。</li><li>缓存和持久化 - pymysql / sqlalchemy / peewee/ redis / pymongo。</li><li>生成数字签名 - hashlib。</li><li>序列化和压缩 - pickle / json / zlib。</li><li>调度器 - 进程（multiprocessing） / 线程（threading） / 协程（coroutine）。</li></ol><p><strong>四种采集方式</strong> </p><p>四种采集方式的比较</p><table><thead><tr><th>抓取方法</th><th>速度</th><th>使用难度</th><th>备注</th></tr></thead><tbody><tr><td>正则表达式</td><td>快</td><td>困难</td><td>常用正则表达式<br>在线正则表达式测试</td></tr><tr><td>lxml</td><td>快</td><td>一般</td><td>需要安装C语言依赖库<br>唯一支持XML的解析器</td></tr><tr><td>Beautiful</td><td>较快/较慢（取决于解析器）</td><td>简单</td><td></td></tr><tr><td>PyQuery</td><td>较快</td><td>简单</td><td>Python版的jQuery</td></tr></tbody></table><blockquote><p>说明：Beautiful的解析器包括：Python标准库（html.parser）、lxml的HTML解析器、lxml的XML解析器和html5lib。</p></blockquote><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>如果你对正则表达式没有任何的概念，那么推荐先阅读<a href="">《正则表达式30分钟入门教程》</a>，然后再阅读我们之前讲解在Python中如何使用正则表达式一文。</p><p><strong>re正则匹配</strong> </p><p>匹配规则：（原始字符串’booby123’）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">^ 开头&apos;^b.*&apos;----以b开头的任意字符</span><br><span class="line"></span><br><span class="line">$ 结尾&apos;^b.*3$&apos;----以b开头，3结尾的任意字符</span><br><span class="line"></span><br><span class="line">* 任意长度（次数），≥0       </span><br><span class="line"></span><br><span class="line">? 非贪婪模式，非贪婪模式尽可能少的匹配所搜索的字符串 &apos;.*?(b.*?b).*&apos;----从左至右第一个b和的二个b之间的内容（包含b）</span><br><span class="line"></span><br><span class="line">+ 一次或多次</span><br><span class="line"></span><br><span class="line">&#123;2&#125; 指定出现次数2次</span><br><span class="line"></span><br><span class="line">&#123;2,&#125; 出现次数≥2次</span><br><span class="line"></span><br><span class="line">&#123;2,5&#125; 出现次数2≤x≤5</span><br><span class="line"></span><br><span class="line">| 或例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[z|f]ood”则匹配“zood”或“food”或&quot;zood&quot;。</span><br><span class="line"></span><br><span class="line">[] 中括号中任意一个符合即可（中括号里面没有分转义字符）   &apos;[abc]ooby123&apos;----只要开头符合[]中任意一个即可</span><br><span class="line"></span><br><span class="line">[^] 只要不出现[]的即可</span><br><span class="line"></span><br><span class="line">[a-Z] 从小a到大Z        &apos;1[48357][0-9]&#123;9&#125;&apos;----电话号码</span><br><span class="line"></span><br><span class="line">. 任意字符</span><br><span class="line"></span><br><span class="line">\s 匹配不可见字符 \n \t    &apos;你\s好&apos;----可以匹配‘你 好’</span><br><span class="line"></span><br><span class="line">\S 匹配可见字符，即普通字符</span><br><span class="line"></span><br><span class="line">\w 匹配下划线在内的任何单词字符</span><br><span class="line"></span><br><span class="line">\W 和上一个相反</span><br><span class="line"></span><br><span class="line">[\u4E00-\u9FA5] 只能匹配汉字</span><br><span class="line"></span><br><span class="line">() 要取出的信息就用括号括起来</span><br><span class="line"></span><br><span class="line">\d 数字</span><br></pre></td></tr></table></figure><h3 id="XPath语法与Lxml库"><a href="#XPath语法与Lxml库" class="headerlink" title="XPath语法与Lxml库"></a>XPath语法与Lxml库</h3><p><strong>XPATH 术语</strong> </p><p><a href="http://www.w3school.com.cn/xpath" target="_blank" rel="noopener">中文文档地址</a></p><p>在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。</p><p>请看下面这个 XML 文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;bookstore&gt;</span><br><span class="line"></span><br><span class="line">&lt;book&gt;</span><br><span class="line">  &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;</span><br><span class="line">  &lt;author&gt;J K. Rowling&lt;/author&gt; </span><br><span class="line">  &lt;year&gt;2005&lt;/year&gt;</span><br><span class="line">  &lt;price&gt;29.99&lt;/price&gt;</span><br><span class="line">&lt;/book&gt;</span><br><span class="line"></span><br><span class="line">&lt;/bookstore&gt;</span><br></pre></td></tr></table></figure><p>上面的XML文档中的节点例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bookstore&gt; （文档节点）</span><br><span class="line">&lt;author&gt;J K. Rowling&lt;/author&gt; （元素节点）</span><br><span class="line">lang=&quot;en&quot; （属性节点） </span><br><span class="line">基本值（或称原子值，Atomic value）</span><br><span class="line">基本值是无父或无子的节点。</span><br></pre></td></tr></table></figure><p><strong>节点关系</strong></p><p>父（Parent）、子（Children） 每个元素以及属性都有一个父。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bookstore&gt;</span><br><span class="line">&lt;book&gt;</span><br><span class="line">  &lt;title&gt;Harry Potter&lt;/title&gt;</span><br><span class="line">  &lt;author&gt;J K. Rowling&lt;/author&gt;</span><br><span class="line">  &lt;year&gt;2005&lt;/year&gt;</span><br><span class="line">  &lt;price&gt;29.99&lt;/price&gt;</span><br><span class="line">&lt;/book&gt;</span><br><span class="line">&lt;/bookstore&gt;</span><br></pre></td></tr></table></figure><p>book 元素是 title、author、year 以及 price 元素的父</p><p>title、author、year 以及 price 元素都是 book 元素的子</p><p>title、author、year 以及 price 元素都是同胞：</p><p>title 元素的先辈是 book 元素和 bookstore 元素</p><p>bookstore 的后代是 book、title、author、year 以及 price 元素</p><p><strong>选取节点</strong></p><p>XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点。</td></tr><tr><td>/</td><td>从根节点选取。</td></tr><tr><td>//</td><td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td></tr><tr><td>.</td><td>选取当前节点。</td></tr><tr><td>..</td><td>选取当前节点的父节点。</td></tr><tr><td>@</td><td>选取属性。</td></tr></tbody></table><p><strong>选取未知节点</strong> </p><p>XPath 通配符可用来选取未知的 XML 元素。</p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配任何元素节点。</td></tr><tr><td>@*</td><td>匹配任何属性节点。</td></tr><tr><td>node()</td><td>匹配任何类型的节点。</td></tr></tbody></table><p><strong>选取若干路径</strong> </p><p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p><p>爬取搜狐体育：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_code</span><span class="params">(url)</span>:</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36'</span></span><br><span class="line">    &#125;</span><br><span class="line">    req = urllib.request.Request(url, headers=headers)</span><br><span class="line">    res = urllib.request.urlopen(req)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_crawl</span><span class="params">(url)</span>:</span></span><br><span class="line">    res = get_code(url)</span><br><span class="line">    p1_url = re.findall(<span class="string">"&lt;a test=a href='(.+?)'"</span>, res.read().decode(<span class="string">'GBK'</span>))</span><br><span class="line">    <span class="keyword">return</span> p1_url</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_content</span><span class="params">(url)</span>:</span></span><br><span class="line">    res2 = get_code(url)</span><br><span class="line">    tree = etree.HTML(res2.read().decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    p2_title = tree.xpath(<span class="string">'//*[@id="article-container"]/div[2]/div[1]/div[1]/h1/text()'</span>)</span><br><span class="line">    p2_content = tree.xpath(<span class="string">'//*[@id="mp-editor"]/p/text()'</span>)</span><br><span class="line">    <span class="keyword">return</span> p2_title, p2_content</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    url = <span class="string">'http://sports.sohu.com/nba_a.shtml'</span></span><br><span class="line">    p_urls = get_crawl(url)</span><br><span class="line">    <span class="keyword">for</span> p_url <span class="keyword">in</span> p_urls:</span><br><span class="line">        result = get_content(p_url)</span><br><span class="line">        print(result)</span><br></pre></td></tr></table></figure><h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h3><p>Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间.—–引入<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">官网地址</a>的一句话</p><p><strong>安装</strong></p><p>Beautiful Soup 4 通过PyPi发布,所以如果你无法使用系统包管理安装,那么也可以通过 easy_install 或 pip 来安装.包的名字是 beautifulsoup4 ,这个包兼容Python2和Python3.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure><p><strong>创建 Beautiful Soup 对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup   <span class="comment"># 首先必须要导入 bs4 库</span></span><br><span class="line"></span><br><span class="line">html = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">soups  = BeautifulSoup(html)   <span class="comment"># 创建 beautifulsoup 对象</span></span><br><span class="line"><span class="comment"># 另外，我们还可以用本地 HTML 文件来创建对象，例如</span></span><br><span class="line"><span class="comment"># soup = BeautifulSoup(open('index.html'))</span></span><br></pre></td></tr></table></figure><p><strong>解析语法、find、find_all</strong></p><p><strong>find_all( name , attrs , recursive , text , </strong>kwargs )** </p><p>find_all() 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 查询所有a标签的内容</span><br><span class="line">soup.find_all(&apos;a&apos;)</span><br><span class="line"></span><br><span class="line">2. 查询所有a标签下class样式为bb的内容</span><br><span class="line">soup.find_all(&apos;a&apos;, &apos;bb&apos;)</span><br><span class="line"></span><br><span class="line">3. 查询所有id样式为cc的内容</span><br><span class="line">soup.find_all(id=&apos;cc&apos;</span><br></pre></td></tr></table></figure><h3 id="PyQuery"><a href="#PyQuery" class="headerlink" title="PyQuery"></a>PyQuery</h3><p>pyquery相当于jQuery的Python实现，可以用于解析HTML网页。</p><p><a href="http://pyquery.readthedocs.io/en/latest/" target="_blank" rel="noopener">官方文档</a><br><a href="http://jquery.cuishifeng.cn/" target="_blank" rel="noopener">jQuery参考文档</a>  </p><ol><li>存储：mysql、redis、mongodb、sqlalchemy</li><li>序列化：json</li><li>调度器：进程、线程、协程</li></ol><p><strong>PyQuery的基本使用</strong>  </p><p><strong>1.安装方法 </strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyquery</span><br></pre></td></tr></table></figure><p><strong>2.引用方法</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from pyquery import PyQuery as pq</span><br></pre></td></tr></table></figure><p><strong>3.简介</strong> </p><p>　pyquery 是类型jquery 的一个专供python使用的html解析的库，使用方法类似bs4。</p><p><strong>4.使用方法</strong> </p><p>4.1 初始化方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc =pq(html) <span class="comment">#解析html字符串</span></span><br><span class="line">doc =pq(<span class="string">"http://news.baidu.com/"</span>) <span class="comment">#解析网页</span></span><br><span class="line">doc =pq(<span class="string">"./a.html"</span>) <span class="comment">#解析html 文本</span></span><br></pre></td></tr></table></figure><p> 4.2 基本CSS选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from pyquery import PyQuery as pq</span><br><span class="line">html = &apos;&apos;&apos;</span><br><span class="line">    &lt;div id=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;ul class=&quot;s_from&quot;&gt;</span><br><span class="line">            asdasd</span><br><span class="line">            &lt;link href=&quot;http://asda.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">            &lt;link href=&quot;http://asda1.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">            &lt;link href=&quot;http://asda2.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">doc = pq(html)</span><br><span class="line">print doc(&quot;#wrap .s_from link&quot;)</span><br></pre></td></tr></table></figure><p>　　运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;http://asda.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">&lt;link href=&quot;http://asda1.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">&lt;link href=&quot;http://asda2.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br></pre></td></tr></table></figure><p>　　#是查找id的标签  .是查找class 的标签  link 是查找link 标签 中间的空格表示里层（注意层级关系以空格隔开） </p><p>4.3 查找子元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pyquery import PyQuery as pq</span><br><span class="line">html = &apos;&apos;&apos;</span><br><span class="line">    &lt;div id=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;ul class=&quot;s_from&quot;&gt;</span><br><span class="line">            asdasd</span><br><span class="line">            &lt;link href=&quot;http://asda.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">            &lt;link href=&quot;http://asda1.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">            &lt;link href=&quot;http://asda2.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">#查找子元素</span><br><span class="line">doc = pq(html)</span><br><span class="line">items=doc(&quot;#wrap&quot;)</span><br><span class="line">print(items)</span><br><span class="line">print(&quot;类型为:%s&quot;%type(items))</span><br><span class="line">link = items.find(&apos;.s_from&apos;)</span><br><span class="line">print(link)</span><br><span class="line">link = items.children()</span><br><span class="line">print(link)</span><br></pre></td></tr></table></figure><p>​    运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;ul class=&quot;s_from&quot;&gt;</span><br><span class="line">            asdasd</span><br><span class="line">            &lt;link href=&quot;http://asda.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">            &lt;link href=&quot;http://asda1.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">            &lt;link href=&quot;http://asda2.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">类型为:&lt;class &apos;pyquery.pyquery.PyQuery&apos;&gt;</span><br><span class="line">&lt;ul class=&quot;s_from&quot;&gt;</span><br><span class="line">            asdasd</span><br><span class="line">            &lt;link href=&quot;http://asda.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">            &lt;link href=&quot;http://asda1.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">            &lt;link href=&quot;http://asda2.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">&lt;ul class=&quot;s_from&quot;&gt;</span><br><span class="line">            asdasd</span><br><span class="line">            &lt;link href=&quot;http://asda.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">            &lt;link href=&quot;http://asda1.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">            &lt;link href=&quot;http://asda2.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>根据运行结果可以发现返回结果类型为pyquery，并且find方法和children 方法都可以获取里层标签</p><p> 4.4查找父元素 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">items=doc(<span class="string">".s_from"</span>)</span><br><span class="line">print(items)</span><br><span class="line"><span class="comment">#查找父元素</span></span><br><span class="line">parent_href=items.parent()</span><br></pre></td></tr></table></figure><p>parent可以查找出外层标签包括的内容，与之类似的还有parents,可以获取所有外层节点 </p><p>4.5 查找兄弟元素 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">items=doc(&quot;link.active1.a123&quot;)</span><br><span class="line">print(items)</span><br><span class="line">#查找兄弟元素</span><br><span class="line">siblings_href=items.siblings()</span><br></pre></td></tr></table></figure><p>​    根据运行结果可以看出，siblings 返回了同级的其他标签<br>    结论：子元素查找，父元素查找，兄弟元素查找，这些方法返回的结果类型都是pyquery类型，可以针对结果再次进行选择</p><p>4.6 遍历查找结果 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">its=doc(&quot;link&quot;).items()</span><br><span class="line">for it in its:</span><br><span class="line">    print(it)</span><br></pre></td></tr></table></figure><p>​    运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;link class=&quot;active1 a123&quot; href=&quot;http://asda.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br><span class="line">&lt;link class=&quot;active2&quot; href=&quot;http://asda1.com&quot;&gt;asdadasdad12312&lt;/link&gt;          </span><br><span class="line">&lt;link class=&quot;movie1&quot; href=&quot;http://asda2.com&quot;&gt;asdadasdad12312&lt;/link&gt;</span><br></pre></td></tr></table></figure><p>4.7获取属性信息 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">its=doc(&quot;link&quot;).items()</span><br><span class="line">for it in its:</span><br><span class="line">    print(it.attr(&apos;href&apos;))</span><br><span class="line">    print(it.attr.href)   #两种写法结果都一样</span><br></pre></td></tr></table></figure><p>4.8 获取文本 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">its=doc(&quot;link&quot;).items()</span><br><span class="line">for it in its:</span><br><span class="line">    print(it.text())</span><br></pre></td></tr></table></figure><p>4.9 获取 HTML信息 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">its=doc(&quot;link&quot;).items()</span><br><span class="line">for it in its:</span><br><span class="line">    print(it.html())</span><br></pre></td></tr></table></figure><p>​    运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt;asdadasdad12312&lt;/a&gt;</span><br><span class="line">asdadasdad12312</span><br><span class="line">asdadasdad12312</span><br></pre></td></tr></table></figure><p><strong>5.常用DOM操作</strong>  </p><p>5.1 addClass removeClass</p><p>　　添加，移除class标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">its=doc(&quot;link&quot;).items()</span><br><span class="line">for it in its:</span><br><span class="line">    print(&quot;添加:%s&quot;%it.addClass(&apos;active1&apos;))</span><br><span class="line">    print(&quot;移除:%s&quot;%it.removeClass(&apos;active1&apos;))</span><br></pre></td></tr></table></figure><p>需要注意的是已经存在的class标签不会继续添加 </p><p>5.2 attr css</p><p>　　attr 为获取/修改属性 css 添加style属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">its=doc(&quot;link&quot;).items()</span><br><span class="line">for it in its:</span><br><span class="line">    print(&quot;修改:%s&quot;%it.attr(&apos;class&apos;,&apos;active&apos;))</span><br><span class="line">    print(&quot;添加:%s&quot;%it.css(&apos;font-size&apos;,&apos;14px&apos;)</span><br></pre></td></tr></table></figure><p>attr css操作直接修改对象的 </p><p>5.3 remove 移除标签 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">its=doc(&quot;div&quot;)</span><br><span class="line">print(&apos;移除前获取文本结果:\n%s&apos;%its.text())</span><br><span class="line">it=its.remove(&apos;ul&apos;)</span><br><span class="line">print(&apos;移除后获取文本结果:\n%s&apos;%it.text())</span><br></pre></td></tr></table></figure><h2 id="4、并发、并行、同步、异步线程、进程"><a href="#4、并发、并行、同步、异步线程、进程" class="headerlink" title="4、并发、并行、同步、异步线程、进程"></a>4、并发、并行、同步、异步线程、进程</h2><h3 id="4-1-同步和异步、阻塞和非阻塞"><a href="#4-1-同步和异步、阻塞和非阻塞" class="headerlink" title="4.1 同步和异步、阻塞和非阻塞"></a>4.1 同步和异步、阻塞和非阻塞</h3><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>同步和异步是相对于操作结果来说，会不会等待结果</p><h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4><p>阻塞是在煮稀饭的过程中，你不能去干其他的事情。非阻塞是在煮稀饭的过程中，你还可以去做其他的事情。阻塞和非阻塞是相对于线程是否被阻塞</p><h4 id="同步和阻塞的区别"><a href="#同步和阻塞的区别" class="headerlink" title="同步和阻塞的区别"></a>同步和阻塞的区别</h4><p>同步是一个过程，阻塞是线程的一个状态。</p><p>当多个线程操作同一公共变量的时候可能会出现竞争的情况，这时候需要使用同步来防止多个线程同时占用资源的情况，让一个线程在运行状态中，另外的线程处于就绪状态，当前一个线程处于暂停状态的时候，后面的处于就绪状态的线程，获取到资源以后，获取到时间片以后就会处于运行状态了。所以阻塞是线程的一个状态而已</p><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><p>并发：从点餐系统看，该肯德基店只有一个负责点餐的收银员，而有2台收银点餐设备，服务员同时操作2个收银点餐终端，这叫并发操作收银点餐终端。</p><p>并行：肯德基为了拓展业务，提高同时服务的能力，在全世界开设分店，这叫并行。</p><p>如何实现并发呢：需要引入多进程，多线程，协程</p><h3 id="4-2-进程"><a href="#4-2-进程" class="headerlink" title="4.2 进程"></a>4.2 进程</h3><p><strong>概念</strong>：</p><p>进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。</p><p><strong>python实现进程</strong>：</p><p>multiprocessing模块就是跨平台版本的多进程模块。</p><p>multiprocessing模块提供了一个Process类来代表一个进程对象，</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">from random import randint</span><br><span class="line">from multiprocessing import Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def coding():</span><br><span class="line">    while True:</span><br><span class="line">        print(&apos;开始撸代码，PID是%s&apos; % os.getpid())</span><br><span class="line">        time.sleep(randint(1, 3))</span><br><span class="line">        print(&apos;写累了，不撸了，PID是%s&apos; % os.getpid())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def play_weixin():</span><br><span class="line">    while True:</span><br><span class="line">        print(&apos;玩一会微信，PID是%s&apos; % os.getpid())</span><br><span class="line">        time.sleep(randint(1,2))</span><br><span class="line">        print(&apos;不玩微信了，开始撸代码，PID是%s&apos; % os.getpid())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line"></span><br><span class="line">    # 创建进程</span><br><span class="line">    p1 = Process(target=coding)</span><br><span class="line">    p2 = Process(target=coding)</span><br><span class="line">    p3 = Process(target=play_weixin)</span><br><span class="line"></span><br><span class="line">    # 启动进程</span><br><span class="line">    p1.start()</span><br><span class="line">    # 阻塞进程p1</span><br><span class="line">    p1.join()</span><br><span class="line"></span><br><span class="line"># 启动进程</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line"></span><br><span class="line"># 主进程</span><br><span class="line">    while True:</span><br><span class="line">        time.sleep(3)</span><br><span class="line">        print(&apos;我是主进程，PID是%s&apos; % os.getpid())</span><br></pre></td></tr></table></figure><h4 id="杀掉进程"><a href="#杀掉进程" class="headerlink" title="杀掉进程"></a>杀掉进程</h4><p>按照上面案例代码运行的话，p1进程会一直阻塞，后面的p2和p3并不会执行。如果在windows中运行的代码，则直接运行‘启动任务管理器’去杀掉进程，这时候p2和p3的进程就会执行了，说明进程之间是相互没有关联的，互不影响的。如果在linux系统中，直接kill -9 PID，就可以杀掉进程了</p><h3 id="4-3-线程"><a href="#4-3-线程" class="headerlink" title="4.3 线程"></a>4.3 线程</h3><p>一个进程中的多个线程可以共享一个资源内存空间</p><p>Python的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</p><p>启动一个线程,创建threading的实例，然后直接start()就可以启动我们定义的线程了。</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>定义一个线程类，继承自threading.Thread</p><p>其中打印一下当前线程的名称，使用threading.current_thread().name来获取当前线程的名称。默认的Python就自动给线程命名为Thread-1，Thread-2……。当然我们也可以自定义线程的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class DataCopy(threading.Thread):</span><br><span class="line"></span><br><span class="line">    def __init__(self, dbname):</span><br><span class="line">        super(DataCopy, self).__init__()</span><br><span class="line">        self.dbName = dbname</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line"></span><br><span class="line">print(&apos;Thread %s is running&apos; % threading.current_thread().name)</span><br><span class="line">        print(&apos;开始备份数据库:%s&apos; % self.dbName)</span><br><span class="line"></span><br><span class="line">        time.sleep(5)</span><br><span class="line"></span><br><span class="line">        print(&apos;数据库%s备份结束&apos; % self.dbName)</span><br><span class="line">print(&apos;Thread %s is ended&apos; % threading.current_thread().name)</span><br></pre></td></tr></table></figure><p>启动一个线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread1 = DataCopy(&apos;database1&apos;)</span><br><span class="line"></span><br><span class="line">thread1.start()</span><br><span class="line"></span><br><span class="line"># 线程执行结束的输出提示</span><br><span class="line">print(&apos;备份结束&apos;)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/threading_many_join.png" alt="图"></p><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>当定义子线程为守护线程的话，当主线程结束了，不管子线程是否执行完，都会被直接给暂停掉。默认daemon为False</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">thread1 = DataCopy(&apos;database1&apos;)</span><br><span class="line">thread2 = DataCopy(&apos;database2&apos;)</span><br><span class="line"></span><br><span class="line"># 设置守护线程</span><br><span class="line">thread1.daemon = True</span><br><span class="line">thread2.daemon = True</span><br><span class="line"></span><br><span class="line"># 运行线程</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"># 线程执行结束的输出提示</span><br><span class="line">print(&apos;备份结束&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/threading_many_deamon.png" alt="图"></p><h4 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h4><p>解释: start和run的区别</p><p>start() 方法是启动一个子线程，线程名就是我们定义的name，或者默认的线程名Thread-1， Thread-2……</p><p>run() 方法并不启动一个新线程，就是在主线程中调用了一个普通函数而已。</p><p>代码1，先使用start()启动线程，并且打印当前线程的名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread1 = DataCopy(&apos;database1&apos;)</span><br><span class="line">thread2 = DataCopy(&apos;database2&apos;)</span><br><span class="line"></span><br><span class="line"># 使用start启动，两个线程同时执行</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"># 线程执行结束的输出提示</span><br><span class="line">print(&apos;备份结束&apos;)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/threading_many_start.png" alt="图"></p><p>代码2，使用run()启动线程，并且打印当前线程的名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thread1 = DataCopy(&apos;database1&apos;)</span><br><span class="line">thread2 = DataCopy(&apos;database2&apos;)</span><br><span class="line"></span><br><span class="line">thread1.run()</span><br><span class="line">thread2.run()</span><br><span class="line"></span><br><span class="line"># 线程执行结束的输出提示</span><br><span class="line">print(&apos;备份结束&apos;)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/threading_many_run.png" alt="图"></p><h3 id="4-4-线程锁"><a href="#4-4-线程锁" class="headerlink" title="4.4 线程锁"></a>4.4 线程锁</h3><p>使用线程时最不愿意遇到的情况就是多个线程竞争资源，在这种情况下为了保证资源状态的正确性，我们可能需要对资源进行加锁保护的处理，这一方面会导致程序失去并发性，另外如果多个线程竞争多个资源时，还有可能因为加锁方式的不当导致死锁。</p><p>要实现将资源和持有资源的线程进行绑定的操作，最简单的做法就是使用threading模块的local类，在网络爬虫开发中，就可以使用local类为每个线程绑定一个MySQL数据库连接或Redis客户端对象，这样通过线程可以直接获得这些资源，既解决了资源竞争的问题，又避免了在函数和方法调用时传递这些资源。</p><h4 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h4><p>线程锁：其实并不是给资源加锁, 而是用锁去锁定资源，你可以定义多个锁,当你需要独占某一资源时，任何一个锁都可以锁这个资源，就好比你用不同的锁都可以把相同的一个门锁住是一个道理</p><p>基本语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#创建锁</span><br><span class="line">mutex = threading.Lock()</span><br><span class="line">#锁定</span><br><span class="line">mutex.acquire([timeout])</span><br><span class="line">#释放</span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure><p>代码：怎么使用锁去锁住资源，释放锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">counter = 0</span><br><span class="line"># 只是定义一个锁,并不是给资源加锁,你可以定义多个锁,像下两行代码,当你需要占用这个资源时，任何一个锁都可以锁这个资源</span><br><span class="line">counter_lock = threading.Lock()</span><br><span class="line">counter_lock2 = threading.Lock()</span><br><span class="line">counter_lock3 = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 可以使用上边三个锁的任何一个来锁定资源</span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    # 使用类定义thread，继承threading.Thread</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        super(MyThread, self).__init__()</span><br><span class="line">        self.name = &quot;Thread-&quot; + str(name)</span><br><span class="line"></span><br><span class="line">    def run(self):  # run函数必须实现</span><br><span class="line">        # 多线程是共享资源的，使用全局变量</span><br><span class="line">        global counter, counter_lock</span><br><span class="line">        # 当需要独占counter资源时，必须先锁定，这个锁可以是任意的一个锁，可以使用上边定义的3个锁中的任意一个</span><br><span class="line">        time.sleep(1);</span><br><span class="line">        if counter_lock.acquire():</span><br><span class="line">            counter += 1</span><br><span class="line">            print(&quot;I am %s, set counter:%s&quot; % (self.name, counter))</span><br><span class="line">            # 使用完counter资源必须要将这个锁打开，让其他线程使用</span><br><span class="line">            counter_lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    for i in range(1, 101):</span><br><span class="line">        my_thread = MyThread(i)</span><br><span class="line">        my_thread.start()</span><br></pre></td></tr></table></figure><p>以上代码，只是教会你怎么去使用锁，锁住资源，当一个线程在使用锁住的资源的时候，其他线程则无法再使用该资源了，起到了很好的避免资源的竞争。</p><p><strong>多线程去打印输出自增的全局变量</strong> </p><p>定义一个简单的多线程，主要功能是用于打印全局递增的变量参数，并打印线程名。</p><p>可以不妨想想，如果启动多线程对同一全局变量进行递增操作的话，就有可能多个线程同时获取到全局变量，然后进行递增操作。可想而知，如果是这样的话，那么打印出来的变量就有可能会重复。这就是出现了一个进程中，多线程同时共享一个资源的时候，出现的资源竞争的问题了。我们先查看一下代码的运行结果，然后进行分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        global n, lock</span><br><span class="line"></span><br><span class="line"># 休眠1秒钟</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 线程主要打印循环地址的n值，和对于的线程的名称，线程名也可以使用self.name来获取</span><br><span class="line">        print(n, threading.current_thread().name)</span><br><span class="line">        n += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line"></span><br><span class="line"># 设置全局变量</span><br><span class="line">    n = 1</span><br><span class="line">    ThreadList = []</span><br><span class="line"># 创建线程锁</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"># 创建20个线程</span><br><span class="line">    for i in range(1, 20):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        ThreadList.append(t)</span><br><span class="line"></span><br><span class="line"># 启动线程</span><br><span class="line">    for t in ThreadList:</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"># 阻塞线程</span><br><span class="line">    for t in ThreadList:</span><br><span class="line">        t.join()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1 Thread-2</span><br><span class="line">1 Thread-3</span><br><span class="line">1 Thread-1</span><br><span class="line">4 Thread-7</span><br><span class="line">4 Thread-5</span><br><span class="line">4 Thread-9</span><br><span class="line">4 Thread-4</span><br><span class="line">5 Thread-6</span><br><span class="line">6 Thread-11</span><br><span class="line">7 Thread-10</span><br><span class="line">9 Thread-8</span><br><span class="line">12 Thread-15</span><br><span class="line">12 Thread-19</span><br><span class="line">12 Thread-18</span><br><span class="line">12 Thread-16</span><br><span class="line">12 Thread-17</span><br><span class="line">14 Thread-12</span><br><span class="line">18 Thread-14</span><br><span class="line">19 Thread-13</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>分析：</p><p>很明显的在我们的执行结果中，打印的全局变量n中有很多重复的，这就印证了我们的多线程在共享资源上存在不可避免的资源竞争的关系。为了解决这种资源的竞争，我们可以采取线程锁的形式去避免对资源的竞争</p><p><strong>优化多线程打印输出自增的全局变量</strong> </p><p>代码优化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def run(self):</span><br><span class="line">    global n, lock</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 判断是否锁定了资源</span><br><span class="line">    if lock.acquire():</span><br><span class="line"></span><br><span class="line"># 如果锁定了资源，则打印如下的全局变量n和线程名，并且全局变量n自增1</span><br><span class="line">        print(n, self.name)</span><br><span class="line">        n += 1</span><br><span class="line"></span><br><span class="line"># 释放锁</span><br><span class="line">        lock.release()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1 Thread-2</span><br><span class="line">2 Thread-3</span><br><span class="line">3 Thread-1</span><br><span class="line">4 Thread-4</span><br><span class="line">5 Thread-5</span><br><span class="line">6 Thread-8</span><br><span class="line">7 Thread-9</span><br><span class="line">8 Thread-12</span><br><span class="line">9 Thread-13</span><br><span class="line">10 Thread-6</span><br><span class="line">11 Thread-16</span><br><span class="line">12 Thread-17</span><br><span class="line">13 Thread-18</span><br><span class="line">14 Thread-7</span><br><span class="line">15 Thread-19</span><br><span class="line">16 Thread-11</span><br><span class="line">17 Thread-10</span><br><span class="line">18 Thread-15</span><br><span class="line">19 Thread-14</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>分析：在优化的代码中，我们先建立了一个threading.Lock类对象lock,在run方法里，我们使用lock.acquire()获得了这个锁。此时，其他的线程就无法再获得该锁了，他们就会阻塞在“if lock.acquire()”这里，直到锁被另一个线程释放：lock.release()。所以，if语句中的内容就是一块完整的代码，不会再存在执行了一半就暂停去执行别的线程的情况。所以最后结果是整齐的。完美的解决了多线程竞争同一资源造成的问题了。</p><h2 id="5、异步I-O"><a href="#5、异步I-O" class="headerlink" title="5、异步I/O"></a>5、异步I/O</h2><h3 id="协程的概念"><a href="#协程的概念" class="headerlink" title="协程的概念"></a>协程的概念</h3><p>协程（coroutine）通常又称之为微线程或纤程，它是相互协作的一组子程序（函数）。所谓相互协作指的是在执行函数A时，可以随时中断去执行函数B，然后又中断继续执行函数A。注意，这一过程并不是函数调用（因为没有调用语句），整个过程看似像多线程，然而协程只有一个线程执行。协程通过<code>yield</code>关键字和 <code>send()</code>操作来转移执行权，协程之间不是调用者与被调用者的关系。</p><p>协程的优势在于以下两点：</p><ol><li>执行效率极高，因为子程序（函数）切换不是线程切换，由程序自身控制，没有切换线程的开销。</li><li>不需要多线程的锁机制，因为只有一个线程，也不存在竞争资源的问题，当然也就不需要对资源加锁保护，因此执行效率高很多。</li></ol><blockquote><p>说明：协程适合处理的是I/O密集型任务，处理CPU密集型任务并不是它的长处，如果要提升CPU的利用率可以考虑“多进程+协程”的模式。</p></blockquote><p><strong>历史回顾</strong> </p><ol><li>Python 2.2：第一次提出了生成器（最初称之为迭代器）的概念（PEP 255）。</li><li>Python 2.5：引入了将对象发送回暂停了的生成器这一特性即生成器的<code>send()</code>方法（PEP 342）。</li><li>Python 3.3：添加了<code>yield from</code>特性，允许从迭代器中返回任何值（注意生成器本身也是迭代器），这样我们就可以串联生成器并且重构出更好的生成器。</li><li>Python 3.4：引入<code>asyncio.coroutine</code>装饰器用来标记作为协程的函数，协程函数和<code>asyncio</code>及其事件循环一起使用，来实现异步I/O操作。</li><li>Python 3.5：引入了<code>async</code>和<code>await</code>，可以使用<code>async def</code>来定义一个协程函数，这个函数中不能包含任何形式的<code>yield</code>语句，但是可以使用<code>return</code>或<code>await</code>从协程中返回值。</li></ol><p><strong>在将协程的时候，需要分别引入迭代器和生成器的含义以及案例</strong></p><p><strong>迭代器</strong> </p><p>迭代器和生成器都是python中最重要的知识点。迭代器可以遍历整个对象，在你需要取值的时候，调用next就可以依次获取迭代器中的下一个值，在迭代中中只能往下取值，不能再往上取值的</p><p>案例代码：</p><p>声明一个列表[1，2，3，4]，然后使用iter()去创建一个迭代器，然后依次调用<strong>next</strong>()就可以获取到迭代器中的下一个值了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = iter([1, 2, 3, 4])</span><br><span class="line">print(type([1, 2, 3, 4]))</span><br><span class="line"></span><br><span class="line">print(type(s))</span><br><span class="line">print(s.__next__())</span><br><span class="line">print(s.__next__())</span><br><span class="line">print(s.__next__())</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;list&apos;&gt;</span><br><span class="line">&lt;class &apos;list_iterator&apos;&gt;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p><strong>生成器</strong> </p><p>什么是生成器：使用了 yield 的函数被称为生成器（generator）。生成器函数返回的结果就是一个迭代器，只能用于迭代操作。既然是迭代器了，就有<strong>next</strong>()的属性了。</p><p>那生成器是怎么工作的呢：在调用生成器运行的过程中，当在第一次运行的时候，在遇到yield时函数会暂停并保持当前所有的运行信息，返回一个yield的值，当再次<strong>next</strong>()的时候，才会在当前代码位置进行运行。</p><p>案例代码： 实现斐波那契算法 0 1 1 2 3 5 8 13 21 34 55</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fibonacci(n):</span><br><span class="line">    # 生成器函数 - 斐波那契</span><br><span class="line">    a, b, counter = 0, 1, 0</span><br><span class="line">    while True:</span><br><span class="line">        if counter &gt; n:</span><br><span class="line">            return</span><br><span class="line">        yield a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line"></span><br><span class="line">    f = fibonacci(10)  # f 是一个迭代器，由生成器返回生成</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            # print(next(f), end=&quot; &quot;)</span><br><span class="line">            print(f.__next__(), end=&quot; &quot;)</span><br><span class="line">        except StopIteration:</span><br><span class="line">            # 如果获取到最后一个的时候，再获取next就会提示StopIteration的异常了</span><br><span class="line">            sys.exit()</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 2 3 5 8 13 21 34 55 </span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>执行线路图：</p><p>查看执行的流程可以使用debug模式去运行，通过断点调试可以很清晰的了解到整个代码的运行流程。</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/yield_shenchengqi.png" alt="图"></p><p><strong>协程例子</strong> </p><p>案例代码： 消费者和生产者模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def consumer():</span><br><span class="line">    r = &apos;1xx&apos;</span><br><span class="line">    while True:</span><br><span class="line">        n = yield r</span><br><span class="line">        if not n:</span><br><span class="line">            return</span><br><span class="line">        print(&apos;[CONSUMER] 吃鸡翅 %s...&apos; % n)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        r = &apos;吃完啦，饱饱的了&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def produce(customer):</span><br><span class="line">    # 启动迭代器</span><br><span class="line">    customer.__next__()</span><br><span class="line">    # 设置变量参数为0</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 3:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print(&apos;[PRODUCER] 做鸡翅 %s...&apos; % n)</span><br><span class="line">        # 想customer中传递变量n，直接跳到consumer中执行</span><br><span class="line">        r = customer.send(n)</span><br><span class="line">        print(&apos;[PRODUCER] 吃鸡翅状态 return: %s&apos; % r)</span><br><span class="line">    # 关闭消费者</span><br><span class="line">    customer.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print(&apos;开始协程&apos;)</span><br><span class="line">    customer = consumer()</span><br><span class="line">    produce(customer)</span><br><span class="line">    print(&apos;结束协程&apos;)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">开始协程</span><br><span class="line">[PRODUCER] 做鸡翅 1...</span><br><span class="line">[CONSUMER] 吃鸡翅 1...</span><br><span class="line">[PRODUCER] 吃鸡翅状态 return: 吃完啦，饱饱的了</span><br><span class="line">[PRODUCER] 做鸡翅 2...</span><br><span class="line">[CONSUMER] 吃鸡翅 2...</span><br><span class="line">[PRODUCER] 吃鸡翅状态 return: 吃完啦，饱饱的了</span><br><span class="line">[PRODUCER] 做鸡翅 3...</span><br><span class="line">[CONSUMER] 吃鸡翅 3...</span><br><span class="line">[PRODUCER] 吃鸡翅状态 return: 吃完啦，饱饱的了</span><br><span class="line">结束协程</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>代码分析：</p><ol><li><p>在获取迭代器的时候，有三种获取方式</p><p>next(customer)</p><p>customer.send(None)</p><p>customer.<strong>next</strong>()</p></li></ol><p>注意:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">customer函数是一个generator（生成器），把一个customer传入produce后：</span><br><span class="line"></span><br><span class="line">首先调用next()启动生成器；</span><br><span class="line"></span><br><span class="line">然后，一旦生产了东西，通过customer.send(n)切换到consumer执行；</span><br><span class="line"></span><br><span class="line">customer通过yield拿到消息，处理，又通过yield把结果传回；</span><br><span class="line"></span><br><span class="line">produce拿到customer处理的结果，继续生产下一条消息；</span><br><span class="line"></span><br><span class="line">produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</span><br><span class="line"></span><br><span class="line">整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</span><br></pre></td></tr></table></figure><p>重点：区分next()和send()的区别</p><p>其实next()和send()在一定意义上作用是相似的，区别是send()可以传递yield表达式的值进去，而next()不能传递特定的值，只能传递None进去。因此，我们可以看做next() 和 send(None) 作用是一样的。需要提醒的是，第一次调用时，请使用next()语句或是send(None)，不能使用send发送一个非None的值，否则会直接报错</p><h3 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h3><p><a href="http://aiohttp.readthedocs.io/en/stable/" target="_blank" rel="noopener">官方文档</a></p><p>aiohttp是什么，官网上有这样一句话介绍：Async HTTP client/server for asyncio and Python，是异步的HTTP框架 </p><p><strong>安装</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install aiohttp</span><br></pre></td></tr></table></figure><p><strong>爬取豆瓣电影资源</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import aiohttp</span><br><span class="line">import json</span><br><span class="line">import asyncio</span><br><span class="line">from pymongo import MongoClient</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DouBan(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.tag_url = &apos;https://movie.douban.com/j/search_tags?type=movie&amp;source=&apos;</span><br><span class="line">        self.bash_url = &apos;https://movie.douban.com/j/search_subjects?type=movie&amp;tag=&#123;tag&#125;&amp;sort=recommend&amp;page_limit=20&amp;page_start=&#123;page_start&#125;&apos;</span><br><span class="line">        self.tag_key = []</span><br><span class="line">        self.max_page = 10</span><br><span class="line">        client = MongoClient(host=&apos;127.0.0.1&apos;, port=27017)</span><br><span class="line">        db = client[&apos;unsplash&apos;]</span><br><span class="line">        self.collection = db[&apos;images&apos;]</span><br><span class="line"></span><br><span class="line">    async def get_img_info(self):</span><br><span class="line">        async with aiohttp.ClientSession() as session:</span><br><span class="line">            # 获取电影分类的信息</span><br><span class="line">            async with session.get(self.tag_url) as tag_rsponse:</span><br><span class="line">                self.tag_key = self.parse_tag(await tag_rsponse.text())</span><br><span class="line">            print(self.tag_key)</span><br><span class="line">            # 循环去获取网页api内容信息</span><br><span class="line">            for key in self.tag_key:</span><br><span class="line">                for page in range(0, self.max_page):</span><br><span class="line">                    async with session.get(self.bash_url.format(tag=key, page_start=page*20)) as response:</span><br><span class="line">                        await self.parse(await response.text())</span><br><span class="line"></span><br><span class="line">    def parse_tag(self, response):</span><br><span class="line">        json_data = json.loads(response)[&apos;tags&apos;]</span><br><span class="line">        return json_data</span><br><span class="line"></span><br><span class="line">    async def parse(self,response):</span><br><span class="line">        json_data = json.loads(response)[&apos;subjects&apos;]</span><br><span class="line">        for data in json_data:</span><br><span class="line">            await self.do_insert(data)</span><br><span class="line"></span><br><span class="line">    async def do_insert(self, document):</span><br><span class="line">        try:</span><br><span class="line">            result = self.collection.insert_one(document)</span><br><span class="line">        except BaseException as e:</span><br><span class="line">            print(&apos;error%s&apos; % e)</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;result %s&apos; % repr(result.inserted_id))</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        loop = asyncio.get_event_loop()</span><br><span class="line">        tasks = [self.get_img_info()]</span><br><span class="line">        loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    us = DouBan()</span><br><span class="line">    us.run()</span><br></pre></td></tr></table></figure><h2 id="6、数据持久化"><a href="#6、数据持久化" class="headerlink" title="6、数据持久化"></a>6、数据持久化</h2><h3 id="1-Redis介绍"><a href="#1-Redis介绍" class="headerlink" title="1.Redis介绍"></a>1.Redis介绍</h3><p>Redis是REmote DIctionary Server的缩写，它是一个用ANSI C编写的高性能的key-value存储系统，与其他的key-value存储系统相比，Redis有以下一些特点（也是优点）：</p><ul><li>的Redis的读写性能极高，并且有丰富的特性（发布/订阅，事务，通知等）。</li><li>Redis的支持数据的持久化（RDB和AOF两种方式），可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis的不仅仅支持简单的键 - 值类型的数据，同时还提供哈希，列表，设置，zset，hyperloglog，地理等数据类型。</li><li>Redis的支持主从复制（实现读写分析）以及哨兵模式（监控主是否宕机并调整配置）。</li></ul><p>Redis的在CentOS的中的安装配置已经上章文章中已经整理好了，如需查看自行跳转过去查看，<a href="https://github.com/coco369/knowledge/blob/master/sql/redis.md" target="_blank" rel="noopener">地址</a> .Redis有着非常丰富的数据类型，也有很多的命令来操作这些数据，具体的内容可以查看<a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis的命令参考</a>，在这个网站上，除了Redis的的命令参考，还有Redis的的详细文档，其中包括了通知，事务，主从复制，持久化，哨兵，集群等内容。</p><p><strong>在Python程序中使用Redis</strong> </p><p>可以使用画中画安装Redis的模块.redis模块的核心是名为Redis的的类，该类的对象代表一个Redis的客户端，通过该客户端可以向Redis的服务器发送命令并获取执行的结果。我们在Redis的客户端中使用的命令基本上就是Redis的对象可以接收的消息。</p><p>首先：安装的Redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install redis</span><br></pre></td></tr></table></figure><p><strong>简单案例</strong> </p><p>该案例：用户在登录的时候，先验证传入的用户名和密码是否在Redis的中，是否能验证通过，如果不能验证通过的话，就去MySQL的数据库中验证，如果验证成功则同步的Redis中用户的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">import pymysql</span><br><span class="line">import redis</span><br><span class="line"></span><br><span class="line"># 访问mysql数据库</span><br><span class="line">def con_mysql(sql):</span><br><span class="line">db = pymysql.connect(</span><br><span class="line">host=&apos;127.0.0.1&apos;,</span><br><span class="line">user=&apos;root&apos;, </span><br><span class="line">passwd=&apos;123456&apos;,</span><br><span class="line">port=3306,</span><br><span class="line">db=&apos;srs&apos;,</span><br><span class="line">charset=&apos;utf8&apos;)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">cursor.execute(sql)</span><br><span class="line">data = cursor.fetchall()</span><br><span class="line">db.close()</span><br><span class="line">return data</span><br><span class="line"></span><br><span class="line">def con_redis()</span><br><span class="line">    r = redis.Redis(host=&apos;47.92.164.198&apos;, port=6379)</span><br><span class="line">    return r</span><br><span class="line"></span><br><span class="line">def excute_redis(r, passwd, name):</span><br><span class="line">    r_name = r.hget(&apos;user&apos;,&apos;name&apos;)</span><br><span class="line">    r_passwd = r.hget(&apos;user&apos;, &apos;passwd&apos;)</span><br><span class="line">    r_name = r_name.decode(&apos;utf8&apos;)</span><br><span class="line">    r_passwd = r_passwd.decode(&apos;utf8&apos;)</span><br><span class="line">    if name == r_name and passwd == r_passwd:</span><br><span class="line">    return True, &apos;登录成功&apos;</span><br><span class="line">    else:</span><br><span class="line">    return False, &apos;登录失败&apos;</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line"># 获取传入的姓名和密码参数</span><br><span class="line">if len(sys.argv):</span><br><span class="line">name = sys.argv[1]</span><br><span class="line">passwd = sys.argv[2]</span><br><span class="line">    # 传入redis中，进行校验</span><br><span class="line">r = con_redis()</span><br><span class="line">result = excute_redis(r, passwd, name)</span><br><span class="line">if not result[0]:</span><br><span class="line"># 查询mysql数据库</span><br><span class="line">sql = &apos;&apos;&apos;select * from stu where name=&quot;%s&quot; and passwd=&quot;%s&quot;&apos;&apos;&apos; % (name, passwd)</span><br><span class="line">print(sql)</span><br><span class="line">data = con_mysql(sql)</span><br><span class="line">if data:</span><br><span class="line">r = con_redis()</span><br><span class="line">    # r = redis.Redis(host=&apos;47.92.164.198&apos;, port=6379)</span><br><span class="line">    r.hset(&apos;user&apos;, &apos;name&apos;, name)</span><br><span class="line">    r.hset(&apos;user&apos;, &apos;passwd&apos;, passwd)</span><br><span class="line">    print(&apos;刷新redis，登录成功&apos;)</span><br><span class="line">else:</span><br><span class="line">print(&apos;用户名和密码错误&apos;)</span><br><span class="line">else:</span><br><span class="line">print(&apos;redis中数据正确，登录成功&apos;)</span><br></pre></td></tr></table></figure><h3 id="2-mongodb介绍"><a href="#2-mongodb介绍" class="headerlink" title="2. mongodb介绍"></a>2. mongodb介绍</h3><p>MongoDB的是2009年年问世的一个面向文档的数据库管理系统，由C ++语言编写，旨在为网络应用提供可扩展的高性能数据存储解决方案。虽然在划分类别的时候后，MongoDB的被认为是的NoSQL的产品，但是它更像一个介于关系数据库和非关系数据库之间的产品，在非关系数据库中它功能最丰富，最像关系数据库。</p><p>MongoDB的将数据存储为一个文档，一个文档由一系列的“键值对”组成，其文档类似于JSON对象，但是MongoDB的对JSON进行了二进制处理（能够更快的定位键和值），因此其文档的存储格式称为BSON。关于JSON和BSON的差别大家可以看看MongoDB官方网站的文章<a href="https://www.mongodb.com/json-and-bson" target="_blank" rel="noopener">“JSON和BSON”</a>。</p><p>目前，MongoDB中已经提供了对Windows中的MacOS，Linux和Solaris等多个平台的支持，而且也提供了多种开发语言的驱动程序，Python的当然是其中之一。</p><p><a href="https://github.com/coco369/knowledge/blob/master/sql/mongodb.md" target="_blank" rel="noopener">MongoDB中安装的配置</a>以及<a href="https://github.com/coco369/knowledge/blob/master/sql/mongodb%E8%AF%AD%E6%B3%95.md" target="_blank" rel="noopener">语法</a>操作都整理好了，可以自行前往回顾，熟悉语法。</p><p><strong>在python中操作mongodb</strong> </p><p>通过PIP安装pymongo来实现对MongoDB中的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pymongo</span><br></pre></td></tr></table></figure><p>简单的访问蒙戈，并打印文档中的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pymongo import MongoClient</span><br><span class="line"></span><br><span class="line">client = MongoClient(&apos;mongodb://45.76.206.145:27017&apos;)</span><br><span class="line">db = client.spider</span><br><span class="line"></span><br><span class="line">for student in db.students.find():</span><br><span class="line">    print(student)</span><br></pre></td></tr></table></figure><h2 id="7、动态解析"><a href="#7、动态解析" class="headerlink" title="7、动态解析"></a>7、动态解析</h2><p>根据权威机构发布的全球互联网可访问性审计报告，全球约有四分之三的网站其内容或部分内容是通过JavaScript动态生成的，这就意味着在浏览器窗口中“查看网页源代码”时无法在HTML代码中找到这些内容，也就是说我们之前用的抓取数据的方式无法正常运转了。解决这样的问题基本上有两种方案：</p><blockquote><p>一是JavaScript逆向工程；</p></blockquote><blockquote><p>另一种是渲染JavaScript获得渲染后的内容。</p></blockquote><h3 id="JavaScript逆向工程"><a href="#JavaScript逆向工程" class="headerlink" title="JavaScript逆向工程"></a>JavaScript逆向工程</h3><p>我们以<a href="https://movie.douban.com/explore#!type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;sort=recommend&amp;page_limit=20&amp;page_start=0" target="_blank" rel="noopener">豆瓣电影</a>为例，说明什么是JavaScript逆向工程。其实所谓的JavaScript逆向工程就是找到通过Ajax请求动态获取数据的接口。</p><p>但是当我们在浏览器中通过右键菜单“显示网页源代码”的时候，居然惊奇的发现页面的HTML代码中连一个电影的名称都搜索不到。</p><p>那网页中的数据到底是怎么加载出来的呢，其实网页中的数据就是一个动态加载出来的。可以在浏览器的“开发人员工具”的“网络”中可以找到获取这些图片数据的网络API接口，如下图所示。</p><p>那么结论就很简单了，只要我们找到了这些网络API接口，那么就能通过这些接口获取到数据，当然实际开发的时候可能还要对这些接口的参数以及接口返回的数据进行分析，了解每个参数的意义以及返回的JSON数据的格式，这样才能在我们的爬虫中使用这些数据。</p><h3 id="selenium自动框架"><a href="#selenium自动框架" class="headerlink" title="selenium自动框架"></a>selenium自动框架</h3><p>使用自动化测试工具Selenium，它提供了浏览器自动化的API接口，这样就可以通过操控浏览器来获取动态内容。首先可以使用pip来安装Selenium。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>我们通过Selenium实现对Chrome浏览器的操控，如果要操控其他的浏览器，可以创对应的浏览器对象，例如Chrome、Firefox、Edge等，还有手机端的浏览器Android、BlackBerry等，另外无界面浏览器PhantomJS也同样支持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser = webdriver.Ie()</span><br><span class="line">browser = webdriver.Opera()</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser = webdriver.PhantomJS()</span><br></pre></td></tr></table></figure><p>这样我们就完成了一个浏览器对象的初始化，接下来我们要做的就是调用browser对象，让其执行各个动作，就可以模拟浏览器操作了。</p><p>案例中我们使用Chrome浏览器，在模拟Chrome浏览器的时候，如果报如下的错误的话，说明你没有Chrome的驱动。接下来就是添加Chrome的驱动到我们的环境变频path中，或者在程序中指定Chrome驱动的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selenium.common.exceptions.WebDriverException: Message: &apos;chromedriver&apos; executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home</span><br></pre></td></tr></table></figure><p>驱动已经下载好了，保存地址在(spider/chromedriver_win32/)中</p><h4 id="访问url"><a href="#访问url" class="headerlink" title="访问url"></a>访问url</h4><p>可以用get()方法来请求一个网页，参数传入链接URL即可</p><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p>在浏览器中的操作，都可以通过selenium来完成，比如填充表单，模拟点击等等。那我们在进行这些操作的时候，首先需要知道我们要填充表单的位置在哪儿，模拟点击的按钮在哪儿。那怎么去获取这些信息呢。selenium中获取元素的方法有很多。</p><p><strong>获取单个元素</strong> </p><p>大概解释一下如下用法:</p><blockquote><p>find_element_by_name()是根据Name值获取</p></blockquote><blockquote><p>ind_element_by_id()是根据ID获取</p></blockquote><blockquote><p>find_element_by_xpath()是根据Xpath提取</p></blockquote><blockquote><p>find_element_by_css_selector(‘#xxx’)是根据id=xxx来获取</p></blockquote><blockquote><p>find_element()方法，它需要传入两个参数，一个是查找的方式By，另一个就是值，实际上它就是find_element_by_id()这种方法的通用函数版本。</p></blockquote><p>注意： from selenium.webdriver.common.by import By</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_element_by_id(id)</span><br><span class="line">就等价于find_element(By.ID, id)</span><br><span class="line"></span><br><span class="line">find_element_by_css_selector(&apos;#xxx&apos;)</span><br><span class="line">等价于find_elements(By.CSS_SELECTOR, &apos;.service-bd li&apos;)</span><br></pre></td></tr></table></figure><p><strong>获取多个元素</strong> </p><blockquote><p>find_elements_by_css_selector(‘#xxx li’)是根据id=xxx来获取下面的所有li的结果</p></blockquote><h4 id="查找淘宝导航条的所有条目"><a href="#查找淘宝导航条的所有条目" class="headerlink" title="查找淘宝导航条的所有条目"></a>查找淘宝导航条的所有条目</h4><p>案例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">chromedriver = &apos;C:\Program Files (x86)\Google\Chrome\Application\chromedriver&apos;</span><br><span class="line">browser = webdriver.Chrome(chromedriver)</span><br><span class="line">browser.get(&apos;https://www.taobao.com&apos;)</span><br><span class="line">lis = browser.find_elements_by_css_selector(&apos;.service-bd li a&apos;)</span><br><span class="line">for li in lis:</span><br><span class="line">    # 获取文本信息</span><br><span class="line">    print(li.text)</span><br><span class="line">    # 获取属性</span><br><span class="line">    print(li.get_attribute(&apos;href&apos;))</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><h4 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h4><p>在Selenium中，get()方法会在网页框架加载结束之后就结束执行，此时如果获取page_source可能并不是浏览器完全加载完成的页面，如果某些页面有额外的Ajax请求，我们在网页源代码中也不一定能成功获取到。所以这里我们需要延时等待一定时间确保元素已经加载出来。在这里等待的方式有两种，一种隐式等待，一种显式等待。</p><p>以访问知乎发现页面为案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">chromedriver = &apos;C:\Program Files (x86)\Google\Chrome\Application\chromedriver&apos;</span><br><span class="line">browser = webdriver.Chrome(chromedriver)</span><br><span class="line"></span><br><span class="line"># 用implicitly_wait()方法实现了隐式等待。</span><br><span class="line">browser.implicitly_wait(10)</span><br><span class="line"></span><br><span class="line">browser.get(&apos;https://www.zhihu.com/explore&apos;)</span><br><span class="line">input = browser.find_element_by_class_name(&apos;zu-top-add-question&apos;)</span><br><span class="line">print(input)</span><br></pre></td></tr></table></figure><h4 id="前进后退"><a href="#前进后退" class="headerlink" title="前进后退"></a>前进后退</h4><p>使用back()方法可以后退，forward()方法可以前进</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">browser.back()</span><br><span class="line">time.sleep(1)</span><br><span class="line">browser.forward()</span><br></pre></td></tr></table></figure><h4 id="Cookies操作"><a href="#Cookies操作" class="headerlink" title="Cookies操作"></a>Cookies操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">chromedriver = &apos;C:\Program Files (x86)\Google\Chrome\Application\chromedriver&apos;</span><br><span class="line">browser = webdriver.Chrome(chromedriver)</span><br><span class="line">browser.get(&apos;https://www.zhihu.com/explore&apos;)</span><br><span class="line"></span><br><span class="line"># 获取所有cookies信息</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line"></span><br><span class="line"># 添加一个Cookie信息</span><br><span class="line">browser.add_cookie(&#123;&apos;name&apos;: &apos;王大帅&apos;, &apos;value&apos;: &apos;16&apos;&#125;)</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line"># 删除所有的Cookies</span><br><span class="line">browser.delete_all_cookies()</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><h4 id="切换窗口"><a href="#切换窗口" class="headerlink" title="切换窗口"></a>切换窗口</h4><p>以淘宝为例：</p><p>打开浏览器在主页中点击女装案例，再切换回主页再点击男装按钮，然后主页进行back()和froward()操作，最后退出整个浏览器quit()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">chromedriver = &apos;C:\Program Files (x86)\Google\Chrome\Application\chromedriver&apos;</span><br><span class="line">browser = webdriver.Chrome(chromedriver)</span><br><span class="line"></span><br><span class="line"># 隐式延迟</span><br><span class="line">browser.implicitly_wait(20)</span><br><span class="line"></span><br><span class="line">browser.get(&apos;https://www.taobao.com&apos;)</span><br><span class="line"></span><br><span class="line"># 获取主窗口</span><br><span class="line">taobao_handler = browser.current_window_handle</span><br><span class="line"></span><br><span class="line"># 点击导航栏女装按钮</span><br><span class="line">browser.find_element_by_xpath(&apos;/html/body/div[4]/div[1]/div[1]/div[1]/div/ul/li[1]/a[1]&apos;).click()</span><br><span class="line"></span><br><span class="line">time.sleep(3)</span><br><span class="line"></span><br><span class="line"># 获取当前窗口</span><br><span class="line">text_browser_handler_nv = browser.current_window_handle</span><br><span class="line"></span><br><span class="line"># 切换窗口继续点击男装案例</span><br><span class="line">browser.switch_to_window(taobao_handler)</span><br><span class="line"></span><br><span class="line"># # 点击导航栏男装按钮</span><br><span class="line">browser.find_element_by_xpath(&apos;/html/body/div[4]/div[1]/div[1]/div[1]/div/ul/li[1]/a[2]&apos;).click()</span><br><span class="line"></span><br><span class="line">time.sleep(3)</span><br><span class="line"></span><br><span class="line"># 后退</span><br><span class="line">browser.back()</span><br><span class="line"></span><br><span class="line">time.sleep(3)</span><br><span class="line"># 前进</span><br><span class="line">browser.forward()</span><br><span class="line"></span><br><span class="line"># 关闭浏览器</span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><p>获取一共启动了多少窗口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser.window_handles</span><br></pre></td></tr></table></figure><h2 id="8、scrapy框架"><a href="#8、scrapy框架" class="headerlink" title="8、scrapy框架"></a>8、scrapy框架</h2><p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。</p><p>其最初是为了 页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据或者通用的网络爬虫。</p><p>Scrapy 使用了 Twisted异步网络库来处理网络通讯。整体架构大致如下:</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/spider_scrapy_zhujian.png" alt="图"></p><p><a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/index.html" target="_blank" rel="noopener">中文官网</a></p><h3 id="初窥Scrapy"><a href="#初窥Scrapy" class="headerlink" title="初窥Scrapy"></a>初窥Scrapy</h3><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Scrapy</span><br></pre></td></tr></table></figure><p>安装过程中会安装如下一些包，在之前的安装过程中，偶尔会出现Twisted失败的话，需要自己手动去安装。</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/spider_scrapy_pip.png" alt="图"></p><p>在此也先安装另外一个必备的包pywin32，如果不安装该包的话，在运行爬虫的时候可能会提示<strong>“ModuleNotFoundError: No module named ‘win32api’”</strong>，因为Python没有自带访问windows系统API的库的，需要下载第三方库。库的名称叫pywin32。可以去网站上下载，<a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/" target="_blank" rel="noopener">下载地址</a></p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/scrapy_win32api.png" alt="图"></p><p>按照自己电脑上的python版本，进行下载安装。安装的时候，先进入虚拟环境中，然后执行easy_install pywin32-221.win-amd64-py3.6.exe 命令即可将包安装在我们当前的虚拟环境中了。</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/easyinstall_win32api.png" alt="图"></p><h3 id="2-Scrapy组件"><a href="#2-Scrapy组件" class="headerlink" title="2. Scrapy组件"></a>2. Scrapy组件</h3><h4 id="1-引擎-Scrapy"><a href="#1-引擎-Scrapy" class="headerlink" title="1. 引擎(Scrapy)"></a>1. 引擎(Scrapy)</h4><p>用来处理整个系统的数据流处理, 触发事务(框架核心)</p><h4 id="2-调度器-Scheduler"><a href="#2-调度器-Scheduler" class="headerlink" title="2. 调度器(Scheduler)"></a>2. 调度器(Scheduler)</h4><p>用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列,<br>由它来决定下一个要抓取的网址是什么, 同时去除重复的网址</p><h4 id="3-下载器-Downloader"><a href="#3-下载器-Downloader" class="headerlink" title="3. 下载器(Downloader)"></a>3. 下载器(Downloader)</h4><p>用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)</p><h4 id="4-爬虫-Spiders"><a href="#4-爬虫-Spiders" class="headerlink" title="4. 爬虫(Spiders)"></a>4. 爬虫(Spiders)</h4><p>爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面</p><h4 id="5-项目管道-Pipeline"><a href="#5-项目管道-Pipeline" class="headerlink" title="5. 项目管道(Pipeline)"></a>5. 项目管道(Pipeline)</h4><p>负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，<br>将被发送到项目管道，并经过几个特定的次序处理数据。</p><h4 id="6-下载器中间件-Downloader-Middlewares"><a href="#6-下载器中间件-Downloader-Middlewares" class="headerlink" title="6. 下载器中间件(Downloader Middlewares)"></a>6. 下载器中间件(Downloader Middlewares)</h4><p>位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。</p><h4 id="7-爬虫中间件-Spider-Middlewares"><a href="#7-爬虫中间件-Spider-Middlewares" class="headerlink" title="7. 爬虫中间件(Spider Middlewares)"></a>7. 爬虫中间件(Spider Middlewares)</h4><p>介于Scrapy引擎和爬虫之间的框架，主要工作是处理蜘蛛的响应输入和请求输出。</p><h4 id="8-调度中间件-Scheduler-Middewares"><a href="#8-调度中间件-Scheduler-Middewares" class="headerlink" title="8. 调度中间件(Scheduler Middewares)"></a>8. 调度中间件(Scheduler Middewares)</h4><p>介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。</p><h3 id="3-处理流程"><a href="#3-处理流程" class="headerlink" title="3. 处理流程"></a>3. 处理流程</h3><p>Scrapy的整个数据处理流程由Scrapy引擎进行控制，通常的运转流程包括以下的步骤：</p><ol><li>引擎询问蜘蛛需要处理哪个网站，并让蜘蛛将第一个需要处理的URL交给它。</li><li>引擎让调度器将需要处理的URL放在队列中。</li><li>引擎从调度那获取接下来进行爬取的页面。</li><li>调度将下一个爬取的URL返回给引擎，引擎将它通过下载中间件发送到下载器。</li><li>当网页被下载器下载完成以后，响应内容通过下载中间件被发送到引擎；如果下载失败了，引擎会通知调度器记录这个URL，待会再重新下载。</li><li>引擎收到下载器的响应并将它通过蜘蛛中间件发送到蜘蛛进行处理。</li><li>蜘蛛处理响应并返回爬取到的数据条目，此外还要将需要跟进的新的URL发送给引擎。</li><li>引擎将抓取到的数据条目送入条目管道，把新的URL发送给调度器放入队列中。</li></ol><p>上述操作中的2-8步会一直重复直到调度器中没有需要请求的URL，爬虫停止工作。</p><h3 id="4-Scrapy项目"><a href="#4-Scrapy项目" class="headerlink" title="4. Scrapy项目"></a>4. Scrapy项目</h3><p>在创建项目开始，我们先确认一下之前安装的scrapy能否正常运行，如下情况即安装成功：</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/scrapy_run_not_error.png" alt="图"></p><h4 id="4-1-创建项目"><a href="#4-1-创建项目" class="headerlink" title="4.1 创建项目"></a>4.1 创建项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject dbspider</span><br></pre></td></tr></table></figure><p>创建成功以后，在我们的文件夹中会发现一个dbspider的目录，这个项目文件就是我们的爬虫项目了。可以先看看它的构成，接下来详细讲解一下每一个文件代表的意思。</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/spider_scrapy_project.png" alt="图"></p><h4 id="4-2-文件解释"><a href="#4-2-文件解释" class="headerlink" title="4.2 文件解释"></a>4.2 文件解释</h4><p>文件说明：</p><p><strong>scrapy.cfg</strong>:项目的配置信息，主要为Scrapy命令行工具提供一个基础的配置信息。（真正爬虫相关的配置信息在settings.py文件中）</p><p><strong>items.py</strong>:设置数据存储模板，用于结构化数据，如：Django的Model</p><p><strong>pipelines</strong>:数据处理行为，如：一般结构化的数据持久化</p><p><strong>settings.py</strong>:配置文件，如：递归的层数、并发数，延迟下载等</p><p><strong>spiders</strong>:爬虫目录，如：创建文件，编写爬虫规则。</p><p>在spiders文件中创建爬虫的时候，一般以爬取的网站的域名为爬虫的名称</p><h3 id="5-编写爬虫"><a href="#5-编写爬虫" class="headerlink" title="5. 编写爬虫"></a>5. 编写爬虫</h3><p>爬取起点中文网的网页源码,爬取小说分类名称以及url</p><p>案例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">from scrapy.selector import Selector</span><br></pre></td></tr></table></figure><p> class QiDianSpider(scrapy.spiders.Spider): name = “qidian” start_urls = [ “<a href="https://www.qidian.com/" target="_blank" rel="noopener">https://www.qidian.com/</a>“, ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line">    # 爬取时请求的url</span><br><span class="line">    current_url = response.url</span><br><span class="line"></span><br><span class="line">    # 返回的html</span><br><span class="line">    body = response.body</span><br><span class="line"></span><br><span class="line">    # 返回的html unicode编码</span><br><span class="line">    unicode_body = response.body_as_unicode()</span><br><span class="line">    res = Selector(response)</span><br><span class="line"></span><br><span class="line">    # 获取小说的分类信息</span><br><span class="line">    xiaoshuo_type = res.xpath(&apos;//*[@id=&quot;pin-nav&quot;]/div/div[1]/ul/li/a/text()&apos;).extract()</span><br><span class="line"></span><br><span class="line">    xiaoshuo_href = res.xpath(&apos;//*[@id=&quot;pin-nav&quot;]/div/div[1]/ul/li/a/@href&apos;).extract()</span><br><span class="line"></span><br><span class="line">    print(xiaoshuo_type, xiaoshuo_href)</span><br></pre></td></tr></table></figure><h4 id="5-1-运行命令："><a href="#5-1-运行命令：" class="headerlink" title="5.1 运行命令："></a>5.1 运行命令：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl qidian</span><br></pre></td></tr></table></figure><p>启动命令中 ‘qidian’参数为我们定义爬虫中的name属性的值</p><p>执行流程：</p><blockquote><p>name: spider对应不同的name</p></blockquote><blockquote><p>start_urls:是spider抓取网页的起始点，可以包括多个url。</p></blockquote><blockquote><p>parse()：spider抓到一个网页以后默认调用的callback，避免使用这个名字来定义自己的方法。当spider拿到url的内容以后，会调用parse方法，并且传递一个response参数给它，response包含了抓到的网页的内容，在parse方法里，你可以从抓到的网页里面解析数据。</p></blockquote><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/scrapy_qidian_type.png" alt="图"></p><h2 id="9、分布式爬虫"><a href="#9、分布式爬虫" class="headerlink" title="9、分布式爬虫"></a>9、分布式爬虫</h2><p>说到分布式系统的时候，要和集中式系统进行对比的学习，下面就先介绍下集中式系统，对比它们的优缺点进行学习。</p><h4 id="集中式系统"><a href="#集中式系统" class="headerlink" title="集中式系统"></a>集中式系统</h4><p>集中式系统：</p><p>集中式系统中整个项目就是一个独立的应用，整个应用也就是整个项目，所有的业务逻辑功能都在一个应用里面。如果遇到并发的瓶颈的时候，就多增加几台服务器来部署项目，以此来解决并发分问题。在nginx中进行负载均衡即可。</p><p>缺点：</p><blockquote><p>a) 不易于扩展</p></blockquote><blockquote><p>b) 如果发现你的项目代码中有bug的话，那么你的所有的服务器中的项目代码都是有问题的，这时候要更新这个bug的时候，就需要同时更新所有的服务器了。</p></blockquote><p>优点：</p><blockquote><p>维护方便</p></blockquote><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><p>分布式系统:</p><p>分布式系统中，我们的整个项目可以拆分成很多业务块，每一个业务块单独进行集群的部署。这样就将整个项目分开了，在进行拓展的时候，系统是很容易横向拓展的。在并发的时候，也很好的将用户的并发量提上去。</p><p>缺点：</p><blockquote><p>a) 项目拆分的过于复杂，给运维带来了很高的维护成本</p></blockquote><blockquote><p>b) 数据的一致性，分布式事务，分布式锁等问题不能得到很好的解决</p></blockquote><p>优点：</p><blockquote><p>a) 一个业务模块崩了，并不影响其他的业务</p></blockquote><blockquote><p>b) 利于扩展</p></blockquote><blockquote><p>c) 在上线某个新功能的时候，只需要新增对应的分布式的节点即可，测试也只需要测试该业务功能即可。很好的避免了测试在上线之前需要将整个系统进行全方面的测试</p></blockquote><h3 id="1-scrapy的分布式原理"><a href="#1-scrapy的分布式原理" class="headerlink" title="1. scrapy的分布式原理"></a>1. scrapy的分布式原理</h3><p>我们还是先回顾下scrapy的运行原理的构造图:</p><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/spider_scrapy_zhujian.png" alt="图"></p><p>该图很好的阐释了在不是scrapy的服务器中的运行结构图，在维护爬取的url队列的时候，使用scheduler进行调度的。那么如果要修改为分布式的scrapy爬虫的话，其实就是将爬取的队列进行共享，多台部署了scrapy爬虫的服务器共享该爬取队列。</p><h3 id="2-分布式架构："><a href="#2-分布式架构：" class="headerlink" title="2. 分布式架构："></a>2. 分布式架构：</h3><p><img src="https://raw.githubusercontent.com/shuaixiaohao/shuaixiaohao.github.io/master/images/blog-image/%E7%88%AC%E8%99%AB/scrapy_redis_tu.png" alt="图"></p><p>master-主机：维护爬虫队列。</p><p>slave-从机：数据爬取，数据处理，数据存储。</p><h3 id="3-搭建分布式爬虫"><a href="#3-搭建分布式爬虫" class="headerlink" title="3. 搭建分布式爬虫"></a>3. 搭建分布式爬虫</h3><p>我们使用scrapy_redis进行分布式爬虫的搭建。</p><p>scrapy_redis是scrapy框架下的一个插件，通过重构调度器来使我们的爬虫运行的更快</p><h4 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h4><p>安装scrapy_redis：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy_redis</span><br></pre></td></tr></table></figure><p>安装redis：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># redis可以仅在master主机上安装</span><br><span class="line"></span><br><span class="line">pip install redis</span><br></pre></td></tr></table></figure><p>安装数据存储数据库，采用mongodb <a href="https://github.com/coco369/knowledge/blob/master/sql/mongodb.md" target="_blank" rel="noopener">见: 安装配置地址</a></p><h4 id="3-2-redis"><a href="#3-2-redis" class="headerlink" title="3.2 redis"></a>3.2 redis</h4><p>在维护爬虫队列的时候，很多爬虫项目同时读取队列中的信息，就造成了可能读数据重复了，比如同时读取同一个url。为了避免这种情况，我们建议使用redis去维护队列。而且<strong>redis的集合中的元素还不是重复的</strong>，可以很好的利用这一点，进行url爬取地址的存储</p><h4 id="3-3-分布式爬虫改造"><a href="#3-3-分布式爬虫改造" class="headerlink" title="3.3 分布式爬虫改造"></a>3.3 分布式爬虫改造</h4><h5 id="3-3-1-master"><a href="#3-3-1-master" class="headerlink" title="3.3.1 master"></a>3.3.1 master</h5><p>master主机改造： 在master主机上安装redis并启动，最好设置密码</p><h5 id="spiders文件中定义的爬虫py文件修改如下："><a href="#spiders文件中定义的爬虫py文件修改如下：" class="headerlink" title="spiders文件中定义的爬虫py文件修改如下："></a>spiders文件中定义的爬虫py文件修改如下：</h5><p>如下爬虫实现的功能是拿到需要爬取的成都各大区县的二手房页面url地址，包括分页的地址。并将数据存储到redis中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">from scrapy import Request</span><br><span class="line">from scrapy.spiders import Spider</span><br><span class="line">from scrapy.selector import Selector</span><br><span class="line"></span><br><span class="line">from lianjiaspider.items import LianjiaspiderItem, MasterItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LianJiaSpider(Spider):</span><br><span class="line"></span><br><span class="line">    name = &apos;lianjia&apos;</span><br><span class="line">    # allowed_domains = [&apos;lianjia.com&apos;]</span><br><span class="line">    domains_url = &apos;https://cd.lianjia.com&apos;</span><br><span class="line">    start_linjia_url = &apos;https://cd.lianjia.com/ershoufang&apos;</span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        yield Request(self.start_linjia_url)</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line"></span><br><span class="line">        sel = Selector(response)</span><br><span class="line">        ershoufang_aera = sel.xpath(&apos;//div[@data-role=&quot;ershoufang&quot;]&apos;)</span><br><span class="line">        area_info = ershoufang_aera.xpath(&apos;./div/a&apos;)</span><br><span class="line"></span><br><span class="line">        for area in area_info:</span><br><span class="line">            area_href = area.xpath(&apos;./@href&apos;).extract()[0]</span><br><span class="line">            area_name = area.xpath(&apos;./text()&apos;).extract()[0]</span><br><span class="line"></span><br><span class="line">            yield Request(self.domains_url + area_href,</span><br><span class="line">                          callback=self.parse_house_info,</span><br><span class="line">                          meta=&#123;&apos;name&apos;: area_name, &apos;href&apos;: area_href&#125;)</span><br><span class="line"></span><br><span class="line">    def parse_house_info(self, response):</span><br><span class="line">        sel = Selector(response)</span><br><span class="line">        page_box = sel.xpath(&apos;//div[@class=&quot;page-box house-lst-page-box&quot;]/@page-data&apos;).extract()</span><br><span class="line">        total_page = json.loads(page_box[0]).get(&apos;totalPage&apos;)</span><br><span class="line"></span><br><span class="line">        for i in range(1, int(total_page)+1):</span><br><span class="line">            item = MasterItem()</span><br><span class="line">            item[&apos;url&apos;] = self.domains_url + response.meta.get(&apos;href&apos;) + &apos;pg&apos; + str(i)</span><br><span class="line">            yield item</span><br></pre></td></tr></table></figure><h5 id="定义Item"><a href="#定义Item" class="headerlink" title="定义Item"></a>定义Item</h5><p>接收一个地址url参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class MasterItem(scrapy.Item):</span><br><span class="line">    url = scrapy.Field()</span><br></pre></td></tr></table></figure><h5 id="新增redis存储中间件"><a href="#新增redis存储中间件" class="headerlink" title="新增redis存储中间件"></a>新增redis存储中间件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MasterPipeline(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line"># 链接redis</span><br><span class="line">        self.r = redis.Redis(host=&apos;127.0.0.1&apos;, port=6379)</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line"># 向redis中插入需要爬取的链接地址</span><br><span class="line">        self.r.lpush(&apos;lianjia:start_urls&apos;, item[&apos;url&apos;])</span><br></pre></td></tr></table></figure><h5 id="3-3-2-slave改造："><a href="#3-3-2-slave改造：" class="headerlink" title="3.3.2 slave改造："></a>3.3.2 slave改造：</h5><p>slave从机改造：slave从机访问redis，直接去访问master主机上的redis的地址，以及端口密码等信息</p><h5 id="spiders爬虫文件改造"><a href="#spiders爬虫文件改造" class="headerlink" title="spiders爬虫文件改造"></a>spiders爬虫文件改造</h5><p>继承改为继承Redisspider</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from scrapy_redis.spiders import RedisSpider</span><br></pre></td></tr></table></figure><p>具体代码优化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from scrapy_redis.spiders import RedisSpider</span><br><span class="line">from scrapy.selector import Selector</span><br><span class="line"></span><br><span class="line">from lianjiaspider.items import LianjiaspiderItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LianJiaSpider(RedisSpider):</span><br><span class="line"></span><br><span class="line">    name = &apos;lianjia&apos;</span><br><span class="line"></span><br><span class="line"># 指定访问redis的爬取urls的队列</span><br><span class="line">    redis_key = &apos;lianjia:start_urls&apos;</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line"></span><br><span class="line">        sel = Selector(response)</span><br><span class="line">        lis = sel.xpath(&apos;//html/body/div[4]/div[1]/ul/li[@class=&quot;clear&quot;]&apos;)</span><br><span class="line">        for li in lis:</span><br><span class="line"></span><br><span class="line">            item = LianjiaspiderItem()</span><br><span class="line">            item[&apos;house_code&apos;] = li.xpath(&apos;./a/@data-housecode&apos;).extract()[0]</span><br><span class="line">            if li.xpath(&apos;./a/img/@src&apos;).extract():</span><br><span class="line">                item[&apos;img_src&apos;] = li.xpath(&apos;./a/img/@src&apos;).extract()[0]</span><br><span class="line">            if li.xpath(&apos;./div/div/a/text()&apos;).extract():</span><br><span class="line">                item[&apos;title&apos;] = li.xpath(&apos;./div/div/a/text()&apos;).extract()[0]</span><br><span class="line">            item[&apos;address&apos;] = li.xpath(&apos;./div/div[2]/div/a/text()&apos;).extract()</span><br><span class="line">            item[&apos;info&apos;] = li.xpath(&apos;./div/div[2]/div/text()&apos;).extract()</span><br><span class="line">            item[&apos;flood&apos;] = li.xpath(&apos;./div/div[3]/div/text()&apos;).extract()</span><br><span class="line">            item[&apos;tag&apos;] = li.xpath(&apos;.//div[@class=&quot;tag&quot;]/span/text()&apos;).extract()</span><br><span class="line">            item[&apos;type&apos;] = &apos;ershoufang&apos;</span><br><span class="line">            item[&apos;city&apos;] = &apos;成都&apos;</span><br><span class="line"></span><br><span class="line">            yield item</span><br><span class="line"></span><br><span class="line">    def split_house_info(self, info):</span><br><span class="line">        return [i.strip() for i in info.split(&apos;|&apos;)[1:]]</span><br></pre></td></tr></table></figure><h5 id="settings-py配置改造"><a href="#settings-py配置改造" class="headerlink" title="settings.py配置改造"></a>settings.py配置改造</h5><p>新增如下的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># scrapy-redis</span><br><span class="line">REDIS_URL = &apos;redis://:yzd@127.0.0.1:6379&apos;  # for master</span><br><span class="line"># REDIS_URL = &apos;redis://:yzd@10.140.0.2:6379&apos;  # for slave (master&apos;s ip)</span><br><span class="line"></span><br><span class="line"># SCHEDULER 是任务分发与调度，把所有的爬虫开始的请求都放在redis里面，所有爬虫都去redis里面读取请求。</span><br><span class="line">SCHEDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><span class="line"></span><br><span class="line"># 如果这一项设为True，那么在Redis中的URL队列不会被清理掉，但是在分布式爬虫共享URL时，要防止重复爬取。如果设为False，那么每一次读取URL后都会将其删掉，但弊端是爬虫暂停后重新启动，他会重新开始爬取。 </span><br><span class="line">SCHEDULER_PERSIST = True</span><br><span class="line"></span><br><span class="line"># REDIS_START_URLS_AS_SET指的是使用redis里面的set类型（简单完成去重），如果你没有设置，默认会选用list。</span><br><span class="line">REDIS_START_URLS_AS_SET = True</span><br><span class="line"></span><br><span class="line"># DUPEFILTER_CLASS 是去重队列，负责所有请求的去重</span><br><span class="line">DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><span class="line"></span><br><span class="line"># 爬虫的请求调度算法，有三种可供选择</span><br><span class="line"># scrapy_redis.queue.SpiderQueue：队列。先入先出队列，先放入Redis的请求优先爬取；</span><br><span class="line"># scrapy_redis.queue.SpiderStack：栈。后放入Redis的请求会优先爬取；</span><br><span class="line"># scrapy_redis.queue.SpiderPriorityQueue：优先级队列。根据优先级算法计算哪个先爬哪个后爬</span><br><span class="line">SCHEDULER_QUEUE_CLASS = &quot;scrapy_redis.queue.SpiderQueue&quot;</span><br><span class="line"></span><br><span class="line"># 设置链接redis的配置，或者如下分别设置端口和IP地址</span><br><span class="line">REDIS_URL = &apos;redis://127.0.0.1:6379&apos;</span><br><span class="line"></span><br><span class="line"># 分布式爬虫设置Ip端口</span><br><span class="line">REDIS_HOST = &apos;127.0.0.1&apos;</span><br><span class="line">REDIS_PORT = 6379</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML</title>
      <link href="/2017/11/29/HTML%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/11/29/HTML%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h3 id="什么是HTML"><a href="#什么是HTML" class="headerlink" title="什么是HTML?"></a>什么是HTML?</h3><p>HTML 是用来描述网页的一种语言。</p><ol><li>Tag: Content 装内容装数据</li><li>CSS: Display 渲染,显示 </li><li>JavaScript: Behavior 交互,行为</li></ol><a id="more"></a><ul><li>HTML 指的是超文本标记语言: <strong>H</strong>yper <strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage</li><li>HTML 不是一种编程语言，而是一种<strong>标记</strong>语言</li><li>标记语言是一套<strong>标记标签</strong> (markup tag)</li><li>HTML 使用标记标签来<strong>描述</strong>网页</li><li>HTML 文档包含了HTML <strong>标签</strong>及<strong>文本</strong> 内容</li><li>HTML文档也叫做<strong>web 页面</strong></li></ul><h4 id="HTML格式"><a href="#HTML格式" class="headerlink" title="HTML格式"></a>HTML格式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>主题title&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>&lt;!DOCTYPE html&gt; 声明为 HTML5 文档</p><p><html>  元素是 HTML 页面的根元素</html></p><p><head>  元素包含了文档的元（meta）数据</head></p><p><title>  元素描述了文档的标题</title></p><p><body>  元素包含了可见的页面内容</body></p><p></p><h1>  元素定义一个大标题<p></p><p></p><p>  元素定义一个段落</p><p><hr> 水平分割线</p><p><br>折行符</p><p><sub>\</sub> 下标标签</p><p><sup>\</sup> 上标标签</p><p><strong>\</strong> 强调标签,变粗</p><p><em>\</em> 强调标签,斜体</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>草莓<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>芒果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器显示:</p><ul><li>苹果</li><li>草莓</li><li>芒果</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>草莓<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>芒果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器显示:</p><ol><li>苹果</li><li>草莓</li><li>芒果</li></ol><h4 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h4><p><dl> 标签定义一个描述列表。</dl></p><p><dl> 标签与 <dt> （定义项目/名字）和 <dd> （描述每一个项目/名字）一起使用。</dd></dt></dl></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>星期<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>1 2 3 4 5 6 7<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>月份<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>1 2 3 4 5 6 7 8 9 10 11 12<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器显示:</p><p>星期<br>​    1 2 3 4 5 6 7<br>月份<br>​    1 2 3 4 5 6 7 8 9 10 11 12</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"url"</span>&gt;</span>链接文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>href</code>属性描述了链接的目标。</p><h4 id="页面链接"><a href="#页面链接" class="headerlink" title="页面链接"></a>页面链接</h4><!-- 页面链接:可以链接到其他网站也可以链接到自己的页面 --><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当前页面跳转,target="_self"可以不写</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">target</span>=<span class="string">"_self"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">打开新页面跳转</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.qq.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>腾讯<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="锚点链接-id属性"><a href="#锚点链接-id属性" class="headerlink" title="锚点链接(id属性)"></a>锚点链接(id属性)</h4><!-- 锚点链接:链接到指定位置 --><p>id属性可用于创建在一个HTML文档书签标记。</p><p>id=”tips”          tips-提示部分,自己定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"top"</span>&gt;</span>Hello,word!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#top"</span>&gt;</span>回顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="功能性链接"><a href="#功能性链接" class="headerlink" title="功能性链接"></a>功能性链接</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">自动弹出发邮箱功能</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:fenghao1994@163.com"</span>&gt;</span>联系站长<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">发起消息会话,wp.qq.com网站自动生成</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"http://wpa.qq.com/msgrd?v=3&amp;uin=&amp;site=qq&amp;menu=yes"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">src</span>=<span class="string">"http://wpa.qq.com/pa?p=2::52"</span> <span class="attr">alt</span>=<span class="string">"联系客服"</span> <span class="attr">title</span>=<span class="string">"联系客服"</span>/&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><p><strong>定义图像的语法是:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"url"</span> <span class="attr">alt</span>=<span class="string">"som_text"</span> &gt;</span></span><br></pre></td></tr></table></figure><p><code>src</code> 指 “source”。源属性的值是图像的 URL 地址,或图片的相对路径。</p><p><code>alt</code> 为图像定义一串预备的可替换的文本。在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。</p><p>height（高度） 与 width（宽度）属性用于设置图像的高度与宽度，属性值默认单位为像素，也可以不设置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./mm.jpg"</span> <span class="attr">alt</span>=<span class="string">"这是一个女的"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"500"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">caption</span>&gt;</span>个人信息统计<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>身高<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    th<span class="tag">&lt;<span class="name">th</span>&gt;</span>体重<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>王大锤<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>170<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..jpg"</span> <span class="attr">width</span>=<span class="string">"60"</span> <span class="attr">height</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>李小刀<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>18<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>180<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>58<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;caption&gt;</code> 定义表格标题</p><p><code>&lt;th&gt;</code> 定义表格的表头</p><p><code>&lt;tr&gt;</code> 定义表格的行</p><p><code>&lt;td&gt;</code> 定义表格单元</p><p><code>align=&quot;center&quot;</code> 居中</p><p><code>colspan=&quot;&quot;</code> 合并</p><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"horse.ogg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"horse.mp3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>controls</code> 属性供添加播放、暂停和音量控件；可以换成<code>autoplay</code> 自动播放；<code>autoplay loop</code>自动循环播放。</p><p><source> 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件</p><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.ogg"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>controls</code> 元素提供了 播放、暂停和音量控件来控制视频。</p><p> width 和 height 属性控制视频的尺寸.尽量不要写</p><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p><strong>区块元素</strong></p><p>大多数 HTML 元素被定义为<strong>块级元素</strong>或<strong>内联元素</strong>。</p><p>块级元素在浏览器显示时，通常会<u>以新行来开始</u>（和结束）。</p><p>实例: </p><h1>, <p>, <ul>, <table>,<div></div></table></ul></p><p><strong>内联元素</strong></p><p>内联元素在显示时通常<u>不会以新行开始</u>。</p><p>实例: <b>, <td>, <a>, <img></a></td></b></p><p><strong><div> 元素</div></strong></p><p><div> 元素是块级元素，它可用于组合其他 HTML 元素的容器。</div></p><p><strong><span> 元素</span></strong></p><p><span> 元素是内联元素，可用作文本的容器</span></p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p> 表单用于收集不同类型的用户输入。表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。表单使用表单标签 \<form> 来设置</form></p><h4 id="输入元素"><a href="#输入元素" class="headerlink" title="输入元素"></a>输入元素</h4><p>多数情况下被用到的表单标签是输入标签（<input>）。</p><p>输入类型是由类型属性（type）定义的。</p><h4 id="文本域（Text-Fields）"><a href="#文本域（Text-Fields）" class="headerlink" title="文本域（Text Fields）"></a>文本域（Text Fields）</h4><p>文本域通过<input type="text"> 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>必填信息<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uid"</span> <span class="attr">placeholder</span>=<span class="string">"请输入用户名"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span>&gt;</span>密码 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pwd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span>&gt;</span>男</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">checked</span>&gt;</span>女</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>action</code> “”里面是要提交的地址</p><p><code>method</code> 规定如何发送表单数据（表单数据发送到 action属性所规定的页面）。共有两种方法：post 方法和 get 方法</p><p> – get</p><ul><li>get是从服务器上获取数据</li><li>get是把参数数据队列加到提交表单的action属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到</li><li>get传送的数据量较小。</li><li><p>get安全性非常低。</p><p>– post</p></li><li><p>post是向服务器传送数据</p></li><li>post是通过HTTP post机制,将表单内各个字段与其内容放置在HTML HEADER内一起传送到action属性所指的URL地址。用户看不到这个过程。</li><li>post传送的数据量较大，一般被默认为不受限制。</li><li>post安全性较高。</li></ul><p><code>enctype</code> 属性规定在将表单数据发送到服务器之前如何对其进行编码。</p><p><strong>注意：</strong>只有 method=”post” 时才使用 enctype 属性。</p><p><code>&lt;fieldset&gt;&lt;/fieldset&gt;</code> 定义了一组相关的表单元素，并使用外框包含起来</p><p><code>&lt;legend&gt;&lt;/legend&gt;</code> 定义了 \<fieldset> 元素的标题</fieldset></p><p><code>&lt;label&gt;</code> 定义了 \<input> 元素的标签，一般为输入标题</p><p><code>&lt;input&gt;</code> 输入标签输入类型是由类型属性（type）定义的。</p><p><code>name</code> 属性规定表单的名称,用于在 JavaScript 中引用元素，或者在表单提交之后引用表单数据。</p><p><code>placeholder</code> 属性规定可描述输入字段预期值的简短的提示信息,该提示会在用户输入值之前显示在输入字段中。</p><p><strong>注意：</strong>placeholder 属性适用于下面的 input 类型：text、search、url、tel、email 和 password。</p><p><code>required</code> 属性是一个布尔属性,规定必需在提交表单之前填写输入字段。</p><p><strong>注意：</strong>required 属性适用于下面的 input 类型：text、search、url、tel、email、password、date pickers、number、checkbox、radio 和 file。</p><h4 id="密码字段"><a href="#密码字段" class="headerlink" title="密码字段"></a>密码字段</h4><p>密码字段通过标签<input type="password"> 来定义</p><h4 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h4><p><code>&lt;input type=&quot;radio&quot;&gt;</code>  标签定义了表单单选框选项</p><p><code>checked</code>选框默认选项</p><h4 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h4><p><input type="checkbox"> 定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>爱好: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"fav"</span>&gt;</span>游戏</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"fav"</span> <span class="attr">checked</span>&gt;</span>阅读</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"fav"</span> <span class="attr">checked</span> <span class="attr">disabled</span>&gt;</span>旅游</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"fav"</span>&gt;</span>运动</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"fav"</span>&gt;</span>其他</span><br></pre></td></tr></table></figure><p><code>checked disabled</code> 默认必选项,不能取消.</p><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"photo1"</span> <span class="attr">multiple</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>multiple</code> 可接受多个值的文件上传字段</p><h4 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="下拉列表选项"><a href="#下拉列表选项" class="headerlink" title="下拉列表选项"></a>下拉列表选项</h4><p><select>定义了下拉选项列表</select></p><p><option>定义下拉列表中的选项</option></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>籍贯: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span>name="prov" </span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>四川<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>云南<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>海南<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>selected</strong> 默认选项</p><h4 id="多行文本框"><a href="#多行文本框" class="headerlink" title="多行文本框"></a>多行文本框</h4><p><textarea> 标签定义一个多行的文本输入控件。文本区域中可容纳无限数量的文本，其中的文本的默认字体是等宽字体（通常是 Courier）。可以通过 cols 和 rows 属性来规定 textarea 的尺寸大小</textarea></p><h3 id="字符实体"><a href="#字符实体" class="headerlink" title="字符实体"></a>字符实体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 空格&amp;nbsp;</span><br><span class="line">&lt;小于号&amp;lt;</span><br><span class="line">&gt;大于号&amp;gt;</span><br><span class="line">&amp;和号&amp;amp;</span><br><span class="line">&quot;引号&amp;quot;</span><br><span class="line">&apos;撇号 &amp;apos; (IE不支持)</span><br><span class="line">￠分&amp;cent;</span><br><span class="line">£镑&amp;pound;</span><br><span class="line">¥人民币/日元</span><br><span class="line">€欧元&amp;euro;</span><br><span class="line">§小节&amp;sect;</span><br><span class="line">×乘号&amp;times;</span><br><span class="line">÷除号&amp;divide;</span><br><span class="line">© 版权&amp;copy;</span><br><span class="line">®注册商标   &amp;reg;</span><br><span class="line">™商标&amp;trade;</span><br></pre></td></tr></table></figure><hr><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="什么是-CSS"><a href="#什么是-CSS" class="headerlink" title="什么是 CSS?"></a>什么是 CSS?</h3><ul><li>CSS 指层叠样式表 (<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)</li><li>样式定义<strong>如何显示</strong> HTML 元素</li><li>样式通常存储在<strong>样式表</strong>中</li><li>把样式添加到 HTML 4.0 中，是为了<strong>解决内容与表现分离的问题</strong></li><li><strong>外部样式表</strong>可以极大提高工作效率</li><li>外部样式表通常存储在 <strong>CSS 文件</strong>中</li><li>多个样式定义可<strong>层叠</strong>为一</li></ul><p>CSS 规则由两个主要的部分构成：<strong><em>选择器</em></strong>，以及一条或多条<strong><em>声明</em></strong>，声明总是以分号(;)结束，声明组以大括号({})括起来</p><ul><li>就近原则</li><li>具体性原则      id选择器&gt;类选择器&gt;标签选择器&gt;通配符选择器 </li><li>重要性原则</li></ul><p><strong>盒子模型</strong> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content（内容） - padding（内边距） - border（边框） - background-image（背景图片） - background-color（背景颜色） - margin（外边距）</span><br></pre></td></tr></table></figure><h3 id="边框和轮廓"><a href="#边框和轮廓" class="headerlink" title="边框和轮廓"></a>边框和轮廓</h3><p><strong>border</strong>        设置对象边框的特性</p><p><strong>border-collapse : collapse</strong>      设置表格的边框合并为一个单一的边框</p><p><strong>border-color</strong>    设置或检索对象的边框颜色</p><p><strong>outline</strong>        设置或检索对象外的线条轮廓。</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p><strong>font-size</strong>    设置字体属性</p><p><strong>font-family</strong>    规定文本的字体系列</p><p><strong>font-style</strong>    规定文本的字体尺寸</p><p><strong>font-weight</strong>    规定字体的粗细</p><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p><strong>color</strong>        指定文本的颜色</p><p><strong>line-height</strong>    设置行高</p><p><strong>text-align</strong>    规定文本的水平对齐方式</p><p><strong>text-decoration</strong>    规定添加到文本的装饰效果，：none取消下划线</p><h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><p><strong>padding</strong>     简写属性在一个声明中设置所有填充属性。该属性可以有1到4个值</p><p><strong>padding-bottom</strong>        设置元素的底填充<br><strong>padding-left</strong>        设置元素的左填充<br><strong>padding-right</strong>    设置元素的右填充<br><strong>padding-top</strong>        设置元素的顶部填充</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><u>div是不支持background-color 的，background-color是table等的属性，你要用background：#（这里是颜色代码）；这样来写</u></p><p><strong>background</strong>        复合属性，设置对象的背景特性</p><p><strong>background-color</strong>    设置或检索对象的背景颜色<br><strong>background-image</strong>    设置或检索对象的背景图像</p><h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><p><strong>margin</strong>        在一个声明中设置所有外边距属性，该属性可以有1到4个值</p><h3 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h3><p><strong>display：none</strong>    此元素不会被显示。</p><p><strong>display：block</strong>    此元素将显示为块级元素，此元素前后会带有换行符。</p><p><strong>display：inline</strong>    默认。此元素会被显示为内联元素，元素前后没有换行符。</p><p><strong>hidden</strong>    元素是不可见的。</p><h3 id="列表-1"><a href="#列表-1" class="headerlink" title="列表"></a>列表</h3><p><strong>list-style</strong>    在一个声明中设置所有的列表属性<br><strong>list-style-position</strong>    设置列表项标记的放置位置</p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p><strong>position:static;</strong>     正常文档流</p><p><strong>position:relative;</strong>     相对定位 相对于元素原来的位置定位没有脱离文档流,对兄弟元素没有影响</p><p><strong>position:absolute;</strong>     绝对定位(相对于父元素来设置位置 脱离了文档流</p><p><strong>position:fixd；</strong>  固定定位（相对于浏览器窗口摆放）</p><p><strong>z-index</strong>    属性指定一个元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。</p><p><strong>float：left</strong>    元素向左浮动。</p><p><strong>float：right</strong>       元素向右浮动。</p><p>黑科技</p><p><strong>overflow: auto;</strong>    如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</p><p><strong>overflow: hidden</strong>  </p><p>兄弟选择器   ~</p><p>相邻兄弟选择器 +</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安装字体</span><br><span class="line">@font-face &#123;</span><br><span class="line">font-family: '给字体起个名 ';</span><br><span class="line">src: url(路径);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>​    <strong>ECMAScript</strong> - 语法规范 - ES5                (ECMA欧洲计算机制造商协会)</p><p>​    <strong>BOM</strong> - Browser Object Model - 浏览器对象模型 - window</p><p>​    <strong>DOM</strong> - Document Object Model - 文档对象模型 - document</p><p>编程范式(理念)</p><ul><li>面向对象编程</li><li>函数式编程</li></ul><p>层叠样式表前置, JS后置</p><p>外部脚本不能包含 \<script> 标签。</p><p> <strong>document.getElementById(“some id”)</strong> 。这个方法是 HTML DOM 中定义的, 是用于访问 HTML 元素的正式 W3C 标准<br>x.innerHTML=”Hello JavaScript”;    //改变内容</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><strong>JavaScript 显示数据</strong></p><p>JavaScript 可以通过不同的方式来输出数据：</p><ul><li>使用 <strong>window.alert()</strong> 弹出警告框。   alert() 方法用于显示带有一条指定消息和一个 <strong>确认</strong> 按钮的警告框。</li><li>使用 <strong>document.write()</strong> 方法将内容写到 HTML 文档中。</li><li>使用 <strong>innerHTML</strong> 写入到 HTML 元素。</li><li>使用 <strong>console.log()</strong> 写入到浏览器的控制台。</li></ul><p><strong>操作 HTML 元素</strong></p><p>如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(<em>id</em>) 方法。</p><p>请使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容：</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>JavaScript 使用关键字 <strong>var</strong> 来定义变量， 使用等号来为变量赋值</p><p>JavaScript 对大小写是敏感的</p><p>分号用于分隔 JavaScript 语句。通常我们在每条可执行的语句结尾添加分号。使用分号的另一用处是在一行中编写多条语句。</p><p>在<u>文本字符串中</u>使用反斜杠对代码行进行换行</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释以 // 开头</p><p>多行注释以 /<em> 开始，以 </em>/ 结尾</p><h3 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h3><p><u>简单数据类型</u>:<code>字符串（String）</code> 、<code>数字(Number)</code> 、<code>布尔(Boolean)</code> 、<code>数组(Array)</code> 、</p><p><code>空（Null）</code> 、<code>未定义（Undefined）</code> </p><p><u>复杂数据类型</u>: <code>对象(Object)</code> </p><p>当声明新变量时，可以使用关键词 “new” 来声明其类型：</p><p>JavaScript中有隐式的类型转换</p><p><code>==</code>比较，它会自动转换数据类型再比较</p><p><code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。</p><p> <code>===(全等于/严格等)</code>    <code>!==(严格不等)</code></p><p>逻辑运算符: </p><p>&amp;&amp;(短路与)            只有所有都为true，&amp;&amp;运算结果才是true，第一个为false后面的不再判断</p><p>||(短路或)            只要其中有一个为true，||运算结果就是true，第一个为true后面的不再判断</p><p>! (非)</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><p>变量在函数内声明，变量为局部作用域。</p><p>局部变量：只能在函数内部访问。</p><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>变量在函数外定义，即为全局变量。</p><p>全局变量有 <strong>全局作用域</strong> : 网页中所有脚本和函数均可使用。 </p><p><u>如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。</u></p><h4 id="JavaScript-变量生命周期"><a href="#JavaScript-变量生命周期" class="headerlink" title="JavaScript 变量生命周期"></a>JavaScript 变量生命周期</h4><p>JavaScript 变量生命周期在它声明时初始化。</p><p>局部变量在函数执行完毕后销毁。</p><p>全局变量在页面关闭后销毁。</p><h3 id="JavaScript全局函数"><a href="#JavaScript全局函数" class="headerlink" title="JavaScript全局函数"></a>JavaScript全局函数</h3><p>isNaN() - 是不是不是一个数</p><p>parseInt() - 取整数如果取不出返回NaN</p><p>parseFloat() - 取小数如果取不出返回NaN</p><p>isFinite() - 是不是有限数值</p><p>eval() - 非常强大的函数 evaluate - XSS(跨站脚本攻击)</p><p>encodeURIComponent() - 处理成百分号编码</p><p>decodeURIComponent() - 将百分号编码解码还原</p><h3 id="Date-对象"><a href="#Date-对象" class="headerlink" title="Date 对象"></a>Date 对象</h3><p>创建 Date 对象： new Date() </p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>getFullYear()</td><td>从 Date 对象以四位数字返回年份</td></tr><tr><td>getMonth()</td><td>从 Date 对象返回月份 (0 ~ 11)</td></tr><tr><td>getDate()</td><td>从 Date 对象返回一个月中的某一天 (1 ~ 31)</td></tr><tr><td>getDay()</td><td>从 Date 对象返回一周中的某一天 (0 ~ 6)</td></tr><tr><td>getHours()</td><td>返回 Date 对象的小时 (0 ~ 23)</td></tr><tr><td>getMinutes()</td><td>返回 Date 对象的分钟 (0 ~ 59)</td></tr><tr><td>getSeconds()</td><td>返回 Date 对象的秒数 (0 ~ 59)</td></tr></tbody></table><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p><strong>alert()</strong>          浏览器弹出带有一段消息和一个确认按钮的警告框</p><p><strong>prompt()</strong>    显示可提示用户输入的对话框</p><p>confirm()    显示带有一段消息以及确认按钮和取消按钮的对话框</p><p>open()          打开一个新的浏览器窗口或查找一个已命名的窗口</p><p>close()        关闭浏览器窗口</p><p><strong>setTimeout()</strong>  在指定的毫秒数后调用函数或计算表达式</p><p><strong>setInterval()</strong>    按照指定的周期（以毫秒计）来调用函数或计算表达式</p><p>clearTimeout()     取消由 setTimeout() 方法设置的 timeout</p><p> clearInterval()    取消由 setInterval() 设置的 timeout</p><p>moveTo()      把窗口的左上角移动到一个指定的坐标</p><p>moveBy()    可相对窗口的当前坐标把它移动指定的像素</p><p>resizeBy()    按照指定的像素调整窗口的大小</p><h4 id="window对象属性"><a href="#window对象属性" class="headerlink" title="window对象属性"></a>window对象属性</h4><p><strong>location</strong> - 用于窗口或框架的 Location 对象</p><p>属性:</p><p>location.href        设置或返回当前显示的文档的完整 URL</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.write(location.href);</span><br></pre></td></tr></table></figure><p>Location 对象方法:</p><p>assign()    载入一个新的文档       // window.location.assign(<em>URL</em>)</p><p>reload()    重新载入当前文档      // location.reload();</p><p>replace()    用新的文档替换当前文档    // location.replace(<em>newURL</em>)</p><p>history - go() / fofward / back</p><p>screen  = avaiwidth / avaiHeight </p><h3 id="Document-对象"><a href="#Document-对象" class="headerlink" title="Document 对象"></a>Document 对象</h3><p><strong>查找元素的方法</strong></p><ul><li><p>getElementById()    返回对拥有指定 id 的第一个对象的引用</p></li><li><p>getElementsByTagName()    返回带有指定标签名的对象集合</p></li><li><p>getElementsByClassName()    返回文档中所有指定类名的元素集合</p></li><li><p>querySelector()    根据指定的选择器查找单个元素</p></li><li><p>querySelectorAll()    根据指定的选择器查找所有元素</p></li></ul><p><strong>绑定事件与取消绑定</strong></p><ul><li>document.addEventListener() 方法用于向文档添加事件句柄 </li><li>document.removeEventListener() 方法来移除 addEventListener() 方法添加的事件句柄 </li><li>element.addEventListener() 方法为指定元素添加事件句柄 </li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(event, function)</span><br></pre></td></tr></table></figure><p>​    - event    必需。描述事件名称的字符串。’click’ - 当用户点击某个对象时调用的事件句柄 </p><p>​    - function      必需。描述了事件触发后执行的函数 </p><p><strong>修改节点的内容和属性</strong></p><ul><li>textContent / innerHTML / nodeValue</li></ul><p><strong>访问成员运算符</strong> </p><ul><li>setAttribute() / getAttribute() / removeAttribute()</li></ul><p>创建新节点 - ()<br>追加新的子节点 - appendChild() / insertBefore()<br>删除子节点 - removeChild()</p><p>如果已经获得一个节点 如何访问它的父节点、子节点、兄弟节点<br>parentNode<br>children / firstChild / lastChild<br>nextSibling / prevSibling</p><h4 id="DOM事件对象"><a href="#DOM事件对象" class="headerlink" title="DOM事件对象"></a>DOM事件对象</h4><p><strong>鼠标事件</strong> </p><p>onmousedown    鼠标按钮被按下</p><p>target 事件属性可返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.target</span><br></pre></td></tr></table></figure><p>事件捕获 - 从外向里传播事件</p><p>事件冒泡 - 从里向外传播事件</p><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p> <strong>jQuery的$函数的作用:</strong></p><p>1、    $(function() {}) -  \$函数中传入的参数是一个函数作用: 绑定页面加载完成之后要执行的回调函数</p><p>2、    $(selector) -  \$函数中传入的参数是一个选择器</p><p>​    作用: 通过选择器获得对应的元素并将其处理成jQuery对象jQuery对象本质是一个数组</p><p>​    如果需要将jQuery对象还原成原生的JS对象一[index]/get(index)</p><p>3、    $(elem) -  \$函数中传入的参数是原生JS对象</p><p>​    作用: 将原生JS对象转换成jQuery对象(更多的属性更多的方法)</p><p>4、    $(tag) - \$函数中传入的参数是一个标签</p><p>​    作用:  和标签对应的元素(得到的是jQuery对身)</p><p>通过jQuery对象的方法可以用更少的代码做更多的事情</p><p>在写代码的时候不需要考虑浏览器兼容性问题(jQuery已经做了处理）</p><p>引入多个JS库出现冲突时可以通过下面的方式让出$函数</p><p>​    jQuery.noConfict() ;</p><p>让出$函数以后原来用\$函数的地方全部换成jQuery</p><p>查找元素</p><ul><li>选择器<ul><li>* / element / #id / .class / selector1, selector2</li><li>ancestor descendant / parent&gt;child / previous+next / previous~siblings </li></ul></li><li>筛选器<ul><li>基本筛选器：:not(selector) / :first / :last / :even / :odd / :eq(index) / :gt(index) / :lt(index) / :animated / :focus</li><li>内容筛选器：:contains(‘…’) / :empty / :parent / :has(selector)</li><li>可见性筛选器：:hidden / :visible</li><li>子节点筛选器：:nth-child(expr) / :first-child / :last-child / :only-child</li><li>属性筛选器：[attribute] / [attribute=’value’] / [attribute!=’value’] / [attribute^=’value’] / [attribute$=’value’] / [attribute|=’value’] / [attribute~=’value’]</li></ul></li><li>表单： :input / :text / :password / :radio / :checkbox / :submit / :image / :reset / :button / :file / :selected / :enabled / :disabled / :checked</li></ul><p>执行操作</p><ul><li>内容操作<ul><li>获取/修改内容：html() / text() / replaceWith() / remove()</li><li>获取/设置元素：before() / after() / prepend() / append() / remove() / clone() / unwrap() / detach() / empty() / add()</li><li>获取/修改属性：attr() / removeAttr() / addClass() / removeClass() / css()</li><li>获取/设置表单值：val()</li></ul></li><li>查找操作<ul><li>查找方法：find() /  parent() / children() / siblings() / next() / nextAll() / prev() / prevAll()</li><li>筛选器：filter() / not() / has() / is() / contains()</li><li>索引编号：eq()</li></ul></li><li>尺寸和位置<ul><li>尺寸相关：height() / width() / innerHeight() / innerWidth() / outerWidth() / outerHeight()</li><li>位置相关：offset() / position() / scrollLeft() / scrollTop()</li></ul></li><li>特效和动画<ul><li>基本动画：show() / hide() / toggle()</li><li>消失出现：fadeIn() / fadeOut() / fadeTo() / fadeToggle()</li><li>滑动效果：slideDown() / slideUp() / slideToggle()</li><li>自定义：delay() / stop() / animate()</li></ul></li><li>事件<ul><li>文档加载：ready() / load()</li><li>用户交互：on() / off()</li></ul></li></ul><p><strong>回调函数</strong> </p><p>evt参数代表的是事件对象 - 绑定了和事件相关的所有信息</p><p>如果事件回调函数中要用到和事件相关的属性和方法就最好指定evt参数</p><ul><li>target / clientX / button / keyCode</li><li>preventDefault() / stopPropagation()</li></ul><p>不管函数是否指定了evt参数当事件发生回调该函数时都会传入该参数</p><p>调构造函数 前面加new</p><p>数组里删元素要从后往前循环</p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>原生Ajax - Asynchronous JavaScript and XML</p><p>让浏览器向服务器发出异步请求(非阻塞式请求)，等服务器返回了响应数据(JSON/XML)后就可以对页面进行局部刷</p><p>新，这样就可以在不中断用户体验的前提下刷新页面数据</p><ul><li>JavaScript发送HTTP请求获取数据默认只支持同源数据(同源策略)</li><li><a href="http://www.abc.com/index.html">http://www.abc.com/index.html</a>  -&gt; JavaScript</li><li>如果要跨域取数据是需要对方提供数据的服务器支持的</li><li>JSONP / 服务器端设置支持跨域取数据(RESTful)</li></ul></script></p></h1></h1>]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>通讯录</title>
      <link href="/2017/11/15/%E9%80%9A%E8%AE%AF%E5%BD%95/"/>
      <url>/2017/11/15/%E9%80%9A%E8%AE%AF%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>用 pymysql 写了一个简单的通讯录。</p><a id="more"></a> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#connection（连接）/ cursor（游标）</span></span><br><span class="line">conn = pymysql.connect(host=<span class="string">'localhost'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, </span><br><span class="line">                       passwd=<span class="string">'123456'</span>, db=<span class="string">'homework'</span>, charset=<span class="string">'utf8'</span>,</span><br><span class="line">                           cursorclass=pymysql.cursors.DictCursor)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contacts</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.cursor = conn.cursor()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self)</span>:</span></span><br><span class="line">        name = input(<span class="string">'姓名:'</span>)</span><br><span class="line">        tel = input(<span class="string">'电话号码:'</span>)</span><br><span class="line">        addr = input(<span class="string">'地址:'</span>)</span><br><span class="line">        birth = input(<span class="string">'出生日期:'</span>)</span><br><span class="line">        result = self.cursor.execute(<span class="string">'insert into tb_contacts </span></span><br><span class="line"><span class="string">                 (cname, ctel, caddr, cbirth) values (%s, %s, %s, %s)'</span></span><br><span class="line">                  , (name, tel, addr, birth))</span><br><span class="line">        print(<span class="string">'添加成功'</span> <span class="keyword">if</span> result == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'添加失败'</span>)</span><br><span class="line">        conn.commit()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.cursor.execute(<span class="string">'select cname 姓名, ctel 电话, caddr 地址,</span></span><br><span class="line"><span class="string">        cbirth 出生日期 from tb_contacts </span></span><br><span class="line"><span class="string">                     where cname like (%s)'</span>, (name))</span><br><span class="line">        result = self.cursor.fetchone()</span><br><span class="line">        print(result <span class="keyword">if</span> result <span class="keyword">else</span> <span class="string">'没有该联系人'</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self)</span>:</span></span><br><span class="line">        name = input(<span class="string">'姓名:'</span>)</span><br><span class="line">        <span class="keyword">if</span> self.search(name):</span><br><span class="line">            result = self.cursor.execute(<span class="string">'delete from tb_contacts </span></span><br><span class="line"><span class="string">                     where cname=%s'</span>, (name,))</span><br><span class="line">            t = input(<span class="string">'确认删除？(确认请输入: y)'</span>)</span><br><span class="line">            <span class="keyword">if</span>  t == <span class="string">'y'</span> <span class="keyword">or</span> t == <span class="string">'Y'</span>:</span><br><span class="line">                print(<span class="string">'删除成功'</span> <span class="keyword">if</span> result == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'删除失败'</span>)</span><br><span class="line">                conn.commit()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'取消删除'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">(self)</span>:</span></span><br><span class="line">        name = input(<span class="string">'需要编辑的联系人姓名:'</span>)</span><br><span class="line">        <span class="keyword">if</span> self.search(name):</span><br><span class="line">            judg = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">while</span> judg:</span><br><span class="line">                num = int(input(<span class="string">'请输入编辑项:1.姓名 2.电话 </span></span><br><span class="line"><span class="string">                                3.地址 4.出生日期 5.退出 \n:'</span>))</span><br><span class="line">                <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">                    m_name = input(<span class="string">'姓名:'</span>)</span><br><span class="line">                    result = self.cursor.execute(<span class="string">'update tb_contacts </span></span><br><span class="line"><span class="string">                             set cname=%s where cname=%s'</span>,(m_name, name))</span><br><span class="line">                    print(<span class="string">'已更改'</span> <span class="keyword">if</span> result ==<span class="number">1</span> <span class="keyword">else</span> <span class="string">'更改失败'</span>)</span><br><span class="line">                    conn.commit()</span><br><span class="line">                    self.search(m_name)</span><br><span class="line">                <span class="keyword">elif</span> num == <span class="number">2</span>:</span><br><span class="line">                    m_tel = input(<span class="string">'电话:'</span>)</span><br><span class="line">                    result = self.cursor.execute(<span class="string">'update tb_contacts </span></span><br><span class="line"><span class="string">                            set ctel=%s where cname=%s'</span>, (m_tel, name))</span><br><span class="line">                    print(<span class="string">'已更改'</span> <span class="keyword">if</span> result == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'更改失败'</span>)</span><br><span class="line">                    conn.commit()</span><br><span class="line">                    self.search(name)</span><br><span class="line">                <span class="keyword">elif</span> num == <span class="number">3</span>:</span><br><span class="line">                    m_addr = input(<span class="string">'地址:'</span>)</span><br><span class="line">                    result = self.cursor.execute(<span class="string">'update tb_contacts </span></span><br><span class="line"><span class="string">                             set caddr=%s where cname=%s'</span>, (m_addr, name))</span><br><span class="line">                    print(<span class="string">'已更改'</span> <span class="keyword">if</span> result == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'更改失败'</span>)</span><br><span class="line">                    conn.commit()</span><br><span class="line">                    self.search(name)</span><br><span class="line">                <span class="keyword">elif</span> num == <span class="number">4</span>:</span><br><span class="line">                    m_birth = input(<span class="string">'地址:'</span>)</span><br><span class="line">                    result = self.cursor.execute(<span class="string">'update tb_contacts </span></span><br><span class="line"><span class="string">                             set cbirth=%s where cname=%s'</span>, (m_birth, name))</span><br><span class="line">                    print(<span class="string">'已更改'</span> <span class="keyword">if</span> result == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'更改失败'</span>)</span><br><span class="line">                    conn.commit()</span><br><span class="line">                    self.search(name)</span><br><span class="line">                <span class="keyword">elif</span> num == <span class="number">5</span>:</span><br><span class="line">                    judg = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'没有该联系人请选择添加'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.cursor.execute(<span class="string">'select cname 姓名, ctel 电话, caddr 地址, </span></span><br><span class="line"><span class="string">                   cbirth 出生日期  from tb_contacts'</span>)</span><br><span class="line">        result = self.cursor.fetchall()</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> result:</span><br><span class="line">            print(a)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'通讯录：\n1.添加 \n2.查询 \n3.删除 \n4.编辑 \n5.查看所有联系人 </span></span><br><span class="line"><span class="string">          \n6.退出 '</span>)</span><br><span class="line">contact = Contacts()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    menu()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                put = int(input(<span class="string">'请输入相应数字操作:'</span>))</span><br><span class="line">                <span class="keyword">if</span> put == <span class="number">1</span>:</span><br><span class="line">                    contact.add()</span><br><span class="line">                <span class="keyword">elif</span> put == <span class="number">2</span>:</span><br><span class="line">                    name = input(<span class="string">'姓名:'</span>)</span><br><span class="line">                    contact.search(name)</span><br><span class="line">                <span class="keyword">elif</span> put == <span class="number">3</span>:</span><br><span class="line">                    contact.delete()</span><br><span class="line">                <span class="keyword">elif</span> put == <span class="number">4</span>:</span><br><span class="line">                    contact.modify()</span><br><span class="line">                <span class="keyword">elif</span> put == <span class="number">5</span>:</span><br><span class="line">                    contact.all()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">elif</span> put == <span class="number">6</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                    <span class="comment"># conn.close()</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">'输入无效'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 小练习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python学习</title>
      <link href="/2017/10/25/python%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/10/25/python%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><code>数字型(Number)</code> <code>字符型(String)</code> <code>布尔型(boolean)</code> <code>空类型(None)</code> <code>列表型(list)</code> <code>元组型(tuple)</code> <code>字典型(dict)</code> <code>集合型(set)</code></p><h3 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h3><p>Python3 中有六个标准的数据类型：<br>    Number（数字）<br>    String（字符串）<br>    List（列表）<br>    Tuple（元组）<br>    Dictionary（字典）<br>    Sets（集合）</p><a id="more"></a> <h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>对变量类型进行转换时可以使用Python的内置函数</p><ul><li>int()：将一个数值或字符串转换成整数，可以指定进制。</li><li>float()：将一个字符串转换成浮点数。</li><li>str()：将指定的对象转换成字符串形式，可以指定编码。</li><li>chr()：将整数转换成该编码对应的字符串（一个字符）。</li><li>ord()：将字符串（一个字符）转换成对应的编码（整数）。</li></ul><hr><h3 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h3><p><code>整型(Int)</code> - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。<br><code>浮点型(float)</code>  - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）<br><code>复数(complex)</code>  - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型</p><h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><p>函数            返回值 ( 描述 )<br><code>abs(x)</code>            返回数字的绝对值，如abs(-10) 返回 10<br><code>ceil(x)</code>        返回数字的上入整数，如math.ceil(4.1) 返回 5<br><code>cmp(x, y)</code>        如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 Python 3 已废弃 。使用 使用 (x&gt;y)-                         (x&lt;y) 替换。</p><p><code>exp(x)</code>            返回e的x次幂(ex),    如math.exp(1) 返回2.718281828459045<br><code>fabs(x)</code>        返回数字的绝对值，如math.fabs(-10) 返回10.0<br><code>floor(x)</code>        返回数字的下舍整数，如math.floor(4.9)返回 4<br><code>log(x)</code>            如math.log(math.e)返回1.0,math.log(100,10)返回2.0<br><code>log10(x)</code>        返回以10为基数的x的对数，如math.log10(100)返回 2.0<br><code>max(x1, x2,...)</code>    返回给定参数的最大值，参数可以为序列。<br><code>min(x1, x2,...)</code>    返回给定参数的最小值，参数可以为序列。<br><code>modf(x)</code>        返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。<br><code>pow(x, y)</code>        x**y 运算后的值。<br><code>round(x [,n])</code>    返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。<br><code>sqrt(x)</code>        返回数字x的平方根。</p><hr><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p><strong>字符串常用内建函数</strong>        str1 = ‘’hello, world!’</p><p><code>str1.split( )</code>  通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串</p><p><code>len()</code>    len函数计算字符串的长度            <em>len(str1)       # 13</em></p><p><code>str1.capitalize()</code>    获得字符串首字母大写的拷贝         <em>str1.capitalize()  # Hello, world!</em></p><p><code>str1.upper()</code>    获得字符串变大写后的拷贝            <em>str1.upper()   # HELLO, WORLD!</em></p><p><code>str1.find(str2, beg=0 end=len(string))</code>        检测 str2 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;str1 = <span class="string">'abca'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(str1.find(<span class="string">'a'</span>))      <span class="comment"># 从下标0开始，查找在字符串里第一个出现的子串，返回结果：0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(str1.find(<span class="string">'a'</span>, <span class="number">1</span>))   <span class="comment"># 从下标1开始，查找在字符串里第一个出现的子串：返回结果3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(str1.find(<span class="string">'3'</span>))      <span class="comment"># 查找不到返回-1</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><code>index(str, beg=0, end=len(string))</code>    跟find()方法一样，只不过如果str不在字符串中会报一个异常.</p><p><code>str1.startswith(str2)</code>        检查字符串<strong>是否</strong>以指定的字符串开头         </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(str1.startswith(<span class="string">'He'</span>))  <span class="comment"># False</span></span><br><span class="line">print(str1.startswith(<span class="string">'hel'</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p><code>str1.endswith(str2)</code>        检查字符串<strong>是否</strong>以指定的字符串结尾</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(str1.endswith(<span class="string">'!'</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p><code>str1.center(width, &#39;=&#39;)</code>        将字符串以指定的<strong>宽度</strong>居中并在两侧填充指定的<strong>字符</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(str1.center(<span class="number">20</span>, <span class="string">'='</span>)) <span class="comment">#===hello, world!====</span></span><br></pre></td></tr></table></figure><p><u>rjust  ljust 右对齐/左对齐</u></p><p><code>str1.rjust(width, &#39; &#39;)</code>        将字符串以指定的<strong>宽度</strong>靠右放置左侧填充指定的<strong>字符</strong></p><p><code>str1.isdigit()</code>        检查字符串<strong>是否</strong>只由数字构成 ,返回 True 或 False</p><p><code>str1.isalpha()</code>         检查字符串<strong>是否</strong>只由字母构成 ,返回 True 或 False</p><p><code>str1.isalnum()</code>         检查字符串<strong>是否</strong>以数字和字母构成 ,返回 True 或 False</p><p><code>str1.strip()</code>     获得字符串修剪左右两侧空格的拷贝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">'      jackf1234@166.com  '</span></span><br><span class="line">print(str1.strip())                    <span class="comment"># jackf1234@166.com</span></span><br></pre></td></tr></table></figure><hr><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>list1 = [1, 3, 5, 7, 100]</p><p><code>len(list1)</code>        列表元素个数</p><p><code>list1.index(obj)</code>     从列表中找出某个值第一个匹配项的索引位置 </p><p><code>max(list1)</code>        返回列表元素最大值</p><p><code>min(list1)</code>        返回列表元素最小值</p><p><code>list(对象)</code>        将对象转换为列表 , 对象:字符串,元组,集合; 字典只能把键转成列表</p><p><code>list1.append(元素)</code>    在列表末尾添加新的元素<br><code>list1.insert(下标, 元素)</code>       在指定下标出添加一个元素,原来位置处的元素往后移动</p><p><code>list1.pop()</code>     将列表中指定<u>下标</u>的元素删除, 如果默认不传递参数,则删除的是最后一个元素</p><p><code>list1.remove()</code>     移除列表中指定的<u>元素</u></p><p><code>list1.clear()</code>     清除列表中所有的元素</p><p><code>list1.reverse()</code>     用于反向列表中元素  等同于[::-1]</p><p><em>reversed(seq) 函数返回一个反转的迭代器。</em> </p><p><em>seq – 要转换的序列，可以是 tuple, string, list 或 range</em></p><p><code>list1.sort()</code>    应用在 list 上的方法, 返回的是对已经存在的列表进行操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">45</span>, <span class="number">21</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># print(list1.sort()) 打印为None,没有返回值,只对原来列表排序</span></span><br><span class="line">list2 = list1.sort()</span><br><span class="line">print(list2)  <span class="comment">#结果还是为None </span></span><br><span class="line">print(list1)  <span class="comment">#[1, 2, 4, 7, 21, 45]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    0  1  2  3  4  5  6  7  8</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">b = a[<span class="number">7</span>:<span class="number">3</span>:<span class="number">-1</span>]</span><br><span class="line">print(b)<span class="comment">#[8, 7, 6, 5]</span></span><br><span class="line">print(a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">-1</span>]) <span class="comment">#None</span></span><br><span class="line">print(a[<span class="number">3</span>:<span class="number">1</span>:<span class="number">-1</span>]) <span class="comment">#[4, 3]</span></span><br></pre></td></tr></table></figure><hr><h3 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h3><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合</p><p><code>len(tuple)</code>    计算元组元素个数。</p><p><code>max(tuple)</code>    返回元组中元素最大值。</p><p><code>min(tuple)</code>    返回元组中元素最小值。</p><p><code>tuple(seq)</code>    将列表转换为元组。</p><hr><h3 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h3><p><strong>无序集合, key唯一,必须是不可变类型</strong><br>访问获取方式: </p><ul><li>​    dict[key]</li><li>​    dict.get(key)</li></ul><p>添加元素:</p><ul><li>​    dict[key] = value # key为原字典中不存在的键</li></ul><p>修改:</p><ul><li>​    dict[key] = balue # key为原字典中存在的键</li></ul><p>dict.keys() 以列表返回字典中所有的键<br>dict.values() 以列表返回字典中所有的值<br>dict.items() 以列表返回可遍历的(键, 值) 元组数组    [(键, 值), (键, 值), (键, 值)]<br>dict.setdefault() 返回指定键的值,如果键不存在于字典中，将会添加键并将值设为默认值<br>dict.pop([key]) 删除指定键值对, 需传入参数 # 没有remove()方法<br>enumerate()用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p><h4 id="字典内置函数"><a href="#字典内置函数" class="headerlink" title="字典内置函数"></a>字典内置函数</h4><p><em>dict1 = {‘name’:’shuaixiaohao’, ‘age’:22, ‘weight’:60}</em></p><p><code>len(dict)</code> 计算字典元素个数，即键的总数。</p><p><em>print(len(dict1))</em>         #  3</p><p><code>str(dict)</code> 输出字典，以可打印的字符串表示。</p><p><em>print(str(dict1))</em>        #{‘name’: ‘shuaixiaohao’, ‘age’: 22, ‘weight’: 60}<br><em>print(type(str(dict1)))</em>    #<class 'str'=""></class></p><p><code>type(variable)</code> 返回输入的变量类型，如果变量是字典就返回字典类型。</p><h4 id="字典内置函数-1"><a href="#字典内置函数-1" class="headerlink" title="字典内置函数"></a>字典内置函数</h4><p><code>radiansdict.clear()</code><br>删除字典内所有元素<br><code>radiansdict.copy()</code><br>返回一个字典的浅复制<br><code>radiansdict.fromkeys()</code><br>创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值<br><code>radiansdict.get(key, default=None)</code><br>返回指定键的值，如果值不在字典中返回default值<br><code>key in dict</code><br>如果键在字典dict里返回true，否则返回false<br><code>radiansdict.items()</code><br>以列表返回可遍历的(键, 值) 元组数组<br><code>radiansdict.keys()</code><br>以列表返回一个字典所有的键<br><code>radiansdict.setdefault(key, default=None)</code><br>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default<br><code>radiansdict.update(dict2)</code><br>把字典dict2的键/值对更新到dict里<br><code>radiansdict.values()</code><br>以列表返回字典中的所有值<br><code>pop(key[,default])</code><br>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。<br><code>popitem()</code><br>随机返回并删除字典中的一对键和值(一般删除末尾对)。</p><hr><h3 id="Sets（集合）"><a href="#Sets（集合）" class="headerlink" title="Sets（集合）"></a>Sets（集合）</h3><p>set是无序,没有重复元素<br>set集合是不可改变的<br>创建一个空的集合 set1 = set(());    set1 = set([]);    set1 = set({})                                                 <u>注意：如果要创建一个空集合，你必须用 set() 而不是 {} ；后者创建一个空的字典</u><br>set.add(): 增加一个元素(重复元素不能添加) # 没有append()方法<br>set.remove():删除元素, 参数是元素<br>set.pop():删除最后一个元素<br>set1 &amp; set2 交集<br>set1 | set2 并集<br>set1 - set2 差集<br>set1 ^ set2 交并集</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict--&gt;set 取字典的键, 传入集合</span><br><span class="line">set --&gt; dict(错误)  # 不能将集合转换成字典, 只有键, 没有值</span><br></pre></td></tr></table></figure><hr><h3 id="三元条件运算"><a href="#三元条件运算" class="headerlink" title="三元条件运算"></a>三元条件运算</h3><p>python中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value1 <span class="keyword">if</span> condition <span class="keyword">else</span> value2</span><br></pre></td></tr></table></figure><p>JavaScript中:  <strong>conditon ? valuel1 : value2</strong> 问号前面的条件如果成立</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getStyle(elem) &#123;</span><br><span class="line">return window.getComputedStyle ? window.getComputedStyle(elem): elem.currentStyle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器是一个可以记住遍历的位置的对象。</p><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p>迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()</strong>。</p><p><u>字符串，列表或元组对象都可用于创建迭代器</u></p><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p> <strong>yield</strong> 函数被称为生成器（generator）, 生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器 , 每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。调用一个生成器函数，返回的是一个迭代器对象。</p><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>*args    <strong>可变参数</strong>(参数不确定) - 元组</p><p>**kwargs    <strong>关键字参数</strong>(给了参数名和参数值的参数) - 字典 </p><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>python 使用 lambda 来创建匿名函数。</p><p>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression  <span class="comment">#arg-参数 ,expression-表达式</span></span><br></pre></td></tr></table></figure><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的</p><ul><li>L （Local） 局部作用域</li><li>E （Enclosing） 闭包函数外的函数中</li><li>G （Global） 全局作用域</li><li>B （Built-in） 内建作用域</li></ul><p>以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。</p><h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域</p><p>global 和 nonlocal关键字</p><p>当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.choice():返回列表,元祖,字典中的某一个值</span><br><span class="line">random.choices():返回列表,元祖,字典中的指定个数值个值 k 关键字参数</span><br><span class="line">random.random():返回<span class="number">0</span><span class="number">-1</span>之间的数,  [<span class="number">0</span>, <span class="number">1</span>)  </span><br><span class="line">random.uniform():返回指定的一个区间范围的随机数 [, )</span><br><span class="line">random.randint():返回指定区间范围的随机整数 [, ]</span><br><span class="line">random.shuffle():将列表中的数据进行打乱排序</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 不定长参数: *args</span><br><span class="line">2. 关键字参数: **kw</span><br><span class="line">3. 偏函数: 导入模块 import functools</span><br><span class="line">        functools.partical()就是创建一个新的函数.不需要自行定义函数.直接将结果赋值给一个变量,而  这个变量就是一个函数.这个函数的目的是将默认参数给固定住</span><br><span class="line">4. 回调函数: 定义函数时,将函数名作为参数传递过来,然后在函数里边再次调用函数</span><br></pre></td></tr></table></figure><h4 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h4><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><table><thead><tr><th>符号</th><th>解释</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意字符</td><td>b.t</td><td>可以匹配bat / but / b#t / b1t等</td></tr><tr><td>\w</td><td>匹配字母/数字/下划线</td><td>b\wt</td><td>可以匹配bat / b1t / b_t等但不能匹配b#t</td></tr><tr><td>\s</td><td>匹配空白字符（包括\r、\n、\t等）</td><td>love\syou</td><td>可以匹配love you</td></tr><tr><td>\d</td><td>匹配数字</td><td>\d\d</td><td>可以匹配01 / 23 / 99等</td></tr><tr><td>\b</td><td>匹配单词的边界</td><td>\bThe\b</td><td></td></tr><tr><td>^</td><td>匹配字符串的开始</td><td>^The</td><td>可以匹配The开头的字符串</td></tr><tr><td>\</td><td>匹配字符串的结束\</td><td>.exe\</td><td>匹配字符串的结束\</td><td>.exe</td><td>可以匹配.exe结尾的字符串</td><td></td><td></td></tr><tr><td>\W</td><td>匹配非字母/数字/下划线</td><td>b\Wt</td><td>可以匹配b#t / b@t等但不能匹配but / b1t / b_t等</td></tr><tr><td>\S</td><td>匹配非空白字符</td><td>love\Syou</td><td>可以匹配love#you等但不能匹配love you</td></tr><tr><td>\D</td><td>匹配非数字</td><td>\d\D</td><td>可以匹配9a / 3# / 0F等</td></tr><tr><td>\B</td><td>匹配非单词边界</td><td>\Bio\B</td><td></td></tr><tr><td>[]</td><td>匹配来自字符集的任意单一字符</td><td>[aeiou]</td><td>可以匹配任一元音字母字符</td></tr><tr><td>[^]</td><td>匹配不在字符集中的任意单一字符</td><td>[^aeiou]</td><td>可以匹配任一非元音字母字符</td></tr><tr><td>*</td><td>匹配0次或多次</td><td>\w*</td><td></td></tr><tr><td>+</td><td>匹配1次或多次</td><td>\w+</td><td></td></tr><tr><td>?</td><td>匹配0次或1次</td><td>\w?</td><td></td></tr><tr><td>{N}</td><td>匹配N次</td><td>\w{3}</td><td></td></tr><tr><td>{M,}</td><td>匹配至少M次</td><td>\w{3,}</td><td></td></tr><tr><td>{M,N}</td><td>匹配至少M次至多N次</td><td>\w{3,6}</td><td></td></tr><tr><td>\</td><td></td><td>分支</td><td>foo\</td><td>bar</td><td>可以匹配foo或者bar</td></tr><tr><td>(?#)</td><td>注释</td><td></td><td></td></tr><tr><td>(exp)</td><td>匹配exp并捕获到自动命名的组中</td><td></td><td></td></tr><tr><td>(?\<name>exp)</name></td><td>匹配exp并捕获到名为name的组中</td><td></td><td></td></tr><tr><td>(?:exp)</td><td>匹配exp但是不捕获匹配的文本</td><td></td><td></td></tr><tr><td>(?=exp)</td><td>匹配exp前面的位置</td><td>\b\w+(?=ing)</td><td>可以匹配I’m dancing中的danc</td></tr><tr><td>(?&lt;=exp)</td><td>匹配exp后面的位置</td><td>(?&lt;=\bdanc)\w+\b</td><td>可以匹配I love dancing and reading中的第一个ing</td></tr><tr><td>(?!exp)</td><td>匹配后面不是exp的位置</td><td></td><td></td></tr><tr><td>(?</td><td>匹配前面不是exp的位置</td><td></td><td></td></tr><tr><td>*?</td><td>重复任意次，但尽可能少重复</td><td>a.<em>ba.</em>?b</td><td>将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串</td></tr><tr><td>+?</td><td>重复1次或多次，但尽可能少重复</td><td></td><td></td></tr><tr><td>??</td><td>重复0次或1次，但尽可能少重复</td><td></td><td></td></tr><tr><td>{M,N}?</td><td>重复M到N次，但尽可能少重复</td><td></td><td></td></tr><tr><td>{M,}?</td><td>重复M次以上，但尽可能少重复</td><td></td></tr></tbody></table><p><strong>re模块中的核心函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">re.match(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line">pattern匹配的正则表达式</span><br><span class="line">string要匹配的字符串</span><br><span class="line">flags标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</span><br></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>compile(pattern, flags=0)</td><td>编译正则表达式返回正则表达式对象</td></tr><tr><td>match(pattern, string, flags=0)</td><td>用正则表达式匹配字符串 成功返回匹配对象 否则返回None</td></tr><tr><td>search(pattern, string, flags=0)</td><td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None</td></tr><tr><td>split(pattern, string, maxsplit=0, flags=0)</td><td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td></tr><tr><td>sub(pattern, repl, string, count=0, flags=0)</td><td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数</td></tr><tr><td>fullmatch(pattern, string, flags=0)</td><td>match函数的完全匹配（从字符串开头到结尾）版本</td></tr><tr><td>findall(pattern, string, flags=0)</td><td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td></tr><tr><td>finditer(pattern, string, flags=0)</td><td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td></tr><tr><td>purge()</td><td>清除隐式编译的正则表达式的缓存</td></tr><tr><td>re.I / re.IGNORECASE</td><td>忽略大小写匹配标记</td></tr><tr><td>re.M / re.MULTILINE</td><td>多行匹配标记</td></tr></tbody></table><hr><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>面向对象的三个基本特征是：封装、继承、多态</strong> </p><p><strong>封装：</strong></p><p>​    封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。被封装的对象通常被称为抽象数据类型。 <strong><em>隐藏复杂的现实细节，暴露简单的调用接口。</em></strong></p><p>封装的意义：<br>　　封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。</p><ol><li>保护数据成员，不让类以外的程序直接访问或修改，只能通过提供的公共的接口访问==&gt;数据封装。</li><li>方法的细节对用户是隐藏的，只要接口不变，内容的修改不会影响到外部的调用者==&gt;方法封装。 </li><li>当对象含有完整的属性和与之对应的方法时称为封装。</li><li>从对象外面不能直接访问对象的属性，只能通过和该属性对应的方法访问。</li><li>对象的方法可以接收对象外面的消息。</li></ol><p><strong>继承：</strong></p><p>​    从已有的类创建新类的过程 提供继承信息的称为父类(超类/基类) 得到继承信息的称为子类(派生类)。继承主要实现重用代码，节省开发时间。</p><ol><li>在类名后边的括号里一般写的是基类的类名</li><li>子类中继承自父类(基类),则父类的成员属性和成员方法都可以被子类所继承</li><li>父类中私有的成员属性不能继承给子类的</li></ol><p><strong>多态：</strong></p><p>“一个接口，多种方法”</p><p>​    同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</p><p>多态的三个条件:</p><ol><li>继承的存在(继承是多态的基础,没有继承就没有多态)</li><li>子类重写父类的方法(多态下调用子类重写的方法)</li><li>父类引用变量指向子类对象(子类到父类的类型转换)</li></ol><p><strong>数据抽象</strong>一找到和对象相关的数据一属性( 名词）</p><p><strong>行为抽象</strong>一  找到和对象相关的行为一方法（动词）</p><p> <strong>__slots__</strong></p><p>​    限定自定义类型的对象只能绑定某些属性，可以通过在类中定义_<em>slots\</em>_变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 限定Person对象只能绑定_name, _age和_gender属性</span></span><br><span class="line">    __slots__ = (<span class="string">'_name'</span>, <span class="string">'_age'</span>, <span class="string">'_gender'</span>)</span><br></pre></td></tr></table></figure><h3 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h3><p>区分开函数和方法的含义：</p><p>　　1.函数：类外部定义的，跟类没有直接关系的；形式： def func(*argv):</p><p>　　2.方法：class内部定义的函数（对象的方法也可以认为是属性）；分为两种：</p><p>　　　　① python自动产生的（魔法方法）：一般形式为 __func__()，python会在对应的时机自动调用该函数；</p><p>　　　　② 人为自定义的方法：一般和普通函数没有区别，只是定义在了class中而已</p><p>　　3.方法与函数的区别：</p><p>　　　　方法可认为是函数的特殊情况；</p><p>　　　　① 方法定义在class内部</p><p>　　　　② 方法的第一个参数应为 cls(类方法) 或者 self(实例方法)</p><p>列出几个基本魔法方法：</p><p><strong>__new__(cls[,*argv])</strong> </p><ul><li>__new__ 是在一个对象实例化的时候所调用的第一个方法 </li><li>它的第一个参数是这个类，其他的参数是用来直接传递给 __init__ 方法 </li><li>_<em>new__ 决定是否要使用该 \</em>_init__方法，因为 __new__ 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __new__ 没有返回实例对象，则 __init__ 不会被调用 </li><li>__new__ 主要是用于继承一个不可变的类型比如一个 tuple 或者 string </li></ul><p><strong>__init__(self,[…])</strong> </p><ul><li><p>类的初始化方法 ，当一个实例对象被定义时调用 </p><p>*__del__(self)**    </p></li><li><p>析构器，当一个实例被析构时调用 </p></li><li><p>_<em>new__ 和 \</em>_init__ 是对象的构造器， __del__ 是对象的销毁器 </p></li></ul><h3 id="Python内置装饰器"><a href="#Python内置装饰器" class="headerlink" title="Python内置装饰器"></a>Python内置装饰器</h3><p>在Python中有三个内置的装饰器，都是跟class相关的：<strong>staticmethod</strong>、<strong>classmethod</strong> 和<strong>property</strong>。</p><ul><li><strong>staticmethod</strong> 是类静态方法，其跟成员方法的区别是没有 self 参数，并且可以在类不进行实例化的情况下调用</li><li><strong>classmethod</strong> 与成员方法的区别在于所接收的第一个参数不是 self （类实例的指针），而是cls（当前类的具体类型）</li><li><strong>property</strong> 是属性的意思，表示可以通过通过类实例直接访问的信息</li></ul><p>类方法、静方法        都是通过给类发消息来调用的             </p><p>实例方法                发给对象的消息 在类创建对象后，实例方法才能被使用，使用格式为：对象名.实例方法</p><p>​                    名。实例方法可以使用该方法所在类的所有静态成员和实例成员。 </p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'try...'</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">    print(<span class="string">'result:'</span>, r)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'except:'</span>, e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'finally...'</span>)</span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure><p>try语句按照如下方式工作；</p><ul><li>首先，执行try子句（在关键字try和关键字except之间的语句）</li><li>如果没有异常发生，忽略except子句，try子句执行后结束。</li><li>如果在<u>执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略</u>。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。</li><li>如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。</li><li>无论有没有异常<strong>finally</strong>语句被执行。</li></ul><p>一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p><p>处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。</p><p>一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> (RuntimeError, TypeError, NameError):</span><br><span class="line">       <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>​    try except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行 </p><p>​    使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。<br>    异常处理并不仅仅处理那些直接发生在try子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="读、写文件"><a href="#读、写文件" class="headerlink" title="读、写文件"></a>读、写文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(filename, mode)</span><br></pre></td></tr></table></figure><p>mode：决定了打开文件的模式：只读，写入，追加等    </p><p><em>操作模式        具体含义</em><br>    <strong>‘r’</strong>            读取 （默认）<br>    <strong>‘w’</strong>            写入（会先截断之前的内容）<br>    <strong>‘x’</strong>            写入，如果文件已经存在会产生异常<br>    <strong>‘a’</strong>            追加，将内容写入到已有文件的末尾<br>    <strong>‘b’</strong>            二进制模式<br>    <strong>‘t’</strong>            文本模式（默认）<br>    <strong>‘+’</strong>            更新（既可以读又可以写）</p><p><code>with</code>语句来自动帮我们调用<code>close()</code>方法 （关闭文件）</p><p>with 语句就可以保证文件之类的对象在使用完之后一定会正确的执行他的清理方法 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"myfile.txt"</span>) <span class="keyword">as</span> f:</span><br></pre></td></tr></table></figure><h3 id="文件对象的方法"><a href="#文件对象的方法" class="headerlink" title="文件对象的方法"></a>文件对象的方法</h3><p><strong>fileObject.read([size])</strong>  </p><p>​    从文件读取指定的字节数，如果未给定或为负则读取所有。</p><p><strong>fileObject.write()</strong> </p><p>​    写文件 # 如果要写入字符串以外的数据,先将他转换为字符串</p><p><strong>fileObject.close()</strong>  </p><p>​    关闭文件</p><p><strong>fileObject.readline([size])</strong> </p><p>​    读取整行内容,包括\n字符, 如果给定参数则从文件开始读取指定的字符个数</p><p><strong>fileObject.readlines([sizeint])</strong> </p><p>​    读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</p><p><strong>f.tell()</strong> </p><p>​    返回一个整数,表示当前文件指针的位置(就是到文件头的比特数).</p><p><strong>f.seek(偏移量,[起始位置])</strong> </p><p>​    用来移动文件指针 #偏移量:单位:比特,可正可负起始位置:0-文件头,默认值;1-当前位置;2-文件尾</p><h3 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h3><p><strong>os模块</strong>:在这个模块中给我们封装好了系统操作的功能函数(方法)</p><p>import os </p><ul><li>os.getcwd() 返回当前的工作目录 # 获取绝对路径</li><li>os.listdir(path) 返回指定的文件夹包含的文件或文件夹的名字的列表 </li><li>os.mkdir(path) 在当前目录下创建新的目录</li><li>os.rmdir(path) 删除目录, 只能删除空目录</li><li>os.rename(src, dst) 对文件进行重命名</li><li>os.stat(file) 获取文件属性</li><li>os.remove(file) 删除文件 #可以将本文件删除</li><li>os.path.join(path1, path2) 路径拼接</li><li>os.path.split(path) 拆分路径 # 返回一个元组(目录, 最后一个文件/目录名称)</li><li>os.path.splitext(path) 获取文件的或站名</li><li>os.path.exists(path) 判断文件/目录是否存在</li><li>os.path.isfile(path) 判断是否是文件</li><li>os.path.getsize(file) 获取文件的大小</li><li>os.path.dirname(path) 获取当前文件的目录</li><li>os.path.basename(path) 获取当前文件/目录名</li></ul><h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><p>很多时候，数据读写不一定是文件，也可以在内存中读写 </p><ol><li>StringIO模块主要用于在<strong>内存</strong>缓冲区中读写数据。模块是用类编写的，只有一个StringIO类，  </li><li># 所以它的可用方法都在类中。此类中的大部分函数都与对文件的操作方法类似。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hello'</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">' '</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'world!'</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue())</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p><strong>getvalue()</strong>方法用于获得写入后的str。 </p><h3 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h3><p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。</p><p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue())</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br></pre></td></tr></table></figure><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p><strong>进程</strong>：是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位 </p><p><strong>线程</strong>：是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源 </p><p>一个程序至少有一个进程,一个进程至少有一个线程。<strong>线程</strong>是最小的执行单元，而<strong>进程</strong>由至少一个线程组成。 </p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>​    Unix/Linux操作系统提供了一个<strong>fork()</strong>系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是<strong>fork()</strong>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 <u>fork()是os模块里的函数</u>。</p><p>​    子进程永远返回 <strong>0</strong>，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用<strong>getppid()</strong>就可以拿到父进程的ID。 </p><p><em><u>Windows没有 fork调用</u></em>，<strong>multiprocessing</strong>模块就是跨平台版本的多进程模块。</p><p><strong>multiprocessing</strong>模块提供了一个<strong>Process</strong>类来代表一个进程对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())  <span class="comment">#getpid()取得进程识别码</span></span><br><span class="line">    p = Process(target=run_proc, args=(<span class="string">'test'</span>,))  <span class="comment">#创建一个Process实例</span></span><br><span class="line">    print(<span class="string">'Child process will start.'</span>)</span><br><span class="line">    p.start()  <span class="comment">#启动子进程</span></span><br><span class="line">    p.join()<span class="comment">#等待子进程结束后再继续往下运行</span></span><br><span class="line">    print(<span class="string">'Child process end.'</span>)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent process <span class="number">928.</span></span><br><span class="line">Process will start.</span><br><span class="line">Run child process test (<span class="number">929</span>)...</span><br><span class="line">Process end.</span><br></pre></td></tr></table></figure><p><em>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用 <code>start()</code>方法启动。</em></p><p><em><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步</em> </p><h4 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h4><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>Python的标准库提供了两个模块：<code>_thread</code> 和 <code>threading</code>，<code>_thread</code> 是低级模块，<code>threading</code> 是高级模块，对  <code>_thread</code> 进行了封装。绝大多数情况下，我们只需要使用 <code>threading</code> 这个高级模块。 </p><p>启动一个线程就是把一个函数传入并创建 <code>Thread</code> 实例，然后调用 <code>start()</code> 开始执行 </p><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>协议- protocol- 通信双方对话的规范和标准</p><p>IP.Internet Protocol- 寻址和路由<br><a href="http://www.baidu.com---&gt;" target="_blank" rel="noopener">www.baidu.com---&gt;</a> 180.97.33.108</p><p>TCP和UDP是在IP协议之上构建的传输协议它们能够提供传输数据的服务<br>TCP提供了可靠传输服务<br>TCP- Transfer Control Protocol<br>握手机制+冗余校验—&gt; 重发一次</p><p>TCP.Transfer Control Protocol  I<br>1.可靠通信[数据不传丢也不传错]<br>滑动窗口机制<br>2.流量控制(自动调节发送数据的速度<br>3.拥塞控制(网络拥堵时会降低发送速度)</p><p>  QQ 微信.应用级<br>QQ— ICQ— OICQ<br>HTTP— Hyper-Text Transfer Protocol<br>HTTPS— Secure<br>SMTP– Simple Mail Transfer Protocol<br>POP3— Post Office Protocol version 3<br>IMAP—Internet Mail Access Protocol<br>xerox— macintosh— Windows</p><p>URL— Uniform Resource Locator<br>协议://域名或IP地址:80/路径/资源名</p><p>网络API(应用程序编程接口) / 网络</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">requests.get()用于请求目标网站，类型是一个HTTPresponse类型</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">print(response.status_code) <span class="comment"># 打印状态码</span></span><br><span class="line">print(response.url) <span class="comment"># 打印请求url</span></span><br><span class="line">print(response.headers) <span class="comment"># 打印头信息</span></span><br><span class="line">print(response.cookies) <span class="comment"># 打印cookie信息</span></span><br><span class="line">print(response.text) <span class="comment">#以文本形式打印网页源码</span></span><br><span class="line">print(response.content) <span class="comment">#以字节流形式打印</span></span><br></pre></td></tr></table></figure><h3 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h3><p><strong>Socket</strong>是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。 </p><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建服务器发文件</span></span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> SEEK_END</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, SOCK_STREAM, AF_INET</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1.创建套接字对象并指定使用哪种传输服务</span></span><br><span class="line">    server = socket(family=AF_INET, type=SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 2.绑定IP地址和端口(区分不同的服务)</span></span><br><span class="line">    server.bind((<span class="string">'10.7.152.130'</span>, <span class="number">9090</span>))</span><br><span class="line">    <span class="comment"># 3.开启监听 - 监听客户端连接到服务器</span></span><br><span class="line">    server.listen(<span class="number">512</span>)</span><br><span class="line">    print(<span class="string">'服务器启动开始监听...'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'guido.jpg'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">        f.seek(<span class="number">0</span>, SEEK_END)<span class="comment">#设置文件读取指针在文件当前位置</span></span><br><span class="line">        file_len = f.tell()<span class="comment">#返回文件当前位置指针</span></span><br><span class="line">    <span class="comment"># 4.通过循环接收客户端的连接并作出相应的处理(提供服务)</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># accept方法是一个阻塞方法 如果没有客户端连接到服务器这个方法就会阻塞代码不会向下执行</span></span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        <span class="comment"># 5.发送数据</span></span><br><span class="line">        client.send(<span class="string">'guido.jpg'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        client.send(str(file_len).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> total &lt; file_len:</span><br><span class="line">            client.send(data[total:total+<span class="number">1024</span>])</span><br><span class="line">            total += <span class="number">1024</span></span><br><span class="line">            sleep(<span class="number">0.001</span>)</span><br><span class="line">        <span class="comment"># 6.断开连接</span></span><br><span class="line">        client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个socket</span></span><br><span class="line">    client = socket()</span><br><span class="line">    <span class="comment"># 建立连接:</span></span><br><span class="line">    client.connect((<span class="string">'10.7.152.130'</span>, <span class="number">9090</span>))</span><br><span class="line">    filename = client.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    print(filename)</span><br><span class="line">    file_len = int(client.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    print(file_len)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'C:/Users/Administrator/Desktop/'</span> + filename,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> total &lt; file_len:</span><br><span class="line">            date = client.recv(<span class="number">1024</span>)</span><br><span class="line">            f.write(date)</span><br><span class="line">            total += <span class="number">1024</span></span><br><span class="line">        print(<span class="string">'图片已保存'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h3>]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
